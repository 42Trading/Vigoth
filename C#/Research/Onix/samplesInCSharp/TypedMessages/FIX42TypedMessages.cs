#region Copyright
/*
* Copyright Onix Solutions Limited [OnixS]. All rights reserved.
*
* This software owned by Onix Solutions Limited [OnixS] and is protected by copyright law
* and international copyright treaties.
*
* Access to and use of the software is governed by the terms of the applicable ONIXS Software
* Services Agreement (the Agreement) and Customer end user license agreements granting
* a non-assignable, non-transferable and non-exclusive license to use the software
* for it's own data processing purposes under the terms defined in the Agreement.
*
* Except as otherwise granted within the terms of the Agreement, copying or reproduction of any part
* of this source code or associated reference material to any other location for further reproduction
* or redistribution, and any amendments to this copyright notice, are expressly prohibited.
*
* Any reproduction or redistribution for sale or hiring of the Software not in accordance with
* the terms of the Agreement is a violation of copyright law.
*/
#endregion

using System;

using System.Collections.Generic;

using FIXForge.NET.FIX;

using FIXForge.NET.FIX.FIX42;

namespace FIX42
{
		static class FieldSetExtension
		{
			#region DateTimeHelper
			private static System.DateTime ConverStringToDateTime(string v, string type)
			{
				switch (type)
				{
					case "UTCTimestamp":
						return System.DateTime.ParseExact(v, new string[] { "yyyyMMdd-HH:mm:ss.fff", "yyyyMMdd-HH:mm:ss" }, System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.AssumeUniversal);
					case "UTCDateOnly":
						return System.DateTime.ParseExact(v, new string[] { "yyyyMMdd" }, System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.AssumeUniversal);
					case "LocalMktDate":
						return System.DateTime.ParseExact(v, new string[] { "yyyyMMdd-HH:mm:ss.fff", "yyyyMMdd-HH:mm:ss" }, System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.AssumeLocal);
					case "TZTimestamp":
						DateTime? res = ParseTZTimestamp(v);
						if (res.HasValue) 
							return res.Value; 
						else 
							throw new Exception("Cannot parse TZTimestamp value: " + v);
					default:
						throw new System.Exception("Unknown DateTime fix type: " + type);
				}
			}

			private static string ConvertDateTimeToString(string type, System.DateTime value)
			{
				switch (type)
				{
					case "UTCTimestamp":
						return value.ToUniversalTime().ToString("yyyyMMdd-HH:mm:ss.fff", System.Globalization.CultureInfo.InvariantCulture);
					case "UTCDateOnly":
						return value.ToUniversalTime().ToString("yyyyMMdd", System.Globalization.CultureInfo.InvariantCulture);
					case "LocalMktDate":
						return value.ToLocalTime().ToString("yyyyMMdd-HH:mm:ss.fff", System.Globalization.CultureInfo.InvariantCulture);
					case "TZTimestamp":
						return value.ToUniversalTime().ToString("yyyyMMdd-HH:mm:ss.fff", System.Globalization.CultureInfo.InvariantCulture);
					default:
						throw new System.Exception("Unknown DateTime fix type: " + type);
				}
			}		
			
			private static System.TimeSpan ConverStringToTimeSpan(string v, string type)
			{
				switch (type)
				{
					case "UTCTimeOnly":
						return System.DateTime.ParseExact(v, new string[] { "HH:mm:ss.fff", "HH:mm:ss" }, System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.AssumeUniversal).TimeOfDay;
					case "TZTimeOnly":
						TimeSpan? res = ParseTZTimeOnly(v);
						if (res.HasValue)
							return res.Value;
						else
							throw new Exception("Cannot parse TZTimeOnly value: " + v);
					default:
						throw new System.Exception("Unknown TimeSpan fix type: " + type);
				}
			}

			private static string ConvertTimeSpanToString(string type, System.TimeSpan value)
			{
				switch (type)
				{
					case "UTCTimeOnly":
						return value.ToString();
					case "TZTimeOnly":
						return value.ToString();
					default:
						throw new System.Exception("Unknown DateTime fix type: " + type);
				}
			}
			
			static System.Text.RegularExpressions.Regex timeRegex = new System.Text.RegularExpressions.Regex(@"(?<hh>\d{{2}})[:](?<mm>\d{{2}})([:](?<ss>\d{{2}})([.](?<fff>\d{{3}})?))?([Z]|([+](?<phh>\d{{2}})([:](?<pmm>\d{{2}}))?)|([-]((?<mhh>\d{{2}}))([:]((?<mmm>\d{{2}})))?))", System.Text.RegularExpressions.RegexOptions.Compiled);
			static System.Text.RegularExpressions.Regex timestampRegex = new System.Text.RegularExpressions.Regex(@"(?<yyyy>\d{{4}})(?<MM>\d{{2}})(?<dd>\d{{2}})[-](?<hh>\d{{2}})[:](?<mm>\d{{2}})([:](?<ss>\d{{2}})([.](?<fff>\d{{3}})?))?([Z]|([+](?<phh>\d{{2}})([:](?<pmm>\d{{2}}))?)|([-]((?<mhh>\d{{2}}))([:]((?<mmm>\d{{2}})))?))", System.Text.RegularExpressions.RegexOptions.Compiled);

			private static DateTime? ParseTZTimestamp(string value)
			{
				if (value == null) throw new ArgumentNullException("value");
				if (value.Length < 14) return null;

				System.Text.RegularExpressions.Match m = timestampRegex.Match(value);
				if (m == null)
					return null;

				if (m.Length != value.Length)
					return null;

				string yyyy = m.Groups["yyyy"].Value;
				string MM = m.Groups["MM"].Value;
				string dd = m.Groups["dd"].Value;

				string hh = m.Groups["hh"].Value;
				string mm = m.Groups["mm"].Value;
				string ss = m.Groups["ss"].Value;
				string fff = m.Groups["fff"].Value;

				string phh = m.Groups["phh"].Value;
				string pmm = m.Groups["pmm"].Value;
				string mhh = m.Groups["mhh"].Value;
				string mmm = m.Groups["mmm"].Value;

				short year, millisecond = 0;
				byte month, day, hour, minute, second = 0;

				if (short.TryParse(yyyy, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out year) == false) return null;
				if (byte.TryParse(MM, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out month) == false) return null;
				if (byte.TryParse(dd, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out day) == false) return null;
				if (year < 0 || year > 9999) return null;
				if (month < 1 || month > 12) return null;
				if (day < 1 || day > 31) return null;

				if (byte.TryParse(hh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out hour) == false) return null;
				if (byte.TryParse(mm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out minute) == false) return null;
				if (!string.IsNullOrEmpty(ss))
					if (byte.TryParse(ss, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out second) == false) return null;
				if (!string.IsNullOrEmpty(fff))
					if (short.TryParse(fff, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out millisecond) == false) return null;

				if (value.Contains("+"))
				{
					byte ihh;
					byte imm = 0;
					if (byte.TryParse(phh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out ihh) == false) return null;
					if (!string.IsNullOrEmpty(pmm))
						if (byte.TryParse(pmm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out imm) == false) return null;
					if (ihh < 1 || ihh > 12) return null;
					if (imm < 0 || imm > 59) return null;
					if (minute + imm > 59)
					{
						hour++;
						minute = (byte)(minute + imm - 59);
					}
					else
					{
						minute = (byte)(minute + imm);
					}
					if (hour + ihh > 23)
					{
						hour = (byte)(hour + ihh - 23);
					}
					else
					{
						hour = (byte)(hour + ihh);
					}
					if (hour < 0 || hour > 23)
						return null;
					if (minute < 0 || minute > 59)
						return null;
				}
				else if (value.LastIndexOf('-') > 10)
				{
					byte ihh;
					byte imm = 0;
					if (byte.TryParse(mhh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out ihh) == false) return null;
					if (!string.IsNullOrEmpty(mmm))
						if (byte.TryParse(mmm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out imm) == false) return null;
					if (ihh < 1 || ihh > 12) return null;
					if (imm < 0 || imm > 59) return null;
					if (minute - imm < 0)
					{
						hour--;
						minute = (byte)(minute - imm + 59);
					}
					else
					{
						minute = (byte)(minute - imm);
					}
					if (hour - ihh < 0)
					{
						hour = (byte)(hour - ihh + 23);
					}
					else
					{
						hour = (byte)(hour - ihh);
					}
					if (hour < 0 || hour > 23)
						return null;
					if (minute < 0 || minute > 59)
						return null;
				}

				DateTime dateTime = new DateTime(year, month, day, hour, minute, second, millisecond, DateTimeKind.Utc);
				return dateTime;
			}

			private static TimeSpan? ParseTZTimeOnly(string value)
			{
				if (value == null) throw new ArgumentNullException("value");
				if (value.Length < 5) return null;


				System.Text.RegularExpressions.Match m = timeRegex.Match(value);
				if (m == null)
					return null;

				if (m.Length != value.Length)
					return null;

				string hh = m.Groups["hh"].Value;
				string mm = m.Groups["mm"].Value;
				string ss = m.Groups["ss"].Value;
				string fff = m.Groups["fff"].Value;

				string phh = m.Groups["phh"].Value;
				string pmm = m.Groups["pmm"].Value;
				string mhh = m.Groups["mhh"].Value;
				string mmm = m.Groups["mmm"].Value;
		
				byte hour, minute, second = 0;
				short millisecond = 0;

				if (byte.TryParse(hh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out hour) == false) return null;
				if (byte.TryParse(mm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out minute) == false) return null;
				if (!string.IsNullOrEmpty(ss))
					if (byte.TryParse(ss, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out second) == false) return null;
				if (!string.IsNullOrEmpty(fff))
					if (short.TryParse(fff, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out millisecond) == false) return null;

				if (value.Contains("+"))
				{
					byte ihh;
					byte imm = 0;
					if (byte.TryParse(phh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out ihh) == false) return null;
					if (!string.IsNullOrEmpty(pmm))
						if (byte.TryParse(pmm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out imm) == false) return null;
					if (ihh < 1 || ihh > 12) return null;
					if (imm < 0 || imm > 59) return null;
					if (minute + imm > 59)
					{
						hour++;
						minute = (byte)(minute + imm - 59);
					}
					else
					{
						minute = (byte)(minute + imm);
					}
					if (hour + ihh > 23)
					{
						hour = (byte)(hour + ihh - 23);
					}
					else
					{
						hour = (byte)(hour + ihh);
					}
					if (hour < 0 || hour > 23)
						return null;
					if (minute < 0 || minute > 59)
						return null;
				}
				else if (value.Contains("-"))
				{
					byte ihh;
					byte imm = 0;
					if (byte.TryParse(mhh, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out ihh) == false) return null;
					if (!string.IsNullOrEmpty(mmm))
						if (byte.TryParse(mmm, System.Globalization.NumberStyles.Integer, System.Globalization.CultureInfo.InvariantCulture, out imm) == false) return null;
					if (ihh < 1 || ihh > 12) return null;
					if (imm < 0 || imm > 59) return null;
					if (minute - imm < 0)
					{
						hour--;
						minute = (byte)(minute - imm + 59);
					}
					else
					{
						minute = (byte)(minute - imm);
					}
					if (hour - ihh < 0)
					{
						hour = (byte)(hour - ihh + 23);
					}
					else
					{
						hour = (byte)(hour - ihh);
					}
					if (hour < 0 || hour > 23)
						return null;
					if (minute < 0 || minute > 59)
						return null;
				}

				TimeSpan result = new TimeSpan(0, hour, minute, second, millisecond);
				return result;
			}
			#endregion DateTimeHelper

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out double value)
			{
				return fieldSet.TryGetDouble(tag, out value);
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out string value)
			{
				if (fieldSet.Contain(tag)) { value = fieldSet.Get(tag); return true; }
				value = null;
				return false;
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out int value)
			{
				return fieldSet.TryGetInteger(tag, out value);
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out long value)
			{
				return fieldSet.TryGetLong(tag, out value);
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out char value)
			{
				return fieldSet.TryGetChar(tag, out value);
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, out bool value)
			{
				char v;
				if (fieldSet.TryGetChar(tag, out v)) return (value = (v == 'Y' || v == 'y'));
				return (value = false);
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, string type, out DateTime value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v)) { value = ConverStringToDateTime(v, type); return true; }
				value = default(DateTime);
				return false;
			}

			static public DateTime GetDateTime(this FieldSet fieldSet, int tag, string type)
			{
				return ConverStringToDateTime(fieldSet.Get(tag), type);
			}

			static public void Set(this FieldSet fieldSet, int tag, string type, DateTime value)
			{
				fieldSet.Set(tag, ConvertDateTimeToString(type, value));
			}

			static public bool TryGetValue(this FieldSet fieldSet, int tag, string type, out TimeSpan value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v)) { value = ConverStringToTimeSpan(v, type); return true; }
				value = default(TimeSpan);
				return false;
			}

			static public TimeSpan GetTimeSpan(this FieldSet fieldSet, int tag, string type)
			{
				return ConverStringToTimeSpan(fieldSet.Get(tag), type);
			}

			static public void Set(this FieldSet fieldSet, int tag, string type, TimeSpan value)
			{
				fieldSet.Set(tag, ConvertTimeSpanToString(type, value));
			}

			static public char GetChar(this FieldSet fieldSet, int tag)
			{
				char v;
				if (fieldSet.TryGetChar(tag, out v)) return v;
				throw new Exception("Cannot find char tag "+ tag);
			}

			static public bool TryGetMsgType(this FieldSet fieldSet, int tag, out MsgType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MsgType)v; return true; }
				value = default(MsgType);
				return false;
			}

			static public MsgType GetMsgType(this FieldSet fieldSet, int tag)
			{
				return (MsgType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MsgType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetPossDupFlag(this FieldSet fieldSet, int tag, out PossDupFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (PossDupFlag)v; return true; }
				value = default(PossDupFlag);
				return false;
			}

			static public PossDupFlag GetPossDupFlag(this FieldSet fieldSet, int tag)
			{
				return (PossDupFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, PossDupFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetPossResend(this FieldSet fieldSet, int tag, out PossResend value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (PossResend)v; return true; }
				value = default(PossResend);
				return false;
			}

			static public PossResend GetPossResend(this FieldSet fieldSet, int tag)
			{
				return (PossResend)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, PossResend value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMessageEncoding(this FieldSet fieldSet, int tag, out MessageEncoding value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "EUC-JP":
							value = MessageEncoding.EUCJP;
							break;
						case "ISO-2022-JP":
							value = MessageEncoding.ISO2022JP;
							break;
						case "Shift_JIS":
							value = MessageEncoding.ShiftJIS;
							break;
						case "UTF-8":
							value = MessageEncoding.UTF8;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(MessageEncoding).Name, v));
					}
					return true;
				}
				value = default(MessageEncoding);
				return false;
			}

			static public MessageEncoding GetMessageEncoding(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "EUC-JP":
						return MessageEncoding.EUCJP;
					case "ISO-2022-JP":
						return MessageEncoding.ISO2022JP;
					case "Shift_JIS":
						return MessageEncoding.ShiftJIS;
					case "UTF-8":
						return MessageEncoding.UTF8;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(MessageEncoding).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, MessageEncoding value)
			{
				switch (value)
				{
					case MessageEncoding.EUCJP:
						fieldSet.Set(tag, "EUC-JP");
						break;
					case MessageEncoding.ISO2022JP:
						fieldSet.Set(tag, "ISO-2022-JP");
						break;
					case MessageEncoding.ShiftJIS:
						fieldSet.Set(tag, "Shift_JIS");
						break;
					case MessageEncoding.UTF8:
						fieldSet.Set(tag, "UTF-8");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetIOITransType(this FieldSet fieldSet, int tag, out IOITransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IOITransType)v; return true; }
				value = default(IOITransType);
				return false;
			}

			static public IOITransType GetIOITransType(this FieldSet fieldSet, int tag)
			{
				return (IOITransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IOITransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIDSource(this FieldSet fieldSet, int tag, out IDSource value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IDSource)v; return true; }
				value = default(IDSource);
				return false;
			}

			static public IDSource GetIDSource(this FieldSet fieldSet, int tag)
			{
				return (IDSource)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IDSource value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSecurityType(this FieldSet fieldSet, int tag, out SecurityType value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "?":
							value = SecurityType.Wildcard;
							break;
						case "BA":
							value = SecurityType.BankersAcceptance;
							break;
						case "CB":
							value = SecurityType.ConvertibleBond;
							break;
						case "CD":
							value = SecurityType.CertificateOfDeposit;
							break;
						case "CMO":
							value = SecurityType.CollateralizedMortgageObligation;
							break;
						case "CORP":
							value = SecurityType.CorporateBond;
							break;
						case "CP":
							value = SecurityType.CommercialPaper;
							break;
						case "CPP":
							value = SecurityType.CorporatePrivatePlacement;
							break;
						case "CS":
							value = SecurityType.CommonStock;
							break;
						case "FHA":
							value = SecurityType.FederalHousingAuthority;
							break;
						case "FHL":
							value = SecurityType.FederalHomeLoan;
							break;
						case "FN":
							value = SecurityType.FederalNationalMortgageAssociation;
							break;
						case "FOR":
							value = SecurityType.ForeignExchangeContract;
							break;
						case "FUT":
							value = SecurityType.Future;
							break;
						case "GN":
							value = SecurityType.GovernmentNationalMortgageAssociation;
							break;
						case "GOVT":
							value = SecurityType.TreasuriesAgencyDebenture;
							break;
						case "IET":
							value = SecurityType.IOETTEMortgage;
							break;
						case "MF":
							value = SecurityType.MutualFund;
							break;
						case "MIO":
							value = SecurityType.MortgageInterestOnly;
							break;
						case "MPO":
							value = SecurityType.MortgagePrincipalOnly;
							break;
						case "MPP":
							value = SecurityType.MortgagePrivatePlacement;
							break;
						case "MPT":
							value = SecurityType.MiscellaneousPassThrough;
							break;
						case "MUNI":
							value = SecurityType.MunicipalBond;
							break;
						case "NONE":
							value = SecurityType.NoSecurityType;
							break;
						case "OPT":
							value = SecurityType.Option;
							break;
						case "PS":
							value = SecurityType.PreferredStock;
							break;
						case "RP":
							value = SecurityType.RepurchaseAgreement;
							break;
						case "RVRP":
							value = SecurityType.ReverseRepurchaseAgreement;
							break;
						case "SL":
							value = SecurityType.StudentLoanMarketingAssociation;
							break;
						case "TD":
							value = SecurityType.TimeDeposit;
							break;
						case "USTB":
							value = SecurityType.USTreasuryBillOld;
							break;
						case "WAR":
							value = SecurityType.Warrant;
							break;
						case "ZOO":
							value = SecurityType.CatsTigersAndLions;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SecurityType).Name, v));
					}
					return true;
				}
				value = default(SecurityType);
				return false;
			}

			static public SecurityType GetSecurityType(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "?":
						return SecurityType.Wildcard;
					case "BA":
						return SecurityType.BankersAcceptance;
					case "CB":
						return SecurityType.ConvertibleBond;
					case "CD":
						return SecurityType.CertificateOfDeposit;
					case "CMO":
						return SecurityType.CollateralizedMortgageObligation;
					case "CORP":
						return SecurityType.CorporateBond;
					case "CP":
						return SecurityType.CommercialPaper;
					case "CPP":
						return SecurityType.CorporatePrivatePlacement;
					case "CS":
						return SecurityType.CommonStock;
					case "FHA":
						return SecurityType.FederalHousingAuthority;
					case "FHL":
						return SecurityType.FederalHomeLoan;
					case "FN":
						return SecurityType.FederalNationalMortgageAssociation;
					case "FOR":
						return SecurityType.ForeignExchangeContract;
					case "FUT":
						return SecurityType.Future;
					case "GN":
						return SecurityType.GovernmentNationalMortgageAssociation;
					case "GOVT":
						return SecurityType.TreasuriesAgencyDebenture;
					case "IET":
						return SecurityType.IOETTEMortgage;
					case "MF":
						return SecurityType.MutualFund;
					case "MIO":
						return SecurityType.MortgageInterestOnly;
					case "MPO":
						return SecurityType.MortgagePrincipalOnly;
					case "MPP":
						return SecurityType.MortgagePrivatePlacement;
					case "MPT":
						return SecurityType.MiscellaneousPassThrough;
					case "MUNI":
						return SecurityType.MunicipalBond;
					case "NONE":
						return SecurityType.NoSecurityType;
					case "OPT":
						return SecurityType.Option;
					case "PS":
						return SecurityType.PreferredStock;
					case "RP":
						return SecurityType.RepurchaseAgreement;
					case "RVRP":
						return SecurityType.ReverseRepurchaseAgreement;
					case "SL":
						return SecurityType.StudentLoanMarketingAssociation;
					case "TD":
						return SecurityType.TimeDeposit;
					case "USTB":
						return SecurityType.USTreasuryBillOld;
					case "WAR":
						return SecurityType.Warrant;
					case "ZOO":
						return SecurityType.CatsTigersAndLions;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SecurityType).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, SecurityType value)
			{
				switch (value)
				{
					case SecurityType.Wildcard:
						fieldSet.Set(tag, "?");
						break;
					case SecurityType.BankersAcceptance:
						fieldSet.Set(tag, "BA");
						break;
					case SecurityType.ConvertibleBond:
						fieldSet.Set(tag, "CB");
						break;
					case SecurityType.CertificateOfDeposit:
						fieldSet.Set(tag, "CD");
						break;
					case SecurityType.CollateralizedMortgageObligation:
						fieldSet.Set(tag, "CMO");
						break;
					case SecurityType.CorporateBond:
						fieldSet.Set(tag, "CORP");
						break;
					case SecurityType.CommercialPaper:
						fieldSet.Set(tag, "CP");
						break;
					case SecurityType.CorporatePrivatePlacement:
						fieldSet.Set(tag, "CPP");
						break;
					case SecurityType.CommonStock:
						fieldSet.Set(tag, "CS");
						break;
					case SecurityType.FederalHousingAuthority:
						fieldSet.Set(tag, "FHA");
						break;
					case SecurityType.FederalHomeLoan:
						fieldSet.Set(tag, "FHL");
						break;
					case SecurityType.FederalNationalMortgageAssociation:
						fieldSet.Set(tag, "FN");
						break;
					case SecurityType.ForeignExchangeContract:
						fieldSet.Set(tag, "FOR");
						break;
					case SecurityType.Future:
						fieldSet.Set(tag, "FUT");
						break;
					case SecurityType.GovernmentNationalMortgageAssociation:
						fieldSet.Set(tag, "GN");
						break;
					case SecurityType.TreasuriesAgencyDebenture:
						fieldSet.Set(tag, "GOVT");
						break;
					case SecurityType.IOETTEMortgage:
						fieldSet.Set(tag, "IET");
						break;
					case SecurityType.MutualFund:
						fieldSet.Set(tag, "MF");
						break;
					case SecurityType.MortgageInterestOnly:
						fieldSet.Set(tag, "MIO");
						break;
					case SecurityType.MortgagePrincipalOnly:
						fieldSet.Set(tag, "MPO");
						break;
					case SecurityType.MortgagePrivatePlacement:
						fieldSet.Set(tag, "MPP");
						break;
					case SecurityType.MiscellaneousPassThrough:
						fieldSet.Set(tag, "MPT");
						break;
					case SecurityType.MunicipalBond:
						fieldSet.Set(tag, "MUNI");
						break;
					case SecurityType.NoSecurityType:
						fieldSet.Set(tag, "NONE");
						break;
					case SecurityType.Option:
						fieldSet.Set(tag, "OPT");
						break;
					case SecurityType.PreferredStock:
						fieldSet.Set(tag, "PS");
						break;
					case SecurityType.RepurchaseAgreement:
						fieldSet.Set(tag, "RP");
						break;
					case SecurityType.ReverseRepurchaseAgreement:
						fieldSet.Set(tag, "RVRP");
						break;
					case SecurityType.StudentLoanMarketingAssociation:
						fieldSet.Set(tag, "SL");
						break;
					case SecurityType.TimeDeposit:
						fieldSet.Set(tag, "TD");
						break;
					case SecurityType.USTreasuryBillOld:
						fieldSet.Set(tag, "USTB");
						break;
					case SecurityType.Warrant:
						fieldSet.Set(tag, "WAR");
						break;
					case SecurityType.CatsTigersAndLions:
						fieldSet.Set(tag, "ZOO");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetPutOrCall(this FieldSet fieldSet, int tag, out PutOrCall value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (PutOrCall)v; return true; }
				value = default(PutOrCall);
				return false;
			}

			static public PutOrCall GetPutOrCall(this FieldSet fieldSet, int tag)
			{
				return (PutOrCall)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, PutOrCall value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSide(this FieldSet fieldSet, int tag, out Side value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (Side)v; return true; }
				value = default(Side);
				return false;
			}

			static public Side GetSide(this FieldSet fieldSet, int tag)
			{
				return (Side)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, Side value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIOIShares(this FieldSet fieldSet, int tag, out IOIShares value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IOIShares)v; return true; }
				value = default(IOIShares);
				return false;
			}

			static public IOIShares GetIOIShares(this FieldSet fieldSet, int tag)
			{
				return (IOIShares)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IOIShares value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIOIQltyInd(this FieldSet fieldSet, int tag, out IOIQltyInd value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IOIQltyInd)v; return true; }
				value = default(IOIQltyInd);
				return false;
			}

			static public IOIQltyInd GetIOIQltyInd(this FieldSet fieldSet, int tag)
			{
				return (IOIQltyInd)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IOIQltyInd value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIOINaturalFlag(this FieldSet fieldSet, int tag, out IOINaturalFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IOINaturalFlag)v; return true; }
				value = default(IOINaturalFlag);
				return false;
			}

			static public IOINaturalFlag GetIOINaturalFlag(this FieldSet fieldSet, int tag)
			{
				return (IOINaturalFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IOINaturalFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIOIQualifier(this FieldSet fieldSet, int tag, out IOIQualifier value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IOIQualifier)v; return true; }
				value = default(IOIQualifier);
				return false;
			}

			static public IOIQualifier GetIOIQualifier(this FieldSet fieldSet, int tag)
			{
				return (IOIQualifier)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IOIQualifier value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetRoutingType(this FieldSet fieldSet, int tag, out RoutingType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (RoutingType)v; return true; }
				value = default(RoutingType);
				return false;
			}

			static public RoutingType GetRoutingType(this FieldSet fieldSet, int tag)
			{
				return (RoutingType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, RoutingType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetBenchmark(this FieldSet fieldSet, int tag, out Benchmark value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (Benchmark)v; return true; }
				value = default(Benchmark);
				return false;
			}

			static public Benchmark GetBenchmark(this FieldSet fieldSet, int tag)
			{
				return (Benchmark)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, Benchmark value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAdvTransType(this FieldSet fieldSet, int tag, out AdvTransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AdvTransType)v; return true; }
				value = default(AdvTransType);
				return false;
			}

			static public AdvTransType GetAdvTransType(this FieldSet fieldSet, int tag)
			{
				return (AdvTransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AdvTransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAdvSide(this FieldSet fieldSet, int tag, out AdvSide value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AdvSide)v; return true; }
				value = default(AdvSide);
				return false;
			}

			static public AdvSide GetAdvSide(this FieldSet fieldSet, int tag)
			{
				return (AdvSide)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AdvSide value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetUrgency(this FieldSet fieldSet, int tag, out Urgency value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (Urgency)v; return true; }
				value = default(Urgency);
				return false;
			}

			static public Urgency GetUrgency(this FieldSet fieldSet, int tag)
			{
				return (Urgency)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, Urgency value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetEmailType(this FieldSet fieldSet, int tag, out EmailType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (EmailType)v; return true; }
				value = default(EmailType);
				return false;
			}

			static public EmailType GetEmailType(this FieldSet fieldSet, int tag)
			{
				return (EmailType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, EmailType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteRequestType(this FieldSet fieldSet, int tag, out QuoteRequestType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteRequestType)v; return true; }
				value = default(QuoteRequestType);
				return false;
			}

			static public QuoteRequestType GetQuoteRequestType(this FieldSet fieldSet, int tag)
			{
				return (QuoteRequestType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteRequestType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetOrdType(this FieldSet fieldSet, int tag, out OrdType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (OrdType)v; return true; }
				value = default(OrdType);
				return false;
			}

			static public OrdType GetOrdType(this FieldSet fieldSet, int tag)
			{
				return (OrdType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, OrdType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteResponseLevel(this FieldSet fieldSet, int tag, out QuoteResponseLevel value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteResponseLevel)v; return true; }
				value = default(QuoteResponseLevel);
				return false;
			}

			static public QuoteResponseLevel GetQuoteResponseLevel(this FieldSet fieldSet, int tag)
			{
				return (QuoteResponseLevel)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteResponseLevel value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteCancelType(this FieldSet fieldSet, int tag, out QuoteCancelType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteCancelType)v; return true; }
				value = default(QuoteCancelType);
				return false;
			}

			static public QuoteCancelType GetQuoteCancelType(this FieldSet fieldSet, int tag)
			{
				return (QuoteCancelType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteCancelType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteAckStatus(this FieldSet fieldSet, int tag, out QuoteAckStatus value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteAckStatus)v; return true; }
				value = default(QuoteAckStatus);
				return false;
			}

			static public QuoteAckStatus GetQuoteAckStatus(this FieldSet fieldSet, int tag)
			{
				return (QuoteAckStatus)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteAckStatus value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteRejectReason(this FieldSet fieldSet, int tag, out QuoteRejectReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteRejectReason)v; return true; }
				value = default(QuoteRejectReason);
				return false;
			}

			static public QuoteRejectReason GetQuoteRejectReason(this FieldSet fieldSet, int tag)
			{
				return (QuoteRejectReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteRejectReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteEntryRejectReason(this FieldSet fieldSet, int tag, out QuoteEntryRejectReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteEntryRejectReason)v; return true; }
				value = default(QuoteEntryRejectReason);
				return false;
			}

			static public QuoteEntryRejectReason GetQuoteEntryRejectReason(this FieldSet fieldSet, int tag)
			{
				return (QuoteEntryRejectReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteEntryRejectReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSubscriptionRequestType(this FieldSet fieldSet, int tag, out SubscriptionRequestType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SubscriptionRequestType)v; return true; }
				value = default(SubscriptionRequestType);
				return false;
			}

			static public SubscriptionRequestType GetSubscriptionRequestType(this FieldSet fieldSet, int tag)
			{
				return (SubscriptionRequestType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SubscriptionRequestType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMDUpdateType(this FieldSet fieldSet, int tag, out MDUpdateType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MDUpdateType)v; return true; }
				value = default(MDUpdateType);
				return false;
			}

			static public MDUpdateType GetMDUpdateType(this FieldSet fieldSet, int tag)
			{
				return (MDUpdateType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MDUpdateType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAggregatedBook(this FieldSet fieldSet, int tag, out AggregatedBook value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "(Not specified)":
							value = AggregatedBook.NotSpecified;
							break;
						case "N":
							value = AggregatedBook.BookEntriesShouldNotBeAggregated;
							break;
						case "Y":
							value = AggregatedBook.BookEntriesToBeAggregated;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(AggregatedBook).Name, v));
					}
					return true;
				}
				value = default(AggregatedBook);
				return false;
			}

			static public AggregatedBook GetAggregatedBook(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "(Not specified)":
						return AggregatedBook.NotSpecified;
					case "N":
						return AggregatedBook.BookEntriesShouldNotBeAggregated;
					case "Y":
						return AggregatedBook.BookEntriesToBeAggregated;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(AggregatedBook).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, AggregatedBook value)
			{
				switch (value)
				{
					case AggregatedBook.NotSpecified:
						fieldSet.Set(tag, "(Not specified)");
						break;
					case AggregatedBook.BookEntriesShouldNotBeAggregated:
						fieldSet.Set(tag, "N");
						break;
					case AggregatedBook.BookEntriesToBeAggregated:
						fieldSet.Set(tag, "Y");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetMDEntryType(this FieldSet fieldSet, int tag, out MDEntryType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MDEntryType)v; return true; }
				value = default(MDEntryType);
				return false;
			}

			static public MDEntryType GetMDEntryType(this FieldSet fieldSet, int tag)
			{
				return (MDEntryType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MDEntryType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetFinancialStatus(this FieldSet fieldSet, int tag, out FinancialStatus value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (FinancialStatus)v; return true; }
				value = default(FinancialStatus);
				return false;
			}

			static public FinancialStatus GetFinancialStatus(this FieldSet fieldSet, int tag)
			{
				return (FinancialStatus)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, FinancialStatus value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCorporateAction(this FieldSet fieldSet, int tag, out CorporateAction value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CorporateAction)v; return true; }
				value = default(CorporateAction);
				return false;
			}

			static public CorporateAction GetCorporateAction(this FieldSet fieldSet, int tag)
			{
				return (CorporateAction)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CorporateAction value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTickDirection(this FieldSet fieldSet, int tag, out TickDirection value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TickDirection)v; return true; }
				value = default(TickDirection);
				return false;
			}

			static public TickDirection GetTickDirection(this FieldSet fieldSet, int tag)
			{
				return (TickDirection)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TickDirection value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetQuoteCondition(this FieldSet fieldSet, int tag, out QuoteCondition value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (QuoteCondition)v; return true; }
				value = default(QuoteCondition);
				return false;
			}

			static public QuoteCondition GetQuoteCondition(this FieldSet fieldSet, int tag)
			{
				return (QuoteCondition)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, QuoteCondition value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTradeCondition(this FieldSet fieldSet, int tag, out TradeCondition value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TradeCondition)v; return true; }
				value = default(TradeCondition);
				return false;
			}

			static public TradeCondition GetTradeCondition(this FieldSet fieldSet, int tag)
			{
				return (TradeCondition)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TradeCondition value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetOpenCloseSettleFlag(this FieldSet fieldSet, int tag, out OpenCloseSettleFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (OpenCloseSettleFlag)v; return true; }
				value = default(OpenCloseSettleFlag);
				return false;
			}

			static public OpenCloseSettleFlag GetOpenCloseSettleFlag(this FieldSet fieldSet, int tag)
			{
				return (OpenCloseSettleFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, OpenCloseSettleFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTimeInForce(this FieldSet fieldSet, int tag, out TimeInForce value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TimeInForce)v; return true; }
				value = default(TimeInForce);
				return false;
			}

			static public TimeInForce GetTimeInForce(this FieldSet fieldSet, int tag)
			{
				return (TimeInForce)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TimeInForce value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetExecInst(this FieldSet fieldSet, int tag, out ExecInst value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ExecInst)v; return true; }
				value = default(ExecInst);
				return false;
			}

			static public ExecInst GetExecInst(this FieldSet fieldSet, int tag)
			{
				return (ExecInst)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ExecInst value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMDUpdateAction(this FieldSet fieldSet, int tag, out MDUpdateAction value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MDUpdateAction)v; return true; }
				value = default(MDUpdateAction);
				return false;
			}

			static public MDUpdateAction GetMDUpdateAction(this FieldSet fieldSet, int tag)
			{
				return (MDUpdateAction)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MDUpdateAction value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetDeleteReason(this FieldSet fieldSet, int tag, out DeleteReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (DeleteReason)v; return true; }
				value = default(DeleteReason);
				return false;
			}

			static public DeleteReason GetDeleteReason(this FieldSet fieldSet, int tag)
			{
				return (DeleteReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, DeleteReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMDReqRejReason(this FieldSet fieldSet, int tag, out MDReqRejReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MDReqRejReason)v; return true; }
				value = default(MDReqRejReason);
				return false;
			}

			static public MDReqRejReason GetMDReqRejReason(this FieldSet fieldSet, int tag)
			{
				return (MDReqRejReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MDReqRejReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSecurityRequestType(this FieldSet fieldSet, int tag, out SecurityRequestType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SecurityRequestType)v; return true; }
				value = default(SecurityRequestType);
				return false;
			}

			static public SecurityRequestType GetSecurityRequestType(this FieldSet fieldSet, int tag)
			{
				return (SecurityRequestType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SecurityRequestType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSecurityResponseType(this FieldSet fieldSet, int tag, out SecurityResponseType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SecurityResponseType)v; return true; }
				value = default(SecurityResponseType);
				return false;
			}

			static public SecurityResponseType GetSecurityResponseType(this FieldSet fieldSet, int tag)
			{
				return (SecurityResponseType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SecurityResponseType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetUnsolicitedIndicator(this FieldSet fieldSet, int tag, out UnsolicitedIndicator value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (UnsolicitedIndicator)v; return true; }
				value = default(UnsolicitedIndicator);
				return false;
			}

			static public UnsolicitedIndicator GetUnsolicitedIndicator(this FieldSet fieldSet, int tag)
			{
				return (UnsolicitedIndicator)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, UnsolicitedIndicator value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSecurityTradingStatus(this FieldSet fieldSet, int tag, out SecurityTradingStatus value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "1":
							value = SecurityTradingStatus.OpeningDelay;
							break;
						case "2":
							value = SecurityTradingStatus.TradingHalt;
							break;
						case "3":
							value = SecurityTradingStatus.Resume;
							break;
						case "4":
							value = SecurityTradingStatus.NoOpen;
							break;
						case "5":
							value = SecurityTradingStatus.PriceIndication;
							break;
						case "6":
							value = SecurityTradingStatus.TradingRangeIndication;
							break;
						case "7":
							value = SecurityTradingStatus.MarketImbalanceBuy;
							break;
						case "8":
							value = SecurityTradingStatus.MarketImbalanceSell;
							break;
						case "9":
							value = SecurityTradingStatus.MarketOnCloseImbalanceBuy;
							break;
						case "10":
							value = SecurityTradingStatus.MarketOnCloseImbalanceSell;
							break;
						case "12":
							value = SecurityTradingStatus.NoMarketImbalance;
							break;
						case "13":
							value = SecurityTradingStatus.NoMarketOnCloseImbalance;
							break;
						case "14":
							value = SecurityTradingStatus.ITSPreOpening;
							break;
						case "15":
							value = SecurityTradingStatus.NewPriceIndication;
							break;
						case "16":
							value = SecurityTradingStatus.TradeDisseminationTime;
							break;
						case "17":
							value = SecurityTradingStatus.ReadyToTrade;
							break;
						case "18":
							value = SecurityTradingStatus.NotAvailableForTrading;
							break;
						case "19":
							value = SecurityTradingStatus.NotTradedOnThisMarket;
							break;
						case "20":
							value = SecurityTradingStatus.UnknownOrInvalid;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SecurityTradingStatus).Name, v));
					}
					return true;
				}
				value = default(SecurityTradingStatus);
				return false;
			}

			static public SecurityTradingStatus GetSecurityTradingStatus(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "1":
						return SecurityTradingStatus.OpeningDelay;
					case "2":
						return SecurityTradingStatus.TradingHalt;
					case "3":
						return SecurityTradingStatus.Resume;
					case "4":
						return SecurityTradingStatus.NoOpen;
					case "5":
						return SecurityTradingStatus.PriceIndication;
					case "6":
						return SecurityTradingStatus.TradingRangeIndication;
					case "7":
						return SecurityTradingStatus.MarketImbalanceBuy;
					case "8":
						return SecurityTradingStatus.MarketImbalanceSell;
					case "9":
						return SecurityTradingStatus.MarketOnCloseImbalanceBuy;
					case "10":
						return SecurityTradingStatus.MarketOnCloseImbalanceSell;
					case "12":
						return SecurityTradingStatus.NoMarketImbalance;
					case "13":
						return SecurityTradingStatus.NoMarketOnCloseImbalance;
					case "14":
						return SecurityTradingStatus.ITSPreOpening;
					case "15":
						return SecurityTradingStatus.NewPriceIndication;
					case "16":
						return SecurityTradingStatus.TradeDisseminationTime;
					case "17":
						return SecurityTradingStatus.ReadyToTrade;
					case "18":
						return SecurityTradingStatus.NotAvailableForTrading;
					case "19":
						return SecurityTradingStatus.NotTradedOnThisMarket;
					case "20":
						return SecurityTradingStatus.UnknownOrInvalid;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SecurityTradingStatus).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, SecurityTradingStatus value)
			{
				switch (value)
				{
					case SecurityTradingStatus.OpeningDelay:
						fieldSet.Set(tag, "1");
						break;
					case SecurityTradingStatus.TradingHalt:
						fieldSet.Set(tag, "2");
						break;
					case SecurityTradingStatus.Resume:
						fieldSet.Set(tag, "3");
						break;
					case SecurityTradingStatus.NoOpen:
						fieldSet.Set(tag, "4");
						break;
					case SecurityTradingStatus.PriceIndication:
						fieldSet.Set(tag, "5");
						break;
					case SecurityTradingStatus.TradingRangeIndication:
						fieldSet.Set(tag, "6");
						break;
					case SecurityTradingStatus.MarketImbalanceBuy:
						fieldSet.Set(tag, "7");
						break;
					case SecurityTradingStatus.MarketImbalanceSell:
						fieldSet.Set(tag, "8");
						break;
					case SecurityTradingStatus.MarketOnCloseImbalanceBuy:
						fieldSet.Set(tag, "9");
						break;
					case SecurityTradingStatus.MarketOnCloseImbalanceSell:
						fieldSet.Set(tag, "10");
						break;
					case SecurityTradingStatus.NoMarketImbalance:
						fieldSet.Set(tag, "12");
						break;
					case SecurityTradingStatus.NoMarketOnCloseImbalance:
						fieldSet.Set(tag, "13");
						break;
					case SecurityTradingStatus.ITSPreOpening:
						fieldSet.Set(tag, "14");
						break;
					case SecurityTradingStatus.NewPriceIndication:
						fieldSet.Set(tag, "15");
						break;
					case SecurityTradingStatus.TradeDisseminationTime:
						fieldSet.Set(tag, "16");
						break;
					case SecurityTradingStatus.ReadyToTrade:
						fieldSet.Set(tag, "17");
						break;
					case SecurityTradingStatus.NotAvailableForTrading:
						fieldSet.Set(tag, "18");
						break;
					case SecurityTradingStatus.NotTradedOnThisMarket:
						fieldSet.Set(tag, "19");
						break;
					case SecurityTradingStatus.UnknownOrInvalid:
						fieldSet.Set(tag, "20");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetHaltReason(this FieldSet fieldSet, int tag, out HaltReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (HaltReason)v; return true; }
				value = default(HaltReason);
				return false;
			}

			static public HaltReason GetHaltReason(this FieldSet fieldSet, int tag)
			{
				return (HaltReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, HaltReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetInViewOfCommon(this FieldSet fieldSet, int tag, out InViewOfCommon value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (InViewOfCommon)v; return true; }
				value = default(InViewOfCommon);
				return false;
			}

			static public InViewOfCommon GetInViewOfCommon(this FieldSet fieldSet, int tag)
			{
				return (InViewOfCommon)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, InViewOfCommon value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetDueToRelated(this FieldSet fieldSet, int tag, out DueToRelated value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (DueToRelated)v; return true; }
				value = default(DueToRelated);
				return false;
			}

			static public DueToRelated GetDueToRelated(this FieldSet fieldSet, int tag)
			{
				return (DueToRelated)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, DueToRelated value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAdjustment(this FieldSet fieldSet, int tag, out Adjustment value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (Adjustment)v; return true; }
				value = default(Adjustment);
				return false;
			}

			static public Adjustment GetAdjustment(this FieldSet fieldSet, int tag)
			{
				return (Adjustment)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, Adjustment value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTradSesMethod(this FieldSet fieldSet, int tag, out TradSesMethod value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TradSesMethod)v; return true; }
				value = default(TradSesMethod);
				return false;
			}

			static public TradSesMethod GetTradSesMethod(this FieldSet fieldSet, int tag)
			{
				return (TradSesMethod)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TradSesMethod value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTradSesMode(this FieldSet fieldSet, int tag, out TradSesMode value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TradSesMode)v; return true; }
				value = default(TradSesMode);
				return false;
			}

			static public TradSesMode GetTradSesMode(this FieldSet fieldSet, int tag)
			{
				return (TradSesMode)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TradSesMode value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTradSesStatus(this FieldSet fieldSet, int tag, out TradSesStatus value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TradSesStatus)v; return true; }
				value = default(TradSesStatus);
				return false;
			}

			static public TradSesStatus GetTradSesStatus(this FieldSet fieldSet, int tag)
			{
				return (TradSesStatus)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TradSesStatus value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetBidRequestTransType(this FieldSet fieldSet, int tag, out BidRequestTransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (BidRequestTransType)v; return true; }
				value = default(BidRequestTransType);
				return false;
			}

			static public BidRequestTransType GetBidRequestTransType(this FieldSet fieldSet, int tag)
			{
				return (BidRequestTransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, BidRequestTransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetNetGrossInd(this FieldSet fieldSet, int tag, out NetGrossInd value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (NetGrossInd)v; return true; }
				value = default(NetGrossInd);
				return false;
			}

			static public NetGrossInd GetNetGrossInd(this FieldSet fieldSet, int tag)
			{
				return (NetGrossInd)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, NetGrossInd value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSettlmntTyp(this FieldSet fieldSet, int tag, out SettlmntTyp value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SettlmntTyp)v; return true; }
				value = default(SettlmntTyp);
				return false;
			}

			static public SettlmntTyp GetSettlmntTyp(this FieldSet fieldSet, int tag)
			{
				return (SettlmntTyp)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SettlmntTyp value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetLiquidityIndType(this FieldSet fieldSet, int tag, out LiquidityIndType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (LiquidityIndType)v; return true; }
				value = default(LiquidityIndType);
				return false;
			}

			static public LiquidityIndType GetLiquidityIndType(this FieldSet fieldSet, int tag)
			{
				return (LiquidityIndType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, LiquidityIndType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetExchangeForPhysical(this FieldSet fieldSet, int tag, out ExchangeForPhysical value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ExchangeForPhysical)v; return true; }
				value = default(ExchangeForPhysical);
				return false;
			}

			static public ExchangeForPhysical GetExchangeForPhysical(this FieldSet fieldSet, int tag)
			{
				return (ExchangeForPhysical)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ExchangeForPhysical value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetProgRptReqs(this FieldSet fieldSet, int tag, out ProgRptReqs value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ProgRptReqs)v; return true; }
				value = default(ProgRptReqs);
				return false;
			}

			static public ProgRptReqs GetProgRptReqs(this FieldSet fieldSet, int tag)
			{
				return (ProgRptReqs)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ProgRptReqs value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetIncTaxInd(this FieldSet fieldSet, int tag, out IncTaxInd value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (IncTaxInd)v; return true; }
				value = default(IncTaxInd);
				return false;
			}

			static public IncTaxInd GetIncTaxInd(this FieldSet fieldSet, int tag)
			{
				return (IncTaxInd)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, IncTaxInd value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetForexReq(this FieldSet fieldSet, int tag, out ForexReq value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ForexReq)v; return true; }
				value = default(ForexReq);
				return false;
			}

			static public ForexReq GetForexReq(this FieldSet fieldSet, int tag)
			{
				return (ForexReq)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ForexReq value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetTradeType(this FieldSet fieldSet, int tag, out TradeType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (TradeType)v; return true; }
				value = default(TradeType);
				return false;
			}

			static public TradeType GetTradeType(this FieldSet fieldSet, int tag)
			{
				return (TradeType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, TradeType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetBasisPxType(this FieldSet fieldSet, int tag, out BasisPxType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (BasisPxType)v; return true; }
				value = default(BasisPxType);
				return false;
			}

			static public BasisPxType GetBasisPxType(this FieldSet fieldSet, int tag)
			{
				return (BasisPxType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, BasisPxType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCommType(this FieldSet fieldSet, int tag, out CommType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CommType)v; return true; }
				value = default(CommType);
				return false;
			}

			static public CommType GetCommType(this FieldSet fieldSet, int tag)
			{
				return (CommType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CommType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetPriceType(this FieldSet fieldSet, int tag, out PriceType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (PriceType)v; return true; }
				value = default(PriceType);
				return false;
			}

			static public PriceType GetPriceType(this FieldSet fieldSet, int tag)
			{
				return (PriceType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, PriceType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetExecTransType(this FieldSet fieldSet, int tag, out ExecTransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ExecTransType)v; return true; }
				value = default(ExecTransType);
				return false;
			}

			static public ExecTransType GetExecTransType(this FieldSet fieldSet, int tag)
			{
				return (ExecTransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ExecTransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetExecType(this FieldSet fieldSet, int tag, out ExecType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ExecType)v; return true; }
				value = default(ExecType);
				return false;
			}

			static public ExecType GetExecType(this FieldSet fieldSet, int tag)
			{
				return (ExecType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ExecType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetOrdStatus(this FieldSet fieldSet, int tag, out OrdStatus value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (OrdStatus)v; return true; }
				value = default(OrdStatus);
				return false;
			}

			static public OrdStatus GetOrdStatus(this FieldSet fieldSet, int tag)
			{
				return (OrdStatus)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, OrdStatus value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetOrdRejReason(this FieldSet fieldSet, int tag, out OrdRejReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (OrdRejReason)v; return true; }
				value = default(OrdRejReason);
				return false;
			}

			static public OrdRejReason GetOrdRejReason(this FieldSet fieldSet, int tag)
			{
				return (OrdRejReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, OrdRejReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetExecRestatementReason(this FieldSet fieldSet, int tag, out ExecRestatementReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ExecRestatementReason)v; return true; }
				value = default(ExecRestatementReason);
				return false;
			}

			static public ExecRestatementReason GetExecRestatementReason(this FieldSet fieldSet, int tag)
			{
				return (ExecRestatementReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ExecRestatementReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetDiscretionInst(this FieldSet fieldSet, int tag, out DiscretionInst value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (DiscretionInst)v; return true; }
				value = default(DiscretionInst);
				return false;
			}

			static public DiscretionInst GetDiscretionInst(this FieldSet fieldSet, int tag)
			{
				return (DiscretionInst)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, DiscretionInst value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSolicitedFlag(this FieldSet fieldSet, int tag, out SolicitedFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SolicitedFlag)v; return true; }
				value = default(SolicitedFlag);
				return false;
			}

			static public SolicitedFlag GetSolicitedFlag(this FieldSet fieldSet, int tag)
			{
				return (SolicitedFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SolicitedFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetRule80AAkaOrderCapacity(this FieldSet fieldSet, int tag, out Rule80AAkaOrderCapacity value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (Rule80AAkaOrderCapacity)v; return true; }
				value = default(Rule80AAkaOrderCapacity);
				return false;
			}

			static public Rule80AAkaOrderCapacity GetRule80AAkaOrderCapacity(this FieldSet fieldSet, int tag)
			{
				return (Rule80AAkaOrderCapacity)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, Rule80AAkaOrderCapacity value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetLastCapacity(this FieldSet fieldSet, int tag, out LastCapacity value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (LastCapacity)v; return true; }
				value = default(LastCapacity);
				return false;
			}

			static public LastCapacity GetLastCapacity(this FieldSet fieldSet, int tag)
			{
				return (LastCapacity)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, LastCapacity value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetGTBookingInst(this FieldSet fieldSet, int tag, out GTBookingInst value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (GTBookingInst)v; return true; }
				value = default(GTBookingInst);
				return false;
			}

			static public GTBookingInst GetGTBookingInst(this FieldSet fieldSet, int tag)
			{
				return (GTBookingInst)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, GTBookingInst value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetReportToExch(this FieldSet fieldSet, int tag, out ReportToExch value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ReportToExch)v; return true; }
				value = default(ReportToExch);
				return false;
			}

			static public ReportToExch GetReportToExch(this FieldSet fieldSet, int tag)
			{
				return (ReportToExch)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ReportToExch value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetHandlInst(this FieldSet fieldSet, int tag, out HandlInst value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (HandlInst)v; return true; }
				value = default(HandlInst);
				return false;
			}

			static public HandlInst GetHandlInst(this FieldSet fieldSet, int tag)
			{
				return (HandlInst)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, HandlInst value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetOpenClose(this FieldSet fieldSet, int tag, out OpenClose value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (OpenClose)v; return true; }
				value = default(OpenClose);
				return false;
			}

			static public OpenClose GetOpenClose(this FieldSet fieldSet, int tag)
			{
				return (OpenClose)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, OpenClose value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMultiLegReportingType(this FieldSet fieldSet, int tag, out MultiLegReportingType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MultiLegReportingType)v; return true; }
				value = default(MultiLegReportingType);
				return false;
			}

			static public MultiLegReportingType GetMultiLegReportingType(this FieldSet fieldSet, int tag)
			{
				return (MultiLegReportingType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MultiLegReportingType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCxlRejResponseTo(this FieldSet fieldSet, int tag, out CxlRejResponseTo value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CxlRejResponseTo)v; return true; }
				value = default(CxlRejResponseTo);
				return false;
			}

			static public CxlRejResponseTo GetCxlRejResponseTo(this FieldSet fieldSet, int tag)
			{
				return (CxlRejResponseTo)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CxlRejResponseTo value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCxlRejReason(this FieldSet fieldSet, int tag, out CxlRejReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CxlRejReason)v; return true; }
				value = default(CxlRejReason);
				return false;
			}

			static public CxlRejReason GetCxlRejReason(this FieldSet fieldSet, int tag)
			{
				return (CxlRejReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CxlRejReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetProcessCode(this FieldSet fieldSet, int tag, out ProcessCode value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ProcessCode)v; return true; }
				value = default(ProcessCode);
				return false;
			}

			static public ProcessCode GetProcessCode(this FieldSet fieldSet, int tag)
			{
				return (ProcessCode)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ProcessCode value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetLocateReqd(this FieldSet fieldSet, int tag, out LocateReqd value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (LocateReqd)v; return true; }
				value = default(LocateReqd);
				return false;
			}

			static public LocateReqd GetLocateReqd(this FieldSet fieldSet, int tag)
			{
				return (LocateReqd)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, LocateReqd value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCoveredOrUncovered(this FieldSet fieldSet, int tag, out CoveredOrUncovered value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CoveredOrUncovered)v; return true; }
				value = default(CoveredOrUncovered);
				return false;
			}

			static public CoveredOrUncovered GetCoveredOrUncovered(this FieldSet fieldSet, int tag)
			{
				return (CoveredOrUncovered)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CoveredOrUncovered value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetCustomerOrFirm(this FieldSet fieldSet, int tag, out CustomerOrFirm value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (CustomerOrFirm)v; return true; }
				value = default(CustomerOrFirm);
				return false;
			}

			static public CustomerOrFirm GetCustomerOrFirm(this FieldSet fieldSet, int tag)
			{
				return (CustomerOrFirm)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, CustomerOrFirm value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetDKReason(this FieldSet fieldSet, int tag, out DKReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (DKReason)v; return true; }
				value = default(DKReason);
				return false;
			}

			static public DKReason GetDKReason(this FieldSet fieldSet, int tag)
			{
				return (DKReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, DKReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetListExecInstType(this FieldSet fieldSet, int tag, out ListExecInstType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ListExecInstType)v; return true; }
				value = default(ListExecInstType);
				return false;
			}

			static public ListExecInstType GetListExecInstType(this FieldSet fieldSet, int tag)
			{
				return (ListExecInstType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ListExecInstType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSettlInstMode(this FieldSet fieldSet, int tag, out SettlInstMode value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SettlInstMode)v; return true; }
				value = default(SettlInstMode);
				return false;
			}

			static public SettlInstMode GetSettlInstMode(this FieldSet fieldSet, int tag)
			{
				return (SettlInstMode)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SettlInstMode value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAllocTransType(this FieldSet fieldSet, int tag, out AllocTransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AllocTransType)v; return true; }
				value = default(AllocTransType);
				return false;
			}

			static public AllocTransType GetAllocTransType(this FieldSet fieldSet, int tag)
			{
				return (AllocTransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AllocTransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAllocLinkType(this FieldSet fieldSet, int tag, out AllocLinkType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AllocLinkType)v; return true; }
				value = default(AllocLinkType);
				return false;
			}

			static public AllocLinkType GetAllocLinkType(this FieldSet fieldSet, int tag)
			{
				return (AllocLinkType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AllocLinkType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetNotifyBrokerOfCredit(this FieldSet fieldSet, int tag, out NotifyBrokerOfCredit value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (NotifyBrokerOfCredit)v; return true; }
				value = default(NotifyBrokerOfCredit);
				return false;
			}

			static public NotifyBrokerOfCredit GetNotifyBrokerOfCredit(this FieldSet fieldSet, int tag)
			{
				return (NotifyBrokerOfCredit)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, NotifyBrokerOfCredit value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAllocHandlInst(this FieldSet fieldSet, int tag, out AllocHandlInst value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AllocHandlInst)v; return true; }
				value = default(AllocHandlInst);
				return false;
			}

			static public AllocHandlInst GetAllocHandlInst(this FieldSet fieldSet, int tag)
			{
				return (AllocHandlInst)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AllocHandlInst value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMiscFeeType(this FieldSet fieldSet, int tag, out MiscFeeType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MiscFeeType)v; return true; }
				value = default(MiscFeeType);
				return false;
			}

			static public MiscFeeType GetMiscFeeType(this FieldSet fieldSet, int tag)
			{
				return (MiscFeeType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MiscFeeType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAllocStatus(this FieldSet fieldSet, int tag, out AllocStatus value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AllocStatus)v; return true; }
				value = default(AllocStatus);
				return false;
			}

			static public AllocStatus GetAllocStatus(this FieldSet fieldSet, int tag)
			{
				return (AllocStatus)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AllocStatus value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetAllocRejCode(this FieldSet fieldSet, int tag, out AllocRejCode value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (AllocRejCode)v; return true; }
				value = default(AllocRejCode);
				return false;
			}

			static public AllocRejCode GetAllocRejCode(this FieldSet fieldSet, int tag)
			{
				return (AllocRejCode)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, AllocRejCode value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSettlInstTransType(this FieldSet fieldSet, int tag, out SettlInstTransType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SettlInstTransType)v; return true; }
				value = default(SettlInstTransType);
				return false;
			}

			static public SettlInstTransType GetSettlInstTransType(this FieldSet fieldSet, int tag)
			{
				return (SettlInstTransType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SettlInstTransType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSettlInstSource(this FieldSet fieldSet, int tag, out SettlInstSource value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (SettlInstSource)v; return true; }
				value = default(SettlInstSource);
				return false;
			}

			static public SettlInstSource GetSettlInstSource(this FieldSet fieldSet, int tag)
			{
				return (SettlInstSource)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, SettlInstSource value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSettlLocation(this FieldSet fieldSet, int tag, out SettlLocation value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "CED":
							value = SettlLocation.CEDEL;
							break;
						case "DTC":
							value = SettlLocation.DepositoryTrustCompany;
							break;
						case "EUR":
							value = SettlLocation.EuroClear;
							break;
						case "FED":
							value = SettlLocation.FederalBookEntry;
							break;
						case "ISO Country Code":
							value = SettlLocation.LocalMarketSettleLocation;
							break;
						case "PNY":
							value = SettlLocation.Physical;
							break;
						case "PTC":
							value = SettlLocation.ParticipantTrustCompany;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SettlLocation).Name, v));
					}
					return true;
				}
				value = default(SettlLocation);
				return false;
			}

			static public SettlLocation GetSettlLocation(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "CED":
						return SettlLocation.CEDEL;
					case "DTC":
						return SettlLocation.DepositoryTrustCompany;
					case "EUR":
						return SettlLocation.EuroClear;
					case "FED":
						return SettlLocation.FederalBookEntry;
					case "ISO Country Code":
						return SettlLocation.LocalMarketSettleLocation;
					case "PNY":
						return SettlLocation.Physical;
					case "PTC":
						return SettlLocation.ParticipantTrustCompany;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SettlLocation).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, SettlLocation value)
			{
				switch (value)
				{
					case SettlLocation.CEDEL:
						fieldSet.Set(tag, "CED");
						break;
					case SettlLocation.DepositoryTrustCompany:
						fieldSet.Set(tag, "DTC");
						break;
					case SettlLocation.EuroClear:
						fieldSet.Set(tag, "EUR");
						break;
					case SettlLocation.FederalBookEntry:
						fieldSet.Set(tag, "FED");
						break;
					case SettlLocation.LocalMarketSettleLocation:
						fieldSet.Set(tag, "ISO Country Code");
						break;
					case SettlLocation.Physical:
						fieldSet.Set(tag, "PNY");
						break;
					case SettlLocation.ParticipantTrustCompany:
						fieldSet.Set(tag, "PTC");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetStandInstDbType(this FieldSet fieldSet, int tag, out StandInstDbType value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (StandInstDbType)v; return true; }
				value = default(StandInstDbType);
				return false;
			}

			static public StandInstDbType GetStandInstDbType(this FieldSet fieldSet, int tag)
			{
				return (StandInstDbType)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, StandInstDbType value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetBusinessRejectReason(this FieldSet fieldSet, int tag, out BusinessRejectReason value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (BusinessRejectReason)v; return true; }
				value = default(BusinessRejectReason);
				return false;
			}

			static public BusinessRejectReason GetBusinessRejectReason(this FieldSet fieldSet, int tag)
			{
				return (BusinessRejectReason)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, BusinessRejectReason value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetSessionRejectReason(this FieldSet fieldSet, int tag, out SessionRejectReason value)
			{
				string v;
				if (fieldSet.TryGetValue(tag, out v))
				{
					switch (v)
					{
						case "0":
							value = SessionRejectReason.InvalidTagNumber;
							break;
						case "1":
							value = SessionRejectReason.RequiredTagMissing;
							break;
						case "2":
							value = SessionRejectReason.TagNotDefinedForThisMessageType;
							break;
						case "3":
							value = SessionRejectReason.UndefinedTag;
							break;
						case "4":
							value = SessionRejectReason.TagSpecifiedWithoutAValue;
							break;
						case "5":
							value = SessionRejectReason.ValueIsIncorrect;
							break;
						case "6":
							value = SessionRejectReason.IncorrectDataFormatForValue;
							break;
						case "7":
							value = SessionRejectReason.DecryptionProblem;
							break;
						case "8":
							value = SessionRejectReason.SignatureProblem;
							break;
						case "9":
							value = SessionRejectReason.CompIDProblem;
							break;
						case "10":
							value = SessionRejectReason.SendingTimeAccuracyProblem;
							break;
						case "11":
							value = SessionRejectReason.InvalidMsgType;
							break;
						default:
							throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SessionRejectReason).Name, v));
					}
					return true;
				}
				value = default(SessionRejectReason);
				return false;
			}

			static public SessionRejectReason GetSessionRejectReason(this FieldSet fieldSet, int tag)
			{
				string v = fieldSet.Get(tag);
				switch (v)
				{
					case "0":
						return SessionRejectReason.InvalidTagNumber;
					case "1":
						return SessionRejectReason.RequiredTagMissing;
					case "2":
						return SessionRejectReason.TagNotDefinedForThisMessageType;
					case "3":
						return SessionRejectReason.UndefinedTag;
					case "4":
						return SessionRejectReason.TagSpecifiedWithoutAValue;
					case "5":
						return SessionRejectReason.ValueIsIncorrect;
					case "6":
						return SessionRejectReason.IncorrectDataFormatForValue;
					case "7":
						return SessionRejectReason.DecryptionProblem;
					case "8":
						return SessionRejectReason.SignatureProblem;
					case "9":
						return SessionRejectReason.CompIDProblem;
					case "10":
						return SessionRejectReason.SendingTimeAccuracyProblem;
					case "11":
						return SessionRejectReason.InvalidMsgType;
					default:
						throw new Exception(string.Format("Cannot parse enum {0} value '{1}'", typeof(SessionRejectReason).Name, v));
				}
			}

			static public void Set(this FieldSet fieldSet, int tag, SessionRejectReason value)
			{
				switch (value)
				{
					case SessionRejectReason.InvalidTagNumber:
						fieldSet.Set(tag, "0");
						break;
					case SessionRejectReason.RequiredTagMissing:
						fieldSet.Set(tag, "1");
						break;
					case SessionRejectReason.TagNotDefinedForThisMessageType:
						fieldSet.Set(tag, "2");
						break;
					case SessionRejectReason.UndefinedTag:
						fieldSet.Set(tag, "3");
						break;
					case SessionRejectReason.TagSpecifiedWithoutAValue:
						fieldSet.Set(tag, "4");
						break;
					case SessionRejectReason.ValueIsIncorrect:
						fieldSet.Set(tag, "5");
						break;
					case SessionRejectReason.IncorrectDataFormatForValue:
						fieldSet.Set(tag, "6");
						break;
					case SessionRejectReason.DecryptionProblem:
						fieldSet.Set(tag, "7");
						break;
					case SessionRejectReason.SignatureProblem:
						fieldSet.Set(tag, "8");
						break;
					case SessionRejectReason.CompIDProblem:
						fieldSet.Set(tag, "9");
						break;
					case SessionRejectReason.SendingTimeAccuracyProblem:
						fieldSet.Set(tag, "10");
						break;
					case SessionRejectReason.InvalidMsgType:
						fieldSet.Set(tag, "11");
						break;
					default:
						fieldSet.Remove(tag);
						break;
				}
			}

			static public bool TryGetGapFillFlag(this FieldSet fieldSet, int tag, out GapFillFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (GapFillFlag)v; return true; }
				value = default(GapFillFlag);
				return false;
			}

			static public GapFillFlag GetGapFillFlag(this FieldSet fieldSet, int tag)
			{
				return (GapFillFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, GapFillFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetEncryptMethod(this FieldSet fieldSet, int tag, out EncryptMethod value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (EncryptMethod)v; return true; }
				value = default(EncryptMethod);
				return false;
			}

			static public EncryptMethod GetEncryptMethod(this FieldSet fieldSet, int tag)
			{
				return (EncryptMethod)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, EncryptMethod value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetResetSeqNumFlag(this FieldSet fieldSet, int tag, out ResetSeqNumFlag value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (ResetSeqNumFlag)v; return true; }
				value = default(ResetSeqNumFlag);
				return false;
			}

			static public ResetSeqNumFlag GetResetSeqNumFlag(this FieldSet fieldSet, int tag)
			{
				return (ResetSeqNumFlag)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, ResetSeqNumFlag value)
			{
				fieldSet.Set(tag, (char)value);
			}

			static public bool TryGetMsgDirection(this FieldSet fieldSet, int tag, out MsgDirection value)
			{
				char v;
				if (fieldSet.TryGetValue(tag, out v)) { value = (MsgDirection)v; return true; }
				value = default(MsgDirection);
				return false;
			}

			static public MsgDirection GetMsgDirection(this FieldSet fieldSet, int tag)
			{
				return (MsgDirection)fieldSet.GetChar(tag);
			}

			static public void Set(this FieldSet fieldSet, int tag, MsgDirection value)
			{
				fieldSet.Set(tag, (char)value);
			}

		}

		/// <summary>
		/// <para>Defines message type. ALWAYS THIRD FIELD IN MESSAGE. (Always unencrypted)</para>
		/// <para>Note: A "U" as the first character in the MsgType field (i.e. U1, U2, etc) indicates that the message format is privately defined between the sender and receiver.</para>
		/// <para>Valid values: *** Note the use of lower case letters ***</para>
		/// <para>0 = Heartbeat</para>
		/// <para>1 = Test Request</para>
		/// <para>2 = Resend Request</para>
		/// <para>3 = Reject</para>
		/// <para>4 = Sequence Reset</para>
		/// <para>5 = Logout</para>
		/// <para>6 = Indication of Interest</para>
		/// <para>7 = Advertisement</para>
		/// <para>8 = Execution Report</para>
		/// <para>9 = Order Cancel Reject</para>
		/// <para>A = Logon</para>
		/// <para>B = News</para>
		/// <para>C = Email</para>
		/// <para>D = Order - Single</para>
		/// <para>E = Order - List</para>
		/// <para>F = Order Cancel Request</para>
		/// <para>G= Order Cancel/Replace Request</para>
		/// <para>H= Order Status Request</para>
		/// <para>J = Allocation</para>
		/// <para>K = List Cancel Request</para>
		/// <para>L = List Execute</para>
		/// <para>M = List Status Request</para>
		/// <para>N = List Status</para>
		/// <para>P = Allocation ACK</para>
		/// <para>Q = Don't Know Trade (DK)</para>
		/// <para>R = Quote Request</para>
		/// <para>S = Quote</para>
		/// <para>T = Settlement Instructions</para>
		/// <para>V = Market Data Request</para>
		/// <para>W = Market Data-Snapshot/Full Refresh</para>
		/// <para>X = Market Data-Incremental Refresh</para>
		/// <para>Y = Market Data Request Reject</para>
		/// <para>Z = Quote Cancel</para>
		/// <para>a = Quote Status Request</para>
		/// <para>b = Quote Acknowledgement</para>
		/// <para>c = Security Definition Request</para>
		/// <para>d = Security Definition</para>
		/// <para>e = Security Status Request</para>
		/// <para>f = Security Status</para>
		/// <para>g = Trading Session Status Request</para>
		/// <para>h = Trading Session Status</para>
		/// <para>i = Mass Quote</para>
		/// <para>j = Business Message Reject</para>
		/// <para>k = Bid Request</para>
		/// <para>l = Bid Response (lowercase L)</para>
		/// <para>m = List Strike Price</para>
		/// </summary>
		public enum MsgType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Heartbeat</para>
			/// </summary>
			Heartbeat = (int)'0',
			/// <summary>
			/// <para>Test Request</para>
			/// </summary>
			TestRequest = (int)'1',
			/// <summary>
			/// <para>Resend Request</para>
			/// </summary>
			ResendRequest = (int)'2',
			/// <summary>
			/// <para>Reject</para>
			/// </summary>
			Reject = (int)'3',
			/// <summary>
			/// <para>Sequence Reset</para>
			/// </summary>
			SequenceReset = (int)'4',
			/// <summary>
			/// <para>Logout</para>
			/// </summary>
			Logout = (int)'5',
			/// <summary>
			/// <para>Indication of Interest</para>
			/// </summary>
			IOI = (int)'6',
			/// <summary>
			/// <para>Advertisement</para>
			/// </summary>
			Advertisement = (int)'7',
			/// <summary>
			/// <para>Execution Report</para>
			/// </summary>
			ExecutionReport = (int)'8',
			/// <summary>
			/// <para>Order Cancel Reject</para>
			/// </summary>
			OrderCancelReject = (int)'9',
			/// <summary>
			/// <para>Quote Status Request</para>
			/// </summary>
			QuoteStatusRequest = (int)'a',
			/// <summary>
			/// <para>Logon</para>
			/// </summary>
			Logon = (int)'A',
			/// <summary>
			/// <para>Quote Acknowledgement</para>
			/// </summary>
			MassQuoteAcknowledgement = (int)'b',
			/// <summary>
			/// <para>News</para>
			/// </summary>
			News = (int)'B',
			/// <summary>
			/// <para>Security Definition Request</para>
			/// </summary>
			SecurityDefinitionRequest = (int)'c',
			/// <summary>
			/// <para>Email</para>
			/// </summary>
			Email = (int)'C',
			/// <summary>
			/// <para>Security Definition</para>
			/// </summary>
			SecurityDefinition = (int)'d',
			/// <summary>
			/// <para>Order  Single</para>
			/// </summary>
			NewOrderSingle = (int)'D',
			/// <summary>
			/// <para>Security Status Request</para>
			/// </summary>
			SecurityStatusRequest = (int)'e',
			/// <summary>
			/// <para>Order  List</para>
			/// </summary>
			NewOrderList = (int)'E',
			/// <summary>
			/// <para>Security Status</para>
			/// </summary>
			SecurityStatus = (int)'f',
			/// <summary>
			/// <para>Order Cancel Request</para>
			/// </summary>
			OrderCancelRequest = (int)'F',
			/// <summary>
			/// <para>Trading Session Status Request</para>
			/// </summary>
			TradingSessionStatusRequest = (int)'g',
			/// <summary>
			/// <para>Order Cancel/Replace Request</para>
			/// </summary>
			OrderCancelReplaceRequest = (int)'G',
			/// <summary>
			/// <para>Trading Session Status</para>
			/// </summary>
			TradingSessionStatus = (int)'h',
			/// <summary>
			/// <para>Order Status Request</para>
			/// </summary>
			OrderStatusRequest = (int)'H',
			/// <summary>
			/// <para>Mass Quote</para>
			/// </summary>
			MassQuote = (int)'i',
			/// <summary>
			/// <para>Business Message Reject</para>
			/// </summary>
			BusinessMessageReject = (int)'j',
			/// <summary>
			/// <para>Allocation</para>
			/// </summary>
			AllocationInstruction = (int)'J',
			/// <summary>
			/// <para>Bid Request</para>
			/// </summary>
			BidRequest = (int)'k',
			/// <summary>
			/// <para>List Cancel Request</para>
			/// </summary>
			ListCancelRequest = (int)'K',
			/// <summary>
			/// <para>Bid Response (lowercase L)</para>
			/// </summary>
			BidResponse = (int)'l',
			/// <summary>
			/// <para>List Execute</para>
			/// </summary>
			ListExecute = (int)'L',
			/// <summary>
			/// <para>List Strike Price</para>
			/// </summary>
			ListStrikePrice = (int)'m',
			/// <summary>
			/// <para>List Status Request</para>
			/// </summary>
			ListStatusRequest = (int)'M',
			/// <summary>
			/// <para>List Status</para>
			/// </summary>
			ListStatus = (int)'N',
			/// <summary>
			/// <para>Allocation ACK</para>
			/// </summary>
			AllocationInstructionAck = (int)'P',
			/// <summary>
			/// <para>Don't Know Trade (DK)</para>
			/// </summary>
			DontKnowTrade = (int)'Q',
			/// <summary>
			/// <para>Quote Request</para>
			/// </summary>
			QuoteRequest = (int)'R',
			/// <summary>
			/// <para>Quote</para>
			/// </summary>
			Quote = (int)'S',
			/// <summary>
			/// <para>Settlement Instructions</para>
			/// </summary>
			SettlementInstructions = (int)'T',
			/// <summary>
			/// <para>Market Data Request</para>
			/// </summary>
			MarketDataRequest = (int)'V',
			/// <summary>
			/// <para>Market Data-Snapshot/Full Refresh</para>
			/// </summary>
			MarketDataSnapshotFullRefresh = (int)'W',
			/// <summary>
			/// <para>Market Data-Incremental Refresh</para>
			/// </summary>
			MarketDataIncrementalRefresh = (int)'X',
			/// <summary>
			/// <para>Market Data Request Reject</para>
			/// </summary>
			MarketDataRequestReject = (int)'Y',
			/// <summary>
			/// <para>Quote Cancel</para>
			/// </summary>
			QuoteCancel = (int)'Z',
		}

		/// <summary>
		/// <para>Indicates possible retransmission of message with this sequence number</para>
		/// <para>Valid values:</para>
		/// <para>Y = Possible duplicate</para>
		/// <para>N = Original transmission</para>
		/// </summary>
		public enum PossDupFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Original transmission</para>
			/// </summary>
			OriginalTransmission = (int)'N',
			/// <summary>
			/// <para>Possible duplicate</para>
			/// </summary>
			PossibleDuplicate = (int)'Y',
		}

		/// <summary>
		/// <para>Indicates that message may contain information that has been sent under another sequence number.</para>
		/// <para>Valid Values:</para>
		/// <para>Y=Possible resend</para>
		/// <para>N=Original transmission</para>
		/// </summary>
		public enum PossResend
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Original transmission</para>
			/// </summary>
			OriginalTransmission = (int)'N',
			/// <summary>
			/// <para>Possible resend</para>
			/// </summary>
			PossibleResend = (int)'Y',
		}

		/// <summary>
		/// <para>Type of message encoding (non-ASCII (non-English) characters) used in a message's 'Encoded' fields.</para>
		/// <para>Valid values:</para>
		/// <para>ISO-2022-JP (for using JIS)</para>
		/// <para>EUC-JP (for using EUC)</para>
		/// <para>Shift_JIS (for using SJIS)</para>
		/// <para>UTF-8 (for using Unicode)</para>
		/// </summary>
		public enum MessageEncoding
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>(for using EUC)</para>
			/// </summary>
			EUCJP,
			/// <summary>
			/// <para>(for using JIS)</para>
			/// </summary>
			ISO2022JP,
			/// <summary>
			/// <para>(for using SJIS)</para>
			/// </summary>
			ShiftJIS,
			/// <summary>
			/// <para>(for using Unicode)</para>
			/// </summary>
			UTF8,
		}

		/// <summary>
		/// <para>Identifies IOI message transaction type</para>
		/// <para>Valid values:</para>
		/// <para>N = New</para>
		/// <para>C = Cancel</para>
		/// <para>R = Replace</para>
		/// </summary>
		public enum IOITransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'C',
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'N',
			/// <summary>
			/// <para>Replace</para>
			/// </summary>
			Replace = (int)'R',
		}

		/// <summary>
		/// <para>Identifies class of alternative SecurityID</para>
		/// <para>Valid values:</para>
		/// <para>1 = CUSIP</para>
		/// <para>2 = SEDOL</para>
		/// <para>3 = QUIK</para>
		/// <para>4 = ISIN number</para>
		/// <para>5 = RIC code</para>
		/// <para>6 = ISO Currency Code</para>
		/// <para>7 = ISO Country Code</para>
		/// <para>8 = Exchange Symbol</para>
		/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
		/// <para>100+ are reserved for private security identifications</para>
		/// </summary>
		public enum IDSource
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>CUSIP</para>
			/// </summary>
			CUSIP = (int)'1',
			/// <summary>
			/// <para>SEDOL</para>
			/// </summary>
			SEDOL = (int)'2',
			/// <summary>
			/// <para>QUIK</para>
			/// </summary>
			QUIK = (int)'3',
			/// <summary>
			/// <para>ISIN number</para>
			/// </summary>
			ISINNumber = (int)'4',
			/// <summary>
			/// <para>RIC code</para>
			/// </summary>
			RICCode = (int)'5',
			/// <summary>
			/// <para>ISO Currency Code</para>
			/// </summary>
			ISOCurrencyCode = (int)'6',
			/// <summary>
			/// <para>ISO Country Code</para>
			/// </summary>
			ISOCountryCode = (int)'7',
			/// <summary>
			/// <para>Exchange Symbol</para>
			/// </summary>
			ExchangeSymbol = (int)'8',
			/// <summary>
			/// <para>Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// </summary>
			ConsolidatedTapeAssociation = (int)'9',
		}

		/// <summary>
		/// <para>Indicates type of security (ISITC spec)</para>
		/// <para>Valid values:</para>
		/// <para>BA = Bankers Acceptance</para>
		/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
		/// <para>CD = Certificate Of Deposit</para>
		/// <para>CMO = Collateralize Mortgage Obligation</para>
		/// <para>CORP = Corporate Bond</para>
		/// <para>CP = Commercial Paper</para>
		/// <para>CPP = Corporate Private Placement</para>
		/// <para>CS = Common Stock</para>
		/// <para>FHA = Federal Housing Authority</para>
		/// <para>FHL = Federal Home Loan</para>
		/// <para>FN = Federal National Mortgage Association</para>
		/// <para>FOR = Foreign Exchange Contract</para>
		/// <para>FUT = Future</para>
		/// <para>GN = Government National Mortgage Association</para>
		/// <para>GOVT = Treasuries + Agency Debenture</para>
		/// <para>IET Mortgage IOETTE</para>
		/// <para>MF = Mutual Fund</para>
		/// <para>MIO = Mortgage Interest Only</para>
		/// <para>MPO = Mortgage Principal Only</para>
		/// <para>MPP = Mortgage Private Placement</para>
		/// <para>MPT = Miscellaneous Pass-Thru</para>
		/// <para>MUNI = Municipal Bond</para>
		/// <para>NONE = No ISITC Security Type</para>
		/// <para>OPT = Option</para>
		/// <para>PS = Preferred Stock</para>
		/// <para>RP = Repurchase Agreement</para>
		/// <para>RVRP = Reverse Repurchase Agreement</para>
		/// <para>SL = Student Loan Marketing Association</para>
		/// <para>TD = Time Deposit</para>
		/// <para>USTB = US Treasury Bill</para>
		/// <para>WAR = Warrant</para>
		/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
		/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
		/// </summary>
		public enum SecurityType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Wildcard entry (used on Security Definition Request message)</para>
			/// </summary>
			Wildcard,
			/// <summary>
			/// <para>Bankers Acceptance</para>
			/// </summary>
			BankersAcceptance,
			/// <summary>
			/// <para>Convertible Bond (Note not part of ISITC spec)</para>
			/// </summary>
			ConvertibleBond,
			/// <summary>
			/// <para>Certificate Of Deposit</para>
			/// </summary>
			CertificateOfDeposit,
			/// <summary>
			/// <para>Collateralize Mortgage Obligation</para>
			/// </summary>
			CollateralizedMortgageObligation,
			/// <summary>
			/// <para>Corporate Bond</para>
			/// </summary>
			CorporateBond,
			/// <summary>
			/// <para>Commercial Paper</para>
			/// </summary>
			CommercialPaper,
			/// <summary>
			/// <para>Corporate Private Placement</para>
			/// </summary>
			CorporatePrivatePlacement,
			/// <summary>
			/// <para>Common Stock</para>
			/// </summary>
			CommonStock,
			/// <summary>
			/// <para>Federal Housing Authority</para>
			/// </summary>
			FederalHousingAuthority,
			/// <summary>
			/// <para>Federal Home Loan</para>
			/// </summary>
			FederalHomeLoan,
			/// <summary>
			/// <para>Federal National Mortgage Association</para>
			/// </summary>
			FederalNationalMortgageAssociation,
			/// <summary>
			/// <para>Foreign Exchange Contract</para>
			/// </summary>
			ForeignExchangeContract,
			/// <summary>
			/// <para>Future</para>
			/// </summary>
			Future,
			/// <summary>
			/// <para>Government National Mortgage Association</para>
			/// </summary>
			GovernmentNationalMortgageAssociation,
			/// <summary>
			/// <para>Treasuries + Agency Debenture</para>
			/// </summary>
			TreasuriesAgencyDebenture,
			/// <summary>
			/// <para>Mortgage IOETTE</para>
			/// </summary>
			IOETTEMortgage,
			/// <summary>
			/// <para>Mutual Fund</para>
			/// </summary>
			MutualFund,
			/// <summary>
			/// <para>Mortgage Interest Only</para>
			/// </summary>
			MortgageInterestOnly,
			/// <summary>
			/// <para>Mortgage Principal Only</para>
			/// </summary>
			MortgagePrincipalOnly,
			/// <summary>
			/// <para>Mortgage Private Placement</para>
			/// </summary>
			MortgagePrivatePlacement,
			/// <summary>
			/// <para>Miscellaneous Pass-Thru</para>
			/// </summary>
			MiscellaneousPassThrough,
			/// <summary>
			/// <para>Municipal Bond</para>
			/// </summary>
			MunicipalBond,
			/// <summary>
			/// <para>No ISITC Security Type</para>
			/// </summary>
			NoSecurityType,
			/// <summary>
			/// <para>Option</para>
			/// </summary>
			Option,
			/// <summary>
			/// <para>Preferred Stock</para>
			/// </summary>
			PreferredStock,
			/// <summary>
			/// <para>Repurchase Agreement</para>
			/// </summary>
			RepurchaseAgreement,
			/// <summary>
			/// <para>Reverse Repurchase Agreement</para>
			/// </summary>
			ReverseRepurchaseAgreement,
			/// <summary>
			/// <para>Student Loan Marketing Association</para>
			/// </summary>
			StudentLoanMarketingAssociation,
			/// <summary>
			/// <para>Time Deposit</para>
			/// </summary>
			TimeDeposit,
			/// <summary>
			/// <para>US Treasury Bill</para>
			/// </summary>
			USTreasuryBillOld,
			/// <summary>
			/// <para>Warrant</para>
			/// </summary>
			Warrant,
			/// <summary>
			/// <para>Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// </summary>
			CatsTigersAndLions,
		}

		/// <summary>
		/// <para>Indicates whether an Option is for a put or call.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Put</para>
		/// <para>1 = Call</para>
		/// </summary>
		public enum PutOrCall
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Put</para>
			/// </summary>
			Put = (int)'0',
			/// <summary>
			/// <para>Call</para>
			/// </summary>
			Call = (int)'1',
		}

		/// <summary>
		/// <para>Side of order</para>
		/// <para>Valid values:</para>
		/// <para>1 = Buy</para>
		/// <para>2 = Sell</para>
		/// <para>3 = Buy minus</para>
		/// <para>4 = Sell plus</para>
		/// <para>5 = Sell short</para>
		/// <para>6 = Sell short exempt</para>
		/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
		/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
		/// <para>9 = Cross short</para>
		/// </summary>
		public enum Side
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Buy</para>
			/// </summary>
			Buy = (int)'1',
			/// <summary>
			/// <para>Sell</para>
			/// </summary>
			Sell = (int)'2',
			/// <summary>
			/// <para>Buy minus</para>
			/// </summary>
			BuyMinus = (int)'3',
			/// <summary>
			/// <para>Sell plus</para>
			/// </summary>
			SellPlus = (int)'4',
			/// <summary>
			/// <para>Sell short</para>
			/// </summary>
			SellShort = (int)'5',
			/// <summary>
			/// <para>Sell short exempt</para>
			/// </summary>
			SellShortExempt = (int)'6',
			/// <summary>
			/// <para>Undisclosed (valid for IOI and List Order messages only)</para>
			/// </summary>
			Undisclosed = (int)'7',
			/// <summary>
			/// <para>Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// </summary>
			Cross = (int)'8',
			/// <summary>
			/// <para>Cross short</para>
			/// </summary>
			CrossShort = (int)'9',
		}

		/// <summary>
		/// <para>Number of shares in numeric or relative size.</para>
		/// <para>Valid values:</para>
		/// <para>0 - 1000000000</para>
		/// <para>S = Small</para>
		/// <para>M = Medium</para>
		/// <para>L = Large</para>
		/// </summary>
		public enum IOIShares
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Large</para>
			/// </summary>
			Large = (int)'L',
			/// <summary>
			/// <para>Medium</para>
			/// </summary>
			Medium = (int)'M',
			/// <summary>
			/// <para>Small</para>
			/// </summary>
			Small = (int)'S',
		}

		/// <summary>
		/// <para>Relative quality of indication</para>
		/// <para>Valid values:</para>
		/// <para>L = Low</para>
		/// <para>M = Medium</para>
		/// <para>H = High</para>
		/// </summary>
		public enum IOIQltyInd
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>High</para>
			/// </summary>
			High = (int)'H',
			/// <summary>
			/// <para>Low</para>
			/// </summary>
			Low = (int)'L',
			/// <summary>
			/// <para>Medium</para>
			/// </summary>
			Medium = (int)'M',
		}

		/// <summary>
		/// <para>Indicates that IOI is the result of an existing agency order or a facilitation position resulting from an agency order, not from principal trading or order solicitation activity.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Natural</para>
		/// <para>N = Not natural</para>
		/// </summary>
		public enum IOINaturalFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Not natural</para>
			/// </summary>
			NotNatural = (int)'N',
			/// <summary>
			/// <para>Natural</para>
			/// </summary>
			Natural = (int)'Y',
		}

		/// <summary>
		/// <para>Code to qualify IOI use.</para>
		/// <para>Valid values:</para>
		/// <para>A = All or none</para>
		/// <para>C = At the close</para>
		/// <para>I = In touch with</para>
		/// <para>L = Limit</para>
		/// <para>M = More behind</para>
		/// <para>O = At the open</para>
		/// <para>P = Taking a position</para>
		/// <para>Q = At the Market (previously called Current Quote)</para>
		/// <para>R = Ready to trade</para>
		/// <para>S = Portfolio show-n</para>
		/// <para>T = Through the day</para>
		/// <para>V = Versus</para>
		/// <para>W = Indication - Working away</para>
		/// <para>X = Crossing opportunity</para>
		/// <para>Y = At the Midpoint</para>
		/// <para>Z = Pre-open</para>
		/// </summary>
		public enum IOIQualifier
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>All or none</para>
			/// </summary>
			AllOrNone = (int)'A',
			/// <summary>
			/// <para>At the close</para>
			/// </summary>
			AtTheClose = (int)'C',
			/// <summary>
			/// <para>In touch with</para>
			/// </summary>
			InTouchWith = (int)'I',
			/// <summary>
			/// <para>Limit</para>
			/// </summary>
			Limit = (int)'L',
			/// <summary>
			/// <para>More behind</para>
			/// </summary>
			MoreBehind = (int)'M',
			/// <summary>
			/// <para>At the open</para>
			/// </summary>
			AtTheOpen = (int)'O',
			/// <summary>
			/// <para>Taking a position</para>
			/// </summary>
			TakingAPosition = (int)'P',
			/// <summary>
			/// <para>At the Market (previously called Current Quote)</para>
			/// </summary>
			AtTheMarket = (int)'Q',
			/// <summary>
			/// <para>Ready to trade</para>
			/// </summary>
			ReadyToTrade = (int)'R',
			/// <summary>
			/// <para>Portfolio show-n</para>
			/// </summary>
			PortfolioShown = (int)'S',
			/// <summary>
			/// <para>Through the day</para>
			/// </summary>
			ThroughTheDay = (int)'T',
			/// <summary>
			/// <para>Versus</para>
			/// </summary>
			Versus = (int)'V',
			/// <summary>
			/// <para>Indication - Working away</para>
			/// </summary>
			Indication = (int)'W',
			/// <summary>
			/// <para>Crossing opportunity</para>
			/// </summary>
			CrossingOpportunity = (int)'X',
			/// <summary>
			/// <para>At the Midpoint</para>
			/// </summary>
			AtTheMidpoint = (int)'Y',
			/// <summary>
			/// <para>Pre-open</para>
			/// </summary>
			PreOpen = (int)'Z',
		}

		/// <summary>
		/// <para>Indicates the type of RoutingID specified.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Target Firm</para>
		/// <para>2 = Target List</para>
		/// <para>3 = Block Firm</para>
		/// <para>4 = Block List</para>
		/// </summary>
		public enum RoutingType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Target Firm</para>
			/// </summary>
			TargetFirm = (int)'1',
			/// <summary>
			/// <para>Target List</para>
			/// </summary>
			TargetList = (int)'2',
			/// <summary>
			/// <para>Block Firm</para>
			/// </summary>
			BlockFirm = (int)'3',
			/// <summary>
			/// <para>Block List</para>
			/// </summary>
			BlockList = (int)'4',
		}

		/// <summary>
		/// <para>For Fixed Income. Identifies the benchmark (e.g. used in conjunction with the SpreadToBenchmark field).</para>
		/// <para>Valid values:</para>
		/// <para>1 = CURVE</para>
		/// <para>2 = 5-YR</para>
		/// <para>3 = OLD-5</para>
		/// <para>4 = 10-YR</para>
		/// <para>5 = OLD-10</para>
		/// <para>6 = 30-YR</para>
		/// <para>7 = OLD-30</para>
		/// <para>8 = 3-MO-LIBOR</para>
		/// <para>9 = 6-MO-LIBOR</para>
		/// </summary>
		public enum Benchmark
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>CURVE</para>
			/// </summary>
			CURVE = (int)'1',
			/// <summary>
			/// <para>5-YR</para>
			/// </summary>
			FiveYR = (int)'2',
			/// <summary>
			/// <para>OLD-5</para>
			/// </summary>
			OLD5 = (int)'3',
			/// <summary>
			/// <para>10-YR</para>
			/// </summary>
			TenYR = (int)'4',
			/// <summary>
			/// <para>OLD-10</para>
			/// </summary>
			OLD10 = (int)'5',
			/// <summary>
			/// <para>30-YR</para>
			/// </summary>
			ThirtyYR = (int)'6',
			/// <summary>
			/// <para>OLD-30</para>
			/// </summary>
			OLD30 = (int)'7',
			/// <summary>
			/// <para>3-MO-LIBOR</para>
			/// </summary>
			ThreeMOLIBOR = (int)'8',
			/// <summary>
			/// <para>6-MO-LIBOR</para>
			/// </summary>
			SixMOLIBOR = (int)'9',
		}

		/// <summary>
		/// <para>Identifies Advertisement message transaction type</para>
		/// <para>Valid values:</para>
		/// <para>N = New</para>
		/// <para>C = Cancel</para>
		/// <para>R = Replace</para>
		/// </summary>
		public enum AdvTransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'C',
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'N',
			/// <summary>
			/// <para>Replace</para>
			/// </summary>
			Replace = (int)'R',
		}

		/// <summary>
		/// <para>Broker's side of advertised trade</para>
		/// <para>Valid values:</para>
		/// <para>B = Buy</para>
		/// <para>S = Sell</para>
		/// <para>X = Cross</para>
		/// <para>T = Trade</para>
		/// </summary>
		public enum AdvSide
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Buy</para>
			/// </summary>
			Buy = (int)'B',
			/// <summary>
			/// <para>Sell</para>
			/// </summary>
			Sell = (int)'S',
			/// <summary>
			/// <para>Trade</para>
			/// </summary>
			Trade = (int)'T',
			/// <summary>
			/// <para>Cross</para>
			/// </summary>
			Cross = (int)'X',
		}

		/// <summary>
		/// <para>Urgency flag</para>
		/// <para>Valid values:</para>
		/// <para>0 = Normal</para>
		/// <para>1 = Flash</para>
		/// <para>2 = Background</para>
		/// </summary>
		public enum Urgency
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Normal</para>
			/// </summary>
			Normal = (int)'0',
			/// <summary>
			/// <para>Flash</para>
			/// </summary>
			Flash = (int)'1',
			/// <summary>
			/// <para>Background</para>
			/// </summary>
			Background = (int)'2',
		}

		/// <summary>
		/// <para>Email message type.</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Reply</para>
		/// <para>2 = Admin Reply</para>
		/// </summary>
		public enum EmailType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Reply</para>
			/// </summary>
			Reply = (int)'1',
			/// <summary>
			/// <para>Admin Reply</para>
			/// </summary>
			AdminReply = (int)'2',
		}

		/// <summary>
		/// <para>Indicates the type of Quote Request being generated</para>
		/// <para>Valid values:</para>
		/// <para>1-Manual</para>
		/// <para>2-Automatic</para>
		/// </summary>
		public enum QuoteRequestType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Manual</para>
			/// </summary>
			Manual = (int)'1',
			/// <summary>
			/// <para>Automatic</para>
			/// </summary>
			Automatic = (int)'2',
		}

		/// <summary>
		/// <para>Order type.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Market</para>
		/// <para>2 = Limit</para>
		/// <para>3 = Stop</para>
		/// <para>4 = Stop limit</para>
		/// <para>5 = Market on close</para>
		/// <para>6 = With or without</para>
		/// <para>7 = Limit or better</para>
		/// <para>8 = Limit with or without</para>
		/// <para>9 = On basis</para>
		/// <para>A = On close</para>
		/// <para>B = Limit on close</para>
		/// <para>C =Forex - Market</para>
		/// <para>D = Previously quoted</para>
		/// <para>E = Previously indicated</para>
		/// <para>F = Forex - Limit</para>
		/// <para>G = Forex - Swap</para>
		/// <para>H = Forex - Previously Quoted</para>
		/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
		/// <para>P = Pegged</para>
		/// </summary>
		public enum OrdType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Market</para>
			/// </summary>
			Market = (int)'1',
			/// <summary>
			/// <para>Limit</para>
			/// </summary>
			Limit = (int)'2',
			/// <summary>
			/// <para>Stop</para>
			/// </summary>
			Stop = (int)'3',
			/// <summary>
			/// <para>Stop limit</para>
			/// </summary>
			StopLimit = (int)'4',
			/// <summary>
			/// <para>Market on close</para>
			/// </summary>
			MarketOnClose = (int)'5',
			/// <summary>
			/// <para>With or without</para>
			/// </summary>
			WithOrWithout = (int)'6',
			/// <summary>
			/// <para>Limit or better</para>
			/// </summary>
			LimitOrBetter = (int)'7',
			/// <summary>
			/// <para>Limit with or without</para>
			/// </summary>
			LimitWithOrWithout = (int)'8',
			/// <summary>
			/// <para>On basis</para>
			/// </summary>
			OnBasis = (int)'9',
			/// <summary>
			/// <para>On close</para>
			/// </summary>
			OnClose = (int)'A',
			/// <summary>
			/// <para>Limit on close</para>
			/// </summary>
			LimitOnClose = (int)'B',
			/// <summary>
			/// <para>Forex - Market</para>
			/// </summary>
			ForexMarket = (int)'C',
			/// <summary>
			/// <para>Previously quoted</para>
			/// </summary>
			PreviouslyQuoted = (int)'D',
			/// <summary>
			/// <para>Previously indicated</para>
			/// </summary>
			PreviouslyIndicated = (int)'E',
			/// <summary>
			/// <para>Forex - Limit</para>
			/// </summary>
			ForexLimit = (int)'F',
			/// <summary>
			/// <para>Forex - Swap</para>
			/// </summary>
			ForexSwap = (int)'G',
			/// <summary>
			/// <para>Forex - Previously Quoted</para>
			/// </summary>
			ForexPreviouslyQuoted = (int)'H',
			/// <summary>
			/// <para>Funari (Limit Day Order with unexecuted portion handled as Market On Close.   e.g. Japan)</para>
			/// </summary>
			Funari = (int)'I',
			/// <summary>
			/// <para>Pegged</para>
			/// </summary>
			Pegged = (int)'P',
		}

		/// <summary>
		/// <para>Level of Response requested from receiver of Quote messages.</para>
		/// <para>Valid Values:</para>
		/// <para>0 - No Acknowledgement (Default)</para>
		/// <para>1 - Acknowledge only negative or erroneous quotes</para>
		/// <para>2 - Acknowledge each Quote messages</para>
		/// </summary>
		public enum QuoteResponseLevel
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>No Acknowledgement (Default)</para>
			/// </summary>
			NoAcknowledgement = (int)'0',
			/// <summary>
			/// <para>Acknowledge only negative or erroneous quotes</para>
			/// </summary>
			AcknowledgeOnlyNegativeOrErroneousQuotes = (int)'1',
			/// <summary>
			/// <para>Acknowledge each Quote messages</para>
			/// </summary>
			AcknowledgeEachQuoteMessage = (int)'2',
		}

		/// <summary>
		/// <para>Identifies the type of quote cancel.</para>
		/// <para>Valid Values:</para>
		/// <para>1 - Cancel for Symbol(s)</para>
		/// <para>2 - Cancel for Security Type(s)</para>
		/// <para>3 - Cancel for Underlying Symbol</para>
		/// <para>4 - Cancel All Quotes</para>
		/// </summary>
		public enum QuoteCancelType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel for Symbol(s)</para>
			/// </summary>
			CancelForOneOrMoreSecurities = (int)'1',
			/// <summary>
			/// <para>Cancel for Security Type(s)</para>
			/// </summary>
			CancelForSecurityType = (int)'2',
			/// <summary>
			/// <para>Cancel for Underlying Symbol</para>
			/// </summary>
			CancelForUnderlyingSecurity = (int)'3',
			/// <summary>
			/// <para>Cancel for All Quotes</para>
			/// </summary>
			CancelAllQuotes = (int)'4',
		}

		/// <summary>
		/// <para>Identifies the status of the quote acknowledgement.</para>
		/// <para>Valid values:</para>
		/// <para>0-Accepted</para>
		/// <para>1-Canceled for Symbol(s)</para>
		/// <para>2-Canceled for Security Type(s)</para>
		/// <para>3-Canceled for Underlying</para>
		/// <para>4-Canceled All</para>
		/// <para>5-Rejected</para>
		/// </summary>
		public enum QuoteAckStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Accepted</para>
			/// </summary>
			Accepted = (int)'0',
			/// <summary>
			/// <para>Canceled for Symbol(s)</para>
			/// </summary>
			CancelForSymbol = (int)'1',
			/// <summary>
			/// <para>Canceled  for Security Type(s)</para>
			/// </summary>
			CanceledForSecurityType = (int)'2',
			/// <summary>
			/// <para>Canceled for Underlying</para>
			/// </summary>
			CanceledForUnderlying = (int)'3',
			/// <summary>
			/// <para>Canceled All</para>
			/// </summary>
			CanceledAll = (int)'4',
			/// <summary>
			/// <para>Rejected</para>
			/// </summary>
			Rejected = (int)'5',
		}

		/// <summary>
		/// <para>Reason Quote was rejected:</para>
		/// <para>Valid Values:</para>
		/// <para>1 = Unknown symbol (Security)</para>
		/// <para>2 = Exchange(Security) closed</para>
		/// <para>3 = Quote Request exceeds limit</para>
		/// <para>4 = Too late to enter</para>
		/// <para>5 = Unknown Quote</para>
		/// <para>6 = Duplicate Quote 7 = Invalid bid/ask spread</para>
		/// <para>8 = Invalid price</para>
		/// <para>9 = Not authorized to quote security</para>
		/// </summary>
		public enum QuoteRejectReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Unknown symbol (Security)</para>
			/// </summary>
			UnknownSymbol = (int)'1',
			/// <summary>
			/// <para>Exchange(Security) closed</para>
			/// </summary>
			Exchange = (int)'2',
			/// <summary>
			/// <para>Quote Request exceeds limit</para>
			/// </summary>
			QuoteRequestExceedsLimit = (int)'3',
			/// <summary>
			/// <para>Too late to enter</para>
			/// </summary>
			TooLateToEnter = (int)'4',
			/// <summary>
			/// <para>Unknown Quote</para>
			/// </summary>
			UnknownQuote = (int)'5',
			/// <summary>
			/// <para>Duplicate Quote</para>
			/// </summary>
			DuplicateQuote = (int)'6',
			/// <summary>
			/// <para>Invalid bid/ask spread</para>
			/// </summary>
			InvalidBid = (int)'7',
			/// <summary>
			/// <para>Invalid price</para>
			/// </summary>
			InvalidPrice = (int)'8',
			/// <summary>
			/// <para>Not authorized to quote security</para>
			/// </summary>
			NotAuthorizedToQuoteSecurity = (int)'9',
		}

		/// <summary>
		/// <para>Reason Quote Entry was rejected:</para>
		/// <para>Valid values:</para>
		/// <para>1 = Unknown symbol (Security)</para>
		/// <para>2 = Exchange(Security) closed</para>
		/// <para>3 = Quote exceeds limit</para>
		/// <para>4 = Too late to enter</para>
		/// <para>5 = Unknown Quote</para>
		/// <para>6 = Duplicate Quote</para>
		/// <para>7 = Invalid bid/ask spread</para>
		/// <para>8 = Invalid price</para>
		/// <para>9 = Not authorized to quote security</para>
		/// </summary>
		public enum QuoteEntryRejectReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Unknown symbol (Security)</para>
			/// </summary>
			UnknownSymbol = (int)'1',
			/// <summary>
			/// <para>Exchange(Security) closed</para>
			/// </summary>
			Exchange = (int)'2',
			/// <summary>
			/// <para>Quote exceeds limit</para>
			/// </summary>
			QuoteExceedsLimit = (int)'3',
			/// <summary>
			/// <para>Too late to enter</para>
			/// </summary>
			TooLateToEnter = (int)'4',
			/// <summary>
			/// <para>Unknown Quote</para>
			/// </summary>
			UnknownQuote = (int)'5',
			/// <summary>
			/// <para>Duplicate Quote</para>
			/// </summary>
			DuplicateQuote = (int)'6',
			/// <summary>
			/// <para>Invalid bid/ask spread</para>
			/// </summary>
			InvalidBidAskSpread = (int)'7',
			/// <summary>
			/// <para>Invalid price</para>
			/// </summary>
			InvalidPrice = (int)'8',
			/// <summary>
			/// <para>Not authorized to quote security</para>
			/// </summary>
			NotAuthorizedToQuoteSecurity = (int)'9',
		}

		/// <summary>
		/// <para>Subscription Request Type</para>
		/// <para>Valid values:</para>
		/// <para>0 = Snapshot</para>
		/// <para>1 = Snapshot + Updates (Subscribe)</para>
		/// <para>2 = Disable previous Snapshot + Update Request (Unsubscribe)</para>
		/// </summary>
		public enum SubscriptionRequestType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Snapshot</para>
			/// </summary>
			Snapshot = (int)'0',
			/// <summary>
			/// <para>Snapshot + Updates (Subscribe)</para>
			/// </summary>
			SnapshotAndUpdates = (int)'1',
			/// <summary>
			/// <para>Disable previous Snapshot + Update Request (Unsubscribe)</para>
			/// </summary>
			DisablePreviousSnapshot = (int)'2',
		}

		/// <summary>
		/// <para>Specifies the type of Market Data update.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Full Refresh</para>
		/// <para>1 = Incremental Refresh</para>
		/// </summary>
		public enum MDUpdateType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Full Refresh</para>
			/// </summary>
			FullRefresh = (int)'0',
			/// <summary>
			/// <para>Incremental Refresh</para>
			/// </summary>
			IncrementalRefresh = (int)'1',
		}

		/// <summary>
		/// <para>Specifies whether or not book entries should be aggregated.</para>
		/// <para>Valid values:</para>
		/// <para>Y = one book entry per side per price</para>
		/// <para>N = Multiple entries per side per price allowed</para>
		/// <para>(Not specified) = broker option</para>
		/// </summary>
		public enum AggregatedBook
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>broker option</para>
			/// </summary>
			NotSpecified,
			/// <summary>
			/// <para>Multiple entries per side per price allowed</para>
			/// </summary>
			BookEntriesShouldNotBeAggregated,
			/// <summary>
			/// <para>one book entry per side per price</para>
			/// </summary>
			BookEntriesToBeAggregated,
		}

		/// <summary>
		/// <para>Type Market Data entry.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Bid</para>
		/// <para>1 = Offer</para>
		/// <para>2 = Trade</para>
		/// <para>3 = Index Value</para>
		/// <para>4 = Opening Price</para>
		/// <para>5 = Closing Price</para>
		/// <para>6 = Settlement Price</para>
		/// <para>7 = Trading Session High Price</para>
		/// <para>8 = Trading Session Low Price</para>
		/// <para>9 = Trading Session VWAP Price</para>
		/// </summary>
		public enum MDEntryType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Bid</para>
			/// </summary>
			Bid = (int)'0',
			/// <summary>
			/// <para>Offer</para>
			/// </summary>
			Offer = (int)'1',
			/// <summary>
			/// <para>Trade</para>
			/// </summary>
			Trade = (int)'2',
			/// <summary>
			/// <para>Index Value</para>
			/// </summary>
			IndexValue = (int)'3',
			/// <summary>
			/// <para>Opening Price</para>
			/// </summary>
			OpeningPrice = (int)'4',
			/// <summary>
			/// <para>Closing Price</para>
			/// </summary>
			ClosingPrice = (int)'5',
			/// <summary>
			/// <para>Settlement Price</para>
			/// </summary>
			SettlementPrice = (int)'6',
			/// <summary>
			/// <para>Trading Session High Price</para>
			/// </summary>
			TradingSessionHighPrice = (int)'7',
			/// <summary>
			/// <para>Trading Session Low Price</para>
			/// </summary>
			TradingSessionLowPrice = (int)'8',
			/// <summary>
			/// <para>Trading Session VWAP Price</para>
			/// </summary>
			TradingSessionVWAPPrice = (int)'9',
		}

		/// <summary>
		/// <para>Identifies a firm's financial status.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Bankrupt</para>
		/// </summary>
		public enum FinancialStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Bankrupt</para>
			/// </summary>
			Bankrupt = (int)'1',
		}

		/// <summary>
		/// <para>Identifies the type of Corporate Action.</para>
		/// <para>Valid values:</para>
		/// <para>A = Ex-Dividend</para>
		/// <para>B = Ex-Distribution</para>
		/// <para>C = Ex-Rights</para>
		/// <para>D = New</para>
		/// <para>E = Ex-Interest</para>
		/// </summary>
		public enum CorporateAction
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Ex-Dividend</para>
			/// </summary>
			ExDividend = (int)'A',
			/// <summary>
			/// <para>Ex-Distribution</para>
			/// </summary>
			ExDistribution = (int)'B',
			/// <summary>
			/// <para>Ex-Rights</para>
			/// </summary>
			ExRights = (int)'C',
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'D',
			/// <summary>
			/// <para>Ex-Interest</para>
			/// </summary>
			ExInterest = (int)'E',
		}

		/// <summary>
		/// <para>Direction of the "tick".</para>
		/// <para>Valid values:</para>
		/// <para>0 = Plus Tick</para>
		/// <para>1 = Zero-Plus Tick</para>
		/// <para>2 = Minus Tick</para>
		/// <para>3 = Zero-Minus Tick</para>
		/// </summary>
		public enum TickDirection
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Plus Tick</para>
			/// </summary>
			PlusTick = (int)'0',
			/// <summary>
			/// <para>Zero-Plus Tick</para>
			/// </summary>
			ZeroPlusTick = (int)'1',
			/// <summary>
			/// <para>Minus Tick</para>
			/// </summary>
			MinusTick = (int)'2',
			/// <summary>
			/// <para>Zero-Minus Tick</para>
			/// </summary>
			ZeroMinusTick = (int)'3',
		}

		/// <summary>
		/// <para>Space-delimited list of conditions describing a quote.</para>
		/// <para>Valid values:</para>
		/// <para>A = Open / Active</para>
		/// <para>B = Closed / Inactive</para>
		/// <para>C = Exchange Best</para>
		/// <para>D = Consolidated Best</para>
		/// <para>E = Locked</para>
		/// <para>F = Crossed</para>
		/// <para>G = Depth</para>
		/// <para>H = Fast Trading</para>
		/// <para>I = Non-Firm</para>
		/// </summary>
		public enum QuoteCondition
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Open / Active</para>
			/// </summary>
			Open = (int)'A',
			/// <summary>
			/// <para>Closed / Inactive</para>
			/// </summary>
			Closed = (int)'B',
			/// <summary>
			/// <para>Exchange Best</para>
			/// </summary>
			ExchangeBest = (int)'C',
			/// <summary>
			/// <para>Consolidated Best</para>
			/// </summary>
			ConsolidatedBest = (int)'D',
			/// <summary>
			/// <para>Locked</para>
			/// </summary>
			Locked = (int)'E',
			/// <summary>
			/// <para>Crossed</para>
			/// </summary>
			Crossed = (int)'F',
			/// <summary>
			/// <para>Depth</para>
			/// </summary>
			Depth = (int)'G',
			/// <summary>
			/// <para>Fast Trading</para>
			/// </summary>
			FastTrading = (int)'H',
			/// <summary>
			/// <para>Non-Firm</para>
			/// </summary>
			NonFirm = (int)'I',
		}

		/// <summary>
		/// <para>Space-delimited list of conditions describing a trade</para>
		/// <para>Valid values:</para>
		/// <para>A = Cash (only) Market</para>
		/// <para>B = Average Price Trade</para>
		/// <para>C = Cash Trade (same day clearing)</para>
		/// <para>D = Next Day (only) Market</para>
		/// <para>E = Opening / Reopening Trade Detail</para>
		/// <para>F = Intraday Trade Detail</para>
		/// <para>G = Rule 127 Trade (NYSE)</para>
		/// <para>H = Rule 155 Trade (Amex)</para>
		/// <para>I = Sold Last (late reporting)</para>
		/// <para>J = Next Day Trade (next day clearing)</para>
		/// <para>K = Opened (late report of opened trade)</para>
		/// <para>L = Seller</para>
		/// <para>M = Sold (out of sequence)</para>
		/// <para>N = Stopped Stock (guarantee of price but does not execute the order)</para>
		/// </summary>
		public enum TradeCondition
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cash (only) Market</para>
			/// </summary>
			Cash = (int)'A',
			/// <summary>
			/// <para>Average Price Trade</para>
			/// </summary>
			AveragePriceTrade = (int)'B',
			/// <summary>
			/// <para>Cash Trade (same day clearing)</para>
			/// </summary>
			CashTrade = (int)'C',
			/// <summary>
			/// <para>Next Day (only) Market</para>
			/// </summary>
			NextDay = (int)'D',
			/// <summary>
			/// <para>Opening / Reopening Trade Detail</para>
			/// </summary>
			Opening = (int)'E',
			/// <summary>
			/// <para>Intraday Trade Detail</para>
			/// </summary>
			IntradayTradeDetail = (int)'F',
			/// <summary>
			/// <para>Rule 127 Trade (NYSE)</para>
			/// </summary>
			Rule127Trade = (int)'G',
			/// <summary>
			/// <para>Rule 155 Trade (Amex)</para>
			/// </summary>
			Rule155Trade = (int)'H',
			/// <summary>
			/// <para>Sold Last (late reporting)</para>
			/// </summary>
			SoldLast = (int)'I',
			/// <summary>
			/// <para>Next Day Trade (next day clearing)</para>
			/// </summary>
			NextDayTrade = (int)'J',
			/// <summary>
			/// <para>Opened (late report of opened trade)</para>
			/// </summary>
			Opened = (int)'K',
			/// <summary>
			/// <para>Seller</para>
			/// </summary>
			Seller = (int)'L',
			/// <summary>
			/// <para>Sold (out of sequence)</para>
			/// </summary>
			Sold = (int)'M',
			/// <summary>
			/// <para>Stopped Stock (guarantee of price but does not execute the order)</para>
			/// </summary>
			StoppedStock = (int)'N',
		}

		/// <summary>
		/// <para>Flag that identifies a price.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Daily Open / Close / Settlement price</para>
		/// <para>1 = Session Open / Close / Settlement price</para>
		/// <para>2 = Delivery Settlement price</para>
		/// </summary>
		public enum OpenCloseSettleFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Daily Open / Close / Settlement price</para>
			/// </summary>
			DailyOpen = (int)'0',
			/// <summary>
			/// <para>Session Open / Close / Settlement price</para>
			/// </summary>
			SessionOpen = (int)'1',
			/// <summary>
			/// <para>Delivery Settlement price</para>
			/// </summary>
			DeliverySettlementEntry = (int)'2',
		}

		/// <summary>
		/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Day</para>
		/// <para>1 = Good Till Cancel (GTC)</para>
		/// <para>2 = At the Opening (OPG)</para>
		/// <para>3 = Immediate or Cancel (IOC)</para>
		/// <para>4 = Fill or Kill (FOK)</para>
		/// <para>5 = Good Till Crossing (GTX)</para>
		/// <para>6 = Good Till Date</para>
		/// </summary>
		public enum TimeInForce
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Day</para>
			/// </summary>
			Day = (int)'0',
			/// <summary>
			/// <para>Good Till Cancel (GTC)</para>
			/// </summary>
			GoodTillCancel = (int)'1',
			/// <summary>
			/// <para>At the Opening (OPG)</para>
			/// </summary>
			AtTheOpening = (int)'2',
			/// <summary>
			/// <para>Immediate or Cancel (IOC)</para>
			/// </summary>
			ImmediateOrCancel = (int)'3',
			/// <summary>
			/// <para>Fill or Kill (FOK)</para>
			/// </summary>
			FillOrKill = (int)'4',
			/// <summary>
			/// <para>Good Till Crossing (GTX)</para>
			/// </summary>
			GoodTillCrossing = (int)'5',
			/// <summary>
			/// <para>Good Till Date</para>
			/// </summary>
			GoodTillDate = (int)'6',
		}

		/// <summary>
		/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Not held</para>
		/// <para>2 = Work</para>
		/// <para>3 = Go along</para>
		/// <para>4 = Over the day</para>
		/// <para>5 = Held</para>
		/// <para>6 = Participate don't initiate</para>
		/// <para>7 = Strict scale</para>
		/// <para>8 = Try to scale</para>
		/// <para>9 = Stay on bidside</para>
		/// <para>0 = Stay on offerside</para>
		/// <para>A = No cross (cross is forbidden)</para>
		/// <para>B = OK to cross</para>
		/// <para>C = Call first</para>
		/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
		/// <para>E = Do not increase - DNI</para>
		/// <para>F = Do not reduce - DNR</para>
		/// <para>G = All or none - AON</para>
		/// <para>I = Institutions only</para>
		/// <para>L = Last peg (last sale)</para>
		/// <para>M = Mid-price peg (midprice of inside quote)</para>
		/// <para>N = Non-negotiable</para>
		/// <para>O = Opening peg</para>
		/// <para>P = Market peg</para>
		/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
		/// <para>S = Suspend</para>
		/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
		/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
		/// <para>V = Netting (for Forex)</para>
		/// <para>W = Peg to VWAP</para>
		/// </summary>
		public enum ExecInst
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Stay on offerside</para>
			/// </summary>
			StayOnOfferSide = (int)'0',
			/// <summary>
			/// <para>Not held</para>
			/// </summary>
			NotHeld = (int)'1',
			/// <summary>
			/// <para>Work</para>
			/// </summary>
			Work = (int)'2',
			/// <summary>
			/// <para>Go along</para>
			/// </summary>
			GoAlong = (int)'3',
			/// <summary>
			/// <para>Over the day</para>
			/// </summary>
			OverTheDay = (int)'4',
			/// <summary>
			/// <para>Held</para>
			/// </summary>
			Held = (int)'5',
			/// <summary>
			/// <para>Participate don't initiate</para>
			/// </summary>
			ParticipateDoNotInitiate = (int)'6',
			/// <summary>
			/// <para>Strict scale</para>
			/// </summary>
			StrictScale = (int)'7',
			/// <summary>
			/// <para>Try to scale</para>
			/// </summary>
			TryToScale = (int)'8',
			/// <summary>
			/// <para>Stay on bidside</para>
			/// </summary>
			StayOnBidSide = (int)'9',
			/// <summary>
			/// <para>No cross (cross is forbidden)</para>
			/// </summary>
			NoCross = (int)'A',
			/// <summary>
			/// <para>OK to cross</para>
			/// </summary>
			OKToCross = (int)'B',
			/// <summary>
			/// <para>Call first</para>
			/// </summary>
			CallFirst = (int)'C',
			/// <summary>
			/// <para>Percent of volume (indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)</para>
			/// </summary>
			PercentOfVolume = (int)'D',
			/// <summary>
			/// <para>Do not increase - DNI</para>
			/// </summary>
			DoNotIncrease = (int)'E',
			/// <summary>
			/// <para>Do not reduce - DNR</para>
			/// </summary>
			DoNotReduce = (int)'F',
			/// <summary>
			/// <para>All or none - AON</para>
			/// </summary>
			AllOrNone = (int)'G',
			/// <summary>
			/// <para>Institutions only</para>
			/// </summary>
			InstitutionsOnly = (int)'I',
			/// <summary>
			/// <para>Last peg (last sale)</para>
			/// </summary>
			LastPeg = (int)'L',
			/// <summary>
			/// <para>Mid-price peg (midprice of inside quote)</para>
			/// </summary>
			MidPricePeg = (int)'M',
			/// <summary>
			/// <para>Non-negotiable</para>
			/// </summary>
			NonNegotiable = (int)'N',
			/// <summary>
			/// <para>Opening peg</para>
			/// </summary>
			OpeningPeg = (int)'O',
			/// <summary>
			/// <para>Market peg</para>
			/// </summary>
			MarketPeg = (int)'P',
			/// <summary>
			/// <para>Primary peg (primary market - buy at bid/sell at offer)</para>
			/// </summary>
			PrimaryPeg = (int)'R',
			/// <summary>
			/// <para>Suspend</para>
			/// </summary>
			Suspend = (int)'S',
			/// <summary>
			/// <para>Fixed Peg to Local best bid or offer at time of order</para>
			/// </summary>
			FixedPegToLocalBestBidOrOfferAtTimeOfOrder = (int)'T',
			/// <summary>
			/// <para>Customer Display Instruction (Rule11Ac1-1/4)</para>
			/// </summary>
			CustomerDisplayInstruction = (int)'U',
			/// <summary>
			/// <para>Netting (for Forex)</para>
			/// </summary>
			Netting = (int)'V',
			/// <summary>
			/// <para>Peg to VWAP</para>
			/// </summary>
			PegToVWAP = (int)'W',
		}

		/// <summary>
		/// <para>Type of Market Data update action.</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Change</para>
		/// <para>2 = Delete</para>
		/// </summary>
		public enum MDUpdateAction
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Change</para>
			/// </summary>
			Change = (int)'1',
			/// <summary>
			/// <para>Delete</para>
			/// </summary>
			Delete = (int)'2',
		}

		/// <summary>
		/// <para>Reason for deletion.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Cancelation / Trade Bust</para>
		/// <para>1 = Error</para>
		/// </summary>
		public enum DeleteReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancelation / Trade Bust</para>
			/// </summary>
			Cancellation = (int)'0',
			/// <summary>
			/// <para>Error</para>
			/// </summary>
			Error = (int)'1',
		}

		/// <summary>
		/// <para>Reason for the rejection of a Market Data request.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Unknown symbol</para>
		/// <para>1 = Duplicate MDReqID</para>
		/// <para>2 = Insufficient Bandwidth</para>
		/// <para>3 = Insufficient Permissions</para>
		/// <para>4 = Unsupported SubscriptionRequestType</para>
		/// <para>5 = Unsupported MarketDepth</para>
		/// <para>6 = Unsupported MDUpdateType</para>
		/// <para>7 = Unsupported AggregatedBook</para>
		/// <para>8 = Unsupported MDEntryType</para>
		/// </summary>
		public enum MDReqRejReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Unknown symbol</para>
			/// </summary>
			UnknownSymbol = (int)'0',
			/// <summary>
			/// <para>Duplicate MDReqID</para>
			/// </summary>
			DuplicateMDReqID = (int)'1',
			/// <summary>
			/// <para>Insufficient Bandwidth</para>
			/// </summary>
			InsufficientBandwidth = (int)'2',
			/// <summary>
			/// <para>Insufficient Permissions</para>
			/// </summary>
			InsufficientPermissions = (int)'3',
			/// <summary>
			/// <para>Unsupported SubscriptionRequestType</para>
			/// </summary>
			UnsupportedSubscriptionRequestType = (int)'4',
			/// <summary>
			/// <para>Unsupported MarketDepth</para>
			/// </summary>
			UnsupportedMarketDepth = (int)'5',
			/// <summary>
			/// <para>Unsupported MDUpdateType</para>
			/// </summary>
			UnsupportedMDUpdateType = (int)'6',
			/// <summary>
			/// <para>Unsupported AggregatedBook</para>
			/// </summary>
			UnsupportedAggregatedBook = (int)'7',
			/// <summary>
			/// <para>Unsupported MDEntryType</para>
			/// </summary>
			UnsupportedMDEntryType = (int)'8',
		}

		/// <summary>
		/// <para>Type of Security Definition Request.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Request Security identity and specifications</para>
		/// <para>1 = Request Security identity for the specifications provided (Name of the security is not supplied)</para>
		/// <para>2 = Request List Security Types</para>
		/// <para>3 = Request List Securities (Can be qualified with Symbol, SecurityType, TradingSessionID, SecurityExchange is provided then only list Securities for the specific type)</para>
		/// </summary>
		public enum SecurityRequestType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Request Security identity and specifications</para>
			/// </summary>
			RequestSecurityIdentityAndSpecifications = (int)'0',
			/// <summary>
			/// <para>Request Security identity for the specifications provided (Name of the security is not supplied)</para>
			/// </summary>
			RequestSecurityIdentityForSpecifications = (int)'1',
			/// <summary>
			/// <para>Request List Security Types</para>
			/// </summary>
			RequestListSecurityTypes = (int)'2',
			/// <summary>
			/// <para>Request List Securities (Can be qualified with Symbol, SecurityType, TradingSessionID, SecurityExchange is provided then only list Securities for the specific type)</para>
			/// </summary>
			RequestListSecurities = (int)'3',
		}

		/// <summary>
		/// <para>Type of Security Definition message response.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Accept security proposal as is</para>
		/// <para>2 = Accept security proposal with revisions as indicated in the message</para>
		/// <para>3 = List of security types returned per request</para>
		/// <para>4 = List of securities returned per request</para>
		/// <para>5 = Reject security proposal</para>
		/// <para>6 = Can not match selection criteria</para>
		/// </summary>
		public enum SecurityResponseType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Accept security proposal as is</para>
			/// </summary>
			AcceptAsIs = (int)'1',
			/// <summary>
			/// <para>Accept security proposal with revisions as indicated in the message</para>
			/// </summary>
			AcceptWithRevisions = (int)'2',
			/// <summary>
			/// <para>List of security types returned per request</para>
			/// </summary>
			ListOfSecurityTypesReturnedPerRequest = (int)'3',
			/// <summary>
			/// <para>List of securities returned per request</para>
			/// </summary>
			ListOfSecuritiesReturnedPerRequest = (int)'4',
			/// <summary>
			/// <para>Reject security proposal</para>
			/// </summary>
			RejectSecurityProposal = (int)'5',
			/// <summary>
			/// <para>Can not match selection criteria</para>
			/// </summary>
			CannotMatchSelectionCriteria = (int)'6',
		}

		/// <summary>
		/// <para>Indicates whether or not message is being sent as a result of a subscription request or not.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Message is being sent unsolicited</para>
		/// <para>N = Message is being sent as a result of a prior request</para>
		/// </summary>
		public enum UnsolicitedIndicator
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Message is being sent as a result of a prior request</para>
			/// </summary>
			MessageIsBeingSentAsAResultOfAPriorRequest = (int)'N',
			/// <summary>
			/// <para>Message is being sent unsolicited</para>
			/// </summary>
			MessageIsBeingSentUnsolicited = (int)'Y',
		}

		/// <summary>
		/// <para>Identifies the trading status applicable to the transaction.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Opening Delay</para>
		/// <para>2 = Trading Halt</para>
		/// <para>3 = Resume</para>
		/// <para>4 = No Open/No Resume</para>
		/// <para>5 = Price Indication</para>
		/// <para>6 = Trading Range Indication</para>
		/// <para>7 = Market Imbalance Buy</para>
		/// <para>8 = Market Imbalance Sell</para>
		/// <para>9 = Market On Close Imbalance Buy</para>
		/// <para>10 = Market On Close Imbalance Sell</para>
		/// <para>12 = No Market Imbalance</para>
		/// <para>13 = No Market On Close Imbalance</para>
		/// <para>14 = ITS Pre-Opening</para>
		/// <para>15 = New Price Indication</para>
		/// <para>16 = Trade Dissemination Time</para>
		/// <para>17 = Ready to trade (start of session)</para>
		/// <para>18 = Not Available for trading (end of session)</para>
		/// <para>19 = Not Traded on this Market</para>
		/// <para>20 = Unknown or Invalid</para>
		/// </summary>
		public enum SecurityTradingStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Opening Delay</para>
			/// </summary>
			OpeningDelay,
			/// <summary>
			/// <para>Trading Halt</para>
			/// </summary>
			TradingHalt,
			/// <summary>
			/// <para>Resume</para>
			/// </summary>
			Resume,
			/// <summary>
			/// <para>No Open/No Resume</para>
			/// </summary>
			NoOpen,
			/// <summary>
			/// <para>Price Indication</para>
			/// </summary>
			PriceIndication,
			/// <summary>
			/// <para>Trading Range Indication</para>
			/// </summary>
			TradingRangeIndication,
			/// <summary>
			/// <para>Market Imbalance Buy</para>
			/// </summary>
			MarketImbalanceBuy,
			/// <summary>
			/// <para>Market Imbalance Sell</para>
			/// </summary>
			MarketImbalanceSell,
			/// <summary>
			/// <para>Market On Close Imbalance Buy</para>
			/// </summary>
			MarketOnCloseImbalanceBuy,
			/// <summary>
			/// <para>Market On Close Imbalance Sell</para>
			/// </summary>
			MarketOnCloseImbalanceSell,
			/// <summary>
			/// <para>No Market Imbalance</para>
			/// </summary>
			NoMarketImbalance,
			/// <summary>
			/// <para>No Market On Close Imbalance</para>
			/// </summary>
			NoMarketOnCloseImbalance,
			/// <summary>
			/// <para>ITS Pre-Opening</para>
			/// </summary>
			ITSPreOpening,
			/// <summary>
			/// <para>New Price Indication</para>
			/// </summary>
			NewPriceIndication,
			/// <summary>
			/// <para>Trade Dissemination Time</para>
			/// </summary>
			TradeDisseminationTime,
			/// <summary>
			/// <para>Ready to trade (start of session)</para>
			/// </summary>
			ReadyToTrade,
			/// <summary>
			/// <para>Not Available for trading (end of session)</para>
			/// </summary>
			NotAvailableForTrading,
			/// <summary>
			/// <para>Not Traded on this Market</para>
			/// </summary>
			NotTradedOnThisMarket,
			/// <summary>
			/// <para>Unknown or Invalid</para>
			/// </summary>
			UnknownOrInvalid,
		}

		/// <summary>
		/// <para>Denotes the reason for the Opening Delay or Trading Halt.</para>
		/// <para>Valid values:</para>
		/// <para>I = Order Imbalance</para>
		/// <para>X = Equipment Changeover</para>
		/// <para>P = News Pending</para>
		/// <para>D = News Dissemination</para>
		/// <para>E = Order Influx</para>
		/// <para>M = Additional Information</para>
		/// </summary>
		public enum HaltReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>News Dissemination</para>
			/// </summary>
			NewsDissemination = (int)'D',
			/// <summary>
			/// <para>Order Influx</para>
			/// </summary>
			OrderInflux = (int)'E',
			/// <summary>
			/// <para>Order Imbalance</para>
			/// </summary>
			OrderImbalance = (int)'I',
			/// <summary>
			/// <para>Additional Information</para>
			/// </summary>
			AdditionalInformation = (int)'M',
			/// <summary>
			/// <para>News Pending</para>
			/// </summary>
			NewsPending = (int)'P',
			/// <summary>
			/// <para>Equipment Changeover</para>
			/// </summary>
			EquipmentChangeover = (int)'X',
		}

		/// <summary>
		/// <para>Indicates whether or not the halt was due to Common Stock trading being halted.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Halt was due to common stock being halted</para>
		/// <para>N = Halt was not related to a halt of the common stock</para>
		/// </summary>
		public enum InViewOfCommon
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Halt was not related to a halt of the common stock</para>
			/// </summary>
			HaltWasNotRelatedToAHaltOfTheCommonStock = (int)'N',
			/// <summary>
			/// <para>Halt was due to common stock being halted</para>
			/// </summary>
			HaltWasDueToCommonStockBeingHalted = (int)'Y',
		}

		/// <summary>
		/// <para>Indicates whether or not the halt was due to the Related Security being halted.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Halt was due to related security being halted</para>
		/// <para>N = Halt was not related to a halt of the related security</para>
		/// </summary>
		public enum DueToRelated
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Halt was not related to a halt of the related security</para>
			/// </summary>
			NotRelatedToSecurityHalt = (int)'N',
			/// <summary>
			/// <para>Halt was due to related security being halted</para>
			/// </summary>
			RelatedToSecurityHalt = (int)'Y',
		}

		/// <summary>
		/// <para>Identifies the type of adjustment.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Cancel</para>
		/// <para>2 = Error</para>
		/// <para>3 = Correction</para>
		/// </summary>
		public enum Adjustment
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'1',
			/// <summary>
			/// <para>Error</para>
			/// </summary>
			Error = (int)'2',
			/// <summary>
			/// <para>Correction</para>
			/// </summary>
			Correction = (int)'3',
		}

		/// <summary>
		/// <para>Method of trading</para>
		/// <para>Valid values:</para>
		/// <para>1 = Electronic</para>
		/// <para>2 = Open Outcry</para>
		/// <para>3 = Two Party</para>
		/// </summary>
		public enum TradSesMethod
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Electronic</para>
			/// </summary>
			Electronic = (int)'1',
			/// <summary>
			/// <para>Open Outcry</para>
			/// </summary>
			OpenOutcry = (int)'2',
			/// <summary>
			/// <para>Two Party</para>
			/// </summary>
			TwoParty = (int)'3',
		}

		/// <summary>
		/// <para>Trading Session Mode</para>
		/// <para>Valid values:</para>
		/// <para>1 = Testing</para>
		/// <para>2 = Simulated</para>
		/// <para>3 = Production</para>
		/// </summary>
		public enum TradSesMode
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Testing</para>
			/// </summary>
			Testing = (int)'1',
			/// <summary>
			/// <para>Simulated</para>
			/// </summary>
			Simulated = (int)'2',
			/// <summary>
			/// <para>Production</para>
			/// </summary>
			Production = (int)'3',
		}

		/// <summary>
		/// <para>State of the trading session.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Halted</para>
		/// <para>2 = Open</para>
		/// <para>3 = Closed</para>
		/// <para>4 = Pre-Open</para>
		/// <para>5 = Pre-Close</para>
		/// </summary>
		public enum TradSesStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Halted</para>
			/// </summary>
			Halted = (int)'1',
			/// <summary>
			/// <para>Open</para>
			/// </summary>
			Open = (int)'2',
			/// <summary>
			/// <para>Closed</para>
			/// </summary>
			Closed = (int)'3',
			/// <summary>
			/// <para>Pre-Open</para>
			/// </summary>
			PreOpen = (int)'4',
			/// <summary>
			/// <para>Pre-Close</para>
			/// </summary>
			PreClose = (int)'5',
		}

		/// <summary>
		/// <para>Identifies the Bid Request message type.</para>
		/// <para>Valid values:</para>
		/// <para>N = New</para>
		/// <para>C = Cancel</para>
		/// </summary>
		public enum BidRequestTransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'C',
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'N',
		}

		/// <summary>
		/// <para>Code to represent whether value is net (inclusive of tax) or gross.</para>
		/// <para>Valid values:</para>
		/// <para>1 - Net</para>
		/// <para>2 - Gross</para>
		/// </summary>
		public enum NetGrossInd
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Net</para>
			/// </summary>
			Net = (int)'1',
			/// <summary>
			/// <para>Gross</para>
			/// </summary>
			Gross = (int)'2',
		}

		/// <summary>
		/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Regular</para>
		/// <para>1 = Cash</para>
		/// <para>2 = Next Day</para>
		/// <para>3 = T+2</para>
		/// <para>4 = T+3</para>
		/// <para>5 = T+4</para>
		/// <para>6 = Future</para>
		/// <para>7 = When Issued</para>
		/// <para>8 = Sellers Option</para>
		/// <para>9 = T+ 5</para>
		/// </summary>
		public enum SettlmntTyp
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Regular</para>
			/// </summary>
			Regular = (int)'0',
			/// <summary>
			/// <para>Cash</para>
			/// </summary>
			Cash = (int)'1',
			/// <summary>
			/// <para>Next Day</para>
			/// </summary>
			NextDay = (int)'2',
			/// <summary>
			/// <para>T+2</para>
			/// </summary>
			TPlus2 = (int)'3',
			/// <summary>
			/// <para>T+3</para>
			/// </summary>
			TPlus3 = (int)'4',
			/// <summary>
			/// <para>T+4</para>
			/// </summary>
			TPlus4 = (int)'5',
			/// <summary>
			/// <para>Future</para>
			/// </summary>
			Future = (int)'6',
			/// <summary>
			/// <para>When Issued</para>
			/// </summary>
			WhenAndIfIssued = (int)'7',
			/// <summary>
			/// <para>Sellers Option</para>
			/// </summary>
			SellersOption = (int)'8',
			/// <summary>
			/// <para>T+5</para>
			/// </summary>
			TPlus5 = (int)'9',
		}

		/// <summary>
		/// <para>Code to identify the type of liquidity indicator.</para>
		/// <para>Valid values:</para>
		/// <para>1 - 5day moving average</para>
		/// <para>2 - 20 day moving average</para>
		/// <para>3 - Normal Market Size</para>
		/// <para>4 - Other</para>
		/// </summary>
		public enum LiquidityIndType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>5 day moving average</para>
			/// </summary>
			FiveDayMovingAverage = (int)'1',
			/// <summary>
			/// <para>20 day moving average</para>
			/// </summary>
			TwentyDayMovingAverage = (int)'2',
			/// <summary>
			/// <para>Normal Market Size</para>
			/// </summary>
			NormalMarketSize = (int)'3',
			/// <summary>
			/// <para>Other</para>
			/// </summary>
			Other = (int)'4',
		}

		/// <summary>
		/// <para>Indicates whether or not to exchange for phsyical.</para>
		/// <para>Valid values:</para>
		/// <para>Y = True</para>
		/// <para>N = False</para>
		/// </summary>
		public enum ExchangeForPhysical
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>False</para>
			/// </summary>
			False = (int)'N',
			/// <summary>
			/// <para>True</para>
			/// </summary>
			True = (int)'Y',
		}

		/// <summary>
		/// <para>Code to identify the desired frequency of progress reports.</para>
		/// <para>Valid values:</para>
		/// <para>1 - BuySide explicitly requests status using StatusRequest (Default) The sell-side firm can however, send a DONE status List Status Response in an unsolicited fashion</para>
		/// <para>2 - SellSide periodically sends status using ListStatus. Period optionally specified in ProgressPeriod</para>
		/// <para>3 - Real-time execution reports (to be discouraged)</para>
		/// </summary>
		public enum ProgRptReqs
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>BuySide explicitly requests status using StatusRequest (Default) The sell-side firm can however, send a DONE status List Status Response in an unsolicited fashion</para>
			/// </summary>
			BuySideRequests = (int)'1',
			/// <summary>
			/// <para>SellSide periodically sends status using ListStatus. Period optionally specified in ProgressPeriod</para>
			/// </summary>
			SellSideSends = (int)'2',
			/// <summary>
			/// <para>Real-time execution reports (to be discouraged)</para>
			/// </summary>
			RealTimeExecutionReports = (int)'3',
		}

		/// <summary>
		/// <para>Code to represent whether value is net (inclusive of tax) or gross.</para>
		/// <para>Valid values:</para>
		/// <para>1 - Net</para>
		/// <para>2 - Gross</para>
		/// </summary>
		public enum IncTaxInd
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Net</para>
			/// </summary>
			Net = (int)'1',
			/// <summary>
			/// <para>Gross</para>
			/// </summary>
			Gross = (int)'2',
		}

		/// <summary>
		/// <para>Indicates request for forex accommodation trade to be executed along with security transaction.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Execute Forex after security trade</para>
		/// <para>N = Do not execute Forex after security trade</para>
		/// </summary>
		public enum ForexReq
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Do not execute Forex after security trade</para>
			/// </summary>
			DoNotExecuteForexAfterSecurityTrade = (int)'N',
			/// <summary>
			/// <para>Execute Forex after security trade</para>
			/// </summary>
			ExecuteForexAfterSecurityTrade = (int)'Y',
		}

		/// <summary>
		/// <para>Code to represent the type of trade.</para>
		/// <para>Valid values:</para>
		/// <para>R: Risk Trade</para>
		/// <para>G: VWAP Guarantee</para>
		/// <para>A: Agency</para>
		/// <para>J: Guaranteed Close</para>
		/// </summary>
		public enum TradeType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Agency</para>
			/// </summary>
			Agency = (int)'A',
			/// <summary>
			/// <para>VWAP Guarantee</para>
			/// </summary>
			VWAPGuarantee = (int)'G',
			/// <summary>
			/// <para>Guaranteed Close</para>
			/// </summary>
			GuaranteedClose = (int)'J',
			/// <summary>
			/// <para>Risk Trade</para>
			/// </summary>
			RiskTrade = (int)'R',
		}

		/// <summary>
		/// <para>Code to represent the basis price type.</para>
		/// <para>Valid values:</para>
		/// <para>2: Closing Price at morning session</para>
		/// <para>3: Closing Price</para>
		/// <para>4: Current price</para>
		/// <para>5: SQ</para>
		/// <para>6: VWAP through a day</para>
		/// <para>7: VWAP through a morning session</para>
		/// <para>8: VWAP through an afternoon session</para>
		/// <para>9: VWAP through a day except YORI</para>
		/// <para>A: VWAP through a morning session except YORI</para>
		/// <para>B: VWAP through an afternoon session except YORI</para>
		/// <para>C: Strike</para>
		/// <para>D: Open</para>
		/// <para>Z: Others</para>
		/// </summary>
		public enum BasisPxType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Closing Price at morning session</para>
			/// </summary>
			ClosingPriceAtMorningSession = (int)'2',
			/// <summary>
			/// <para>Closing Price</para>
			/// </summary>
			ClosingPrice = (int)'3',
			/// <summary>
			/// <para>Current price</para>
			/// </summary>
			CurrentPrice = (int)'4',
			/// <summary>
			/// <para>SQ</para>
			/// </summary>
			SQ = (int)'5',
			/// <summary>
			/// <para>VWAP through a day</para>
			/// </summary>
			VWAPThroughADay = (int)'6',
			/// <summary>
			/// <para>VWAP through a morning session</para>
			/// </summary>
			VWAPThroughAMorningSession = (int)'7',
			/// <summary>
			/// <para>VWAP through an afternoon session</para>
			/// </summary>
			VWAPThroughAnAfternoonSession = (int)'8',
			/// <summary>
			/// <para>VWAP through a day except YORI</para>
			/// </summary>
			VWAPThroughADayExcept = (int)'9',
			/// <summary>
			/// <para>VWAP through a morning session except YORI</para>
			/// </summary>
			VWAPThroughAMorningSessionExcept = (int)'A',
			/// <summary>
			/// <para>VWAP through an afternoon session except YORI</para>
			/// </summary>
			VWAPThroughAnAfternoonSessionExcept = (int)'B',
			/// <summary>
			/// <para>Strike</para>
			/// </summary>
			Strike = (int)'C',
			/// <summary>
			/// <para>Open</para>
			/// </summary>
			Open = (int)'D',
			/// <summary>
			/// <para>Others</para>
			/// </summary>
			Others = (int)'Z',
		}

		/// <summary>
		/// <para>Commission type</para>
		/// <para>Valid values:</para>
		/// <para>1 = per share</para>
		/// <para>2 = percentage</para>
		/// <para>3 = absolute</para>
		/// </summary>
		public enum CommType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>per share</para>
			/// </summary>
			PerUnit = (int)'1',
			/// <summary>
			/// <para>percentage</para>
			/// </summary>
			Percent = (int)'2',
			/// <summary>
			/// <para>absolute</para>
			/// </summary>
			Absolute = (int)'3',
		}

		/// <summary>
		/// <para>Code to represent the price type.</para>
		/// <para>Valid values:</para>
		/// <para>1 - Percentage</para>
		/// <para>2 - per share (e.g. cents per share)</para>
		/// <para>3 - Fixed Amount (absolute value)</para>
		/// </summary>
		public enum PriceType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Percentage</para>
			/// </summary>
			Percentage = (int)'1',
			/// <summary>
			/// <para>per share (e.g. cents per share)</para>
			/// </summary>
			PerUnit = (int)'2',
			/// <summary>
			/// <para>Fixed Amount (absolute value)</para>
			/// </summary>
			FixedAmount = (int)'3',
		}

		/// <summary>
		/// <para>Identifies transaction type</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Cancel</para>
		/// <para>2 = Correct</para>
		/// <para>3 = Status</para>
		/// </summary>
		public enum ExecTransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'1',
			/// <summary>
			/// <para>Correct</para>
			/// </summary>
			Correct = (int)'2',
			/// <summary>
			/// <para>Status</para>
			/// </summary>
			Status = (int)'3',
		}

		/// <summary>
		/// <para>Describes the specific ExecutionRpt (i.e. Pending Cancel) while OrdStatus will always identify the current order status (i.e. Partially Filled)</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Partial fill</para>
		/// <para>2 = Fill</para>
		/// <para>3 = Done for day</para>
		/// <para>4 = Canceled</para>
		/// <para>5 = Replace</para>
		/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request)</para>
		/// <para>7 = Stopped</para>
		/// <para>8 = Rejected</para>
		/// <para>9 = Suspended</para>
		/// <para>A = Pending New</para>
		/// <para>B = Calculated</para>
		/// <para>C = Expired</para>
		/// <para>D = Restated (ExecutionRpt sent unsolicited by sellside, with ExecRestatementReason set)</para>
		/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
		/// </summary>
		public enum ExecType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Partial fill</para>
			/// </summary>
			PartialFill = (int)'1',
			/// <summary>
			/// <para>Fill</para>
			/// </summary>
			Fill = (int)'2',
			/// <summary>
			/// <para>Done for day</para>
			/// </summary>
			DoneForDay = (int)'3',
			/// <summary>
			/// <para>Canceled</para>
			/// </summary>
			Canceled = (int)'4',
			/// <summary>
			/// <para>Replace</para>
			/// </summary>
			Replaced = (int)'5',
			/// <summary>
			/// <para>Pending Cancel (e.g. result of Order Cancel Request)</para>
			/// </summary>
			PendingCancel = (int)'6',
			/// <summary>
			/// <para>Stopped</para>
			/// </summary>
			Stopped = (int)'7',
			/// <summary>
			/// <para>Rejected</para>
			/// </summary>
			Rejected = (int)'8',
			/// <summary>
			/// <para>Suspended</para>
			/// </summary>
			Suspended = (int)'9',
			/// <summary>
			/// <para>Pending New</para>
			/// </summary>
			PendingNew = (int)'A',
			/// <summary>
			/// <para>Calculated</para>
			/// </summary>
			Calculated = (int)'B',
			/// <summary>
			/// <para>Expired</para>
			/// </summary>
			Expired = (int)'C',
			/// <summary>
			/// <para>Restated (ExecutionRpt sent unsolicited by sellside, with ExecRestatementReason set)</para>
			/// </summary>
			Restated = (int)'D',
			/// <summary>
			/// <para>Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
			/// </summary>
			PendingReplace = (int)'E',
		}

		/// <summary>
		/// <para>Identifies current status of order.</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Partially filled</para>
		/// <para>2 = Filled</para>
		/// <para>3 = Done for day</para>
		/// <para>4 = Canceled</para>
		/// <para>5 = Replaced</para>
		/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request) 7 = Stopped</para>
		/// <para>8 = Rejected</para>
		/// <para>9 = Suspended</para>
		/// <para>A = Pending New</para>
		/// <para>B = Calculated</para>
		/// <para>C = Expired</para>
		/// <para>D = Accepted for bidding</para>
		/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
		/// </summary>
		public enum OrdStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Partially filled</para>
			/// </summary>
			PartiallyFilled = (int)'1',
			/// <summary>
			/// <para>Filled</para>
			/// </summary>
			Filled = (int)'2',
			/// <summary>
			/// <para>Done for day</para>
			/// </summary>
			DoneForDay = (int)'3',
			/// <summary>
			/// <para>Canceled</para>
			/// </summary>
			Canceled = (int)'4',
			/// <summary>
			/// <para>Replaced</para>
			/// </summary>
			Replaced = (int)'5',
			/// <summary>
			/// <para>Pending Cancel (e.g. result of Order Cancel Request)</para>
			/// </summary>
			PendingCancel = (int)'6',
			/// <summary>
			/// <para>Stopped</para>
			/// </summary>
			Stopped = (int)'7',
			/// <summary>
			/// <para>Rejected</para>
			/// </summary>
			Rejected = (int)'8',
			/// <summary>
			/// <para>Suspended</para>
			/// </summary>
			Suspended = (int)'9',
			/// <summary>
			/// <para>Pending New</para>
			/// </summary>
			PendingNew = (int)'A',
			/// <summary>
			/// <para>Calculated</para>
			/// </summary>
			Calculated = (int)'B',
			/// <summary>
			/// <para>Expired</para>
			/// </summary>
			Expired = (int)'C',
			/// <summary>
			/// <para>Accepted for bidding</para>
			/// </summary>
			AcceptedForBidding = (int)'D',
			/// <summary>
			/// <para>Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
			/// </summary>
			PendingReplace = (int)'E',
		}

		/// <summary>
		/// <para>Code to identify reason for order rejection.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Broker option</para>
		/// <para>1 = Unknown symbol</para>
		/// <para>2 = Exchange closed</para>
		/// <para>3 = Order exceeds limit</para>
		/// <para>4 = Too late to enter</para>
		/// <para>5 = Unknown Order</para>
		/// <para>6 = Duplicate Order (e.g. dupe ClOrdID)</para>
		/// <para>7 = Duplicate of a verbally communicated order</para>
		/// <para>8 = Stale Order</para>
		/// </summary>
		public enum OrdRejReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Broker option</para>
			/// </summary>
			BrokerCredit = (int)'0',
			/// <summary>
			/// <para>Unknown symbol</para>
			/// </summary>
			UnknownSymbol = (int)'1',
			/// <summary>
			/// <para>Exchange closed</para>
			/// </summary>
			ExchangeClosed = (int)'2',
			/// <summary>
			/// <para>Order exceeds limit</para>
			/// </summary>
			OrderExceedsLimit = (int)'3',
			/// <summary>
			/// <para>Too late to enter</para>
			/// </summary>
			TooLateToEnter = (int)'4',
			/// <summary>
			/// <para>Unknown Order</para>
			/// </summary>
			UnknownOrder = (int)'5',
			/// <summary>
			/// <para>Duplicate Order (e.g. dupe ClOrdID)</para>
			/// </summary>
			DuplicateOrder = (int)'6',
			/// <summary>
			/// <para>Duplicate of a verbally communicated order</para>
			/// </summary>
			DuplicateOfAVerballyCommunicatedOrder = (int)'7',
			/// <summary>
			/// <para>Stale Order</para>
			/// </summary>
			StaleOrder = (int)'8',
		}

		/// <summary>
		/// <para>Code to identify reason for an ExecutionRpt message sent with ExecType=Restated or used when communicating an unsolicited cancel.</para>
		/// <para>Valid values:</para>
		/// <para>0 = GT Corporate action</para>
		/// <para>1 = GT renewal / restatement (no corporate action)</para>
		/// <para>2 = Verbal change</para>
		/// <para>3 = Repricing of order</para>
		/// <para>4 = Broker option</para>
		/// <para>5 = Partial decline of OrderQty (e.g. exchange-initiated partial cancel)</para>
		/// </summary>
		public enum ExecRestatementReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>GT Corporate action</para>
			/// </summary>
			GTCorporateAction = (int)'0',
			/// <summary>
			/// <para>GT renewal / restatement (no corporate action)</para>
			/// </summary>
			GTRenewal = (int)'1',
			/// <summary>
			/// <para>Verbal change</para>
			/// </summary>
			VerbalChange = (int)'2',
			/// <summary>
			/// <para>Repricing of order</para>
			/// </summary>
			RepricingOfOrder = (int)'3',
			/// <summary>
			/// <para>Broker option</para>
			/// </summary>
			BrokerOption = (int)'4',
			/// <summary>
			/// <para>Partial decline of OrderQty (e.g. exchange-initiated partial cancel)</para>
			/// </summary>
			PartialDeclineOfOrderQty = (int)'5',
		}

		/// <summary>
		/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Related to displayed price</para>
		/// <para>1 = Related to market price</para>
		/// <para>2 = Related to primary price</para>
		/// <para>3 = Related to local primary price</para>
		/// <para>4 = Related to midpoint price</para>
		/// <para>5 = Related to last trade price</para>
		/// </summary>
		public enum DiscretionInst
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Related to displayed price</para>
			/// </summary>
			RelatedToDisplayedPrice = (int)'0',
			/// <summary>
			/// <para>Related to market price</para>
			/// </summary>
			RelatedToMarketPrice = (int)'1',
			/// <summary>
			/// <para>Related to primary price</para>
			/// </summary>
			RelatedToPrimaryPrice = (int)'2',
			/// <summary>
			/// <para>Related to local primary price</para>
			/// </summary>
			RelatedToLocalPrimaryPrice = (int)'3',
			/// <summary>
			/// <para>Related to midpoint price</para>
			/// </summary>
			RelatedToMidpointPrice = (int)'4',
			/// <summary>
			/// <para>Related to last trade price</para>
			/// </summary>
			RelatedToLastTradePrice = (int)'5',
		}

		/// <summary>
		/// <para>Indicates whether or not the order was solicited.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Was solcitied</para>
		/// <para>N = Was not solicited</para>
		/// </summary>
		public enum SolicitedFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Was not solicited</para>
			/// </summary>
			WasNotSolicited = (int)'N',
			/// <summary>
			/// <para>Was solcitied</para>
			/// </summary>
			WasSolicited = (int)'Y',
		}

		/// <summary>
		/// <para>Note that the name of this field is changing to 'OrderCapacity' as Rule80A is a very US market-specific term. Other world markets need to convey similar information, however, often a subset of the US values. . See the 'Rule80A (aka OrderCapacity) Usage by Market' appendix for market-specific usage of this field.Valid values:</para>
		/// <para>A = Agency single order</para>
		/// <para>B = Short exempt transaction (refer to A type)</para>
		/// <para>C = Program Order, non-index arb, for Member firm/org</para>
		/// <para>D = Program Order, index arb, for Member firm/org</para>
		/// <para>E = Registered Equity Market Maker trades</para>
		/// <para>F = Short exempt transaction (refer to W type)</para>
		/// <para>H = Short exempt transaction (refer to I type)</para>
		/// <para>I = Individual Investor, single order</para>
		/// <para>J = Program Order, index arb, for individual customer</para>
		/// <para>K = Program Order, non-index arb, for individual customer</para>
		/// <para>L = Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
		/// <para>M = Program Order, index arb, for other member</para>
		/// <para>N = Program Order, non-index arb, for other member</para>
		/// <para>O = Competing dealer trades</para>
		/// <para>P = Principal</para>
		/// <para>R = Competing dealer trades</para>
		/// <para>S = Specialist trades</para>
		/// <para>T = Competing dealer trades</para>
		/// <para>U = Program Order, index arb, for other agency</para>
		/// <para>W = All other orders as agent for other member</para>
		/// <para>X = Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
		/// <para>Y = Program Order, non-index arb, for other agency</para>
		/// <para>Z = Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
		/// </summary>
		public enum Rule80AAkaOrderCapacity
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Agency single order</para>
			/// </summary>
			AgencySingleOrder = (int)'A',
			/// <summary>
			/// <para>Short exempt transaction (refer to A type)</para>
			/// </summary>
			ShortExemptTransactionAType = (int)'B',
			/// <summary>
			/// <para>Program Order, non-index arb, for Member firm/org</para>
			/// </summary>
			ProprietaryNonAlgo = (int)'C',
			/// <summary>
			/// <para>Program Order, index arb, for Member firm/org</para>
			/// </summary>
			ProgramOrderMember = (int)'D',
			/// <summary>
			/// <para>Registered Equity Market Maker trades</para>
			/// </summary>
			ShortExemptTransactionForPrincipal = (int)'E',
			/// <summary>
			/// <para>Short exempt transaction (refer to W type)</para>
			/// </summary>
			ShortExemptTransactionWType = (int)'F',
			/// <summary>
			/// <para>Short exempt transaction (refer to I type)</para>
			/// </summary>
			ShortExemptTransactionIType = (int)'H',
			/// <summary>
			/// <para>Individual Investor, single order</para>
			/// </summary>
			IndividualInvestor = (int)'I',
			/// <summary>
			/// <para>Program Order, index arb, for individual customer</para>
			/// </summary>
			ProprietaryAlgo = (int)'J',
			/// <summary>
			/// <para>Program Order, non-index arb, for individual customer</para>
			/// </summary>
			AgencyAlgo = (int)'K',
			/// <summary>
			/// <para>Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
			/// </summary>
			ShortExemptTransactionMemberAffliated = (int)'L',
			/// <summary>
			/// <para>Program Order, index arb, for other member</para>
			/// </summary>
			ProgramOrderOtherMember = (int)'M',
			/// <summary>
			/// <para>Program Order, non-index arb, for other member</para>
			/// </summary>
			AgentForOtherMember = (int)'N',
			/// <summary>
			/// <para>Competing dealer trades</para>
			/// </summary>
			ProprietaryTransactionAffiliated = (int)'O',
			/// <summary>
			/// <para>Principal</para>
			/// </summary>
			Principal = (int)'P',
			/// <summary>
			/// <para>Competing dealer trades</para>
			/// </summary>
			TransactionNonMember = (int)'R',
			/// <summary>
			/// <para>Specialist trades</para>
			/// </summary>
			SpecialistTrades = (int)'S',
			/// <summary>
			/// <para>Competing dealer trades</para>
			/// </summary>
			TransactionUnaffiliatedMember = (int)'T',
			/// <summary>
			/// <para>Program Order, index arb, for other agency</para>
			/// </summary>
			AgencyIndexArb = (int)'U',
			/// <summary>
			/// <para>All other orders as agent for other member</para>
			/// </summary>
			AllOtherOrdersAsAgentForOtherMember = (int)'W',
			/// <summary>
			/// <para>Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
			/// </summary>
			ShortExemptTransactionMemberNotAffliated = (int)'X',
			/// <summary>
			/// <para>Program Order, non-index arb, for other agency</para>
			/// </summary>
			AgencyNonAlgo = (int)'Y',
			/// <summary>
			/// <para>Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
			/// </summary>
			ShortExemptTransactionNonMember = (int)'Z',
		}

		/// <summary>
		/// <para>Broker capacity in order execution</para>
		/// <para>Valid values:</para>
		/// <para>1 = Agent</para>
		/// <para>2 = Cross as agent</para>
		/// <para>3 = Cross as principal</para>
		/// <para>4 = Principal</para>
		/// </summary>
		public enum LastCapacity
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Agent</para>
			/// </summary>
			Agent = (int)'1',
			/// <summary>
			/// <para>Cross as agent</para>
			/// </summary>
			CrossAsAgent = (int)'2',
			/// <summary>
			/// <para>Cross as principal</para>
			/// </summary>
			CrossAsPrincipal = (int)'3',
			/// <summary>
			/// <para>Principal</para>
			/// </summary>
			Principal = (int)'4',
		}

		/// <summary>
		/// <para>Code to identify whether to book out executions on a part-filled GT order on the day of execution or to accumulate.</para>
		/// <para>Valid values:</para>
		/// <para>0 = book out all trades on day of execution</para>
		/// <para>1 = accumulate executions until order is filled or expires</para>
		/// <para>2 = accumulate until verbally notified otherwise</para>
		/// </summary>
		public enum GTBookingInst
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>book out all trades on day of execution</para>
			/// </summary>
			BookOutAllTradesOnDayOfExecution = (int)'0',
			/// <summary>
			/// <para>accumulate executions until order is filled or expires</para>
			/// </summary>
			AccumulateUntilFilledOrExpired = (int)'1',
			/// <summary>
			/// <para>accumulate until verbally notified otherwise</para>
			/// </summary>
			AccumulateUntilVerballlyNotifiedOtherwise = (int)'2',
		}

		/// <summary>
		/// <para>Identifies party of trade responsible for exchange reporting.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Indicates that party receiving message must report trade</para>
		/// <para>N = Indicates that party sending message will report trade</para>
		/// </summary>
		public enum ReportToExch
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Indicates that party sending message will report trade</para>
			/// </summary>
			SenderReports = (int)'N',
			/// <summary>
			/// <para>Indicates that party receiving message must report trade</para>
			/// </summary>
			ReceiverReports = (int)'Y',
		}

		/// <summary>
		/// <para>Instructions for order handling on Broker trading floor</para>
		/// <para>Valid values:</para>
		/// <para>1 = Automated execution order, private, no Broker intervention</para>
		/// <para>2 = Automated execution order, public, Broker intervention OK</para>
		/// <para>3 = Manual order, best execution</para>
		/// </summary>
		public enum HandlInst
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Automated execution order, private, no Broker intervention</para>
			/// </summary>
			AutomatedExecutionNoIntervention = (int)'1',
			/// <summary>
			/// <para>Automated execution order, public, Broker intervention OK</para>
			/// </summary>
			AutomatedExecutionInterventionOK = (int)'2',
			/// <summary>
			/// <para>Manual order, best execution</para>
			/// </summary>
			ManualOrder = (int)'3',
		}

		/// <summary>
		/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
		/// <para>Valid Values:</para>
		/// <para>O=Open</para>
		/// <para>C=Close</para>
		/// </summary>
		public enum OpenClose
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Close</para>
			/// </summary>
			Close = (int)'C',
			/// <summary>
			/// <para>Open</para>
			/// </summary>
			Open = (int)'O',
		}

		/// <summary>
		/// <para>Used to indicate what an Execution Report represents (e.g. used with multi-leg securiteis, such as option strategies, spreads, etc.).</para>
		/// <para>Valid Values:</para>
		/// <para>1 - Single Security (default if not specified)</para>
		/// <para>2 - Individual leg of a multi-leg security</para>
		/// <para>3 - Multi-leg security</para>
		/// </summary>
		public enum MultiLegReportingType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Single Security (default if not specified)</para>
			/// </summary>
			SingleSecurity = (int)'1',
			/// <summary>
			/// <para>Individual leg of a multi-leg security</para>
			/// </summary>
			IndividualLegOfAMultiLegSecurity = (int)'2',
			/// <summary>
			/// <para>Multi-leg security</para>
			/// </summary>
			MultiLegSecurity = (int)'3',
		}

		/// <summary>
		/// <para>Identifies the type of request that a Cancel Reject is in response to.</para>
		/// <para>Valid values:</para>
		/// <para>1 - Order Cancel Request</para>
		/// <para>2 - Order Cancel/Replace Request</para>
		/// </summary>
		public enum CxlRejResponseTo
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Order Cancel Request</para>
			/// </summary>
			OrderCancelRequest = (int)'1',
			/// <summary>
			/// <para>Order Cancel/Replace Request</para>
			/// </summary>
			OrderCancel = (int)'2',
		}

		/// <summary>
		/// <para>Code to identify reason for cancel rejection.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Too late to cancel</para>
		/// <para>1 = Unknown order</para>
		/// <para>2 = Broker Option</para>
		/// <para>3 = Order already in Pending Cancel or Pending Replace status</para>
		/// </summary>
		public enum CxlRejReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Too late to cancel</para>
			/// </summary>
			TooLateToCancel = (int)'0',
			/// <summary>
			/// <para>Unknown order</para>
			/// </summary>
			UnknownOrder = (int)'1',
			/// <summary>
			/// <para>Broker Option</para>
			/// </summary>
			BrokerCredit = (int)'2',
			/// <summary>
			/// <para>Order already in Pending Cancel or Pending Replace status</para>
			/// </summary>
			OrderAlreadyInPendingStatus = (int)'3',
		}

		/// <summary>
		/// <para>Processing code for sub-account. Absence of this field in AllocAccount / AllocPrice/AllocShares / ProcessCode instance indicates regular trade.</para>
		/// <para>Valid values:</para>
		/// <para>0 = regular</para>
		/// <para>1 = soft dollar</para>
		/// <para>2 = step-in</para>
		/// <para>3 = step-out</para>
		/// <para>4 = soft-dollar step-in</para>
		/// <para>5 = soft-dollar step-out</para>
		/// <para>6 = plan sponsor</para>
		/// </summary>
		public enum ProcessCode
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>regular</para>
			/// </summary>
			Regular = (int)'0',
			/// <summary>
			/// <para>soft dollar</para>
			/// </summary>
			SoftDollar = (int)'1',
			/// <summary>
			/// <para>step-in</para>
			/// </summary>
			StepIn = (int)'2',
			/// <summary>
			/// <para>step-out</para>
			/// </summary>
			StepOut = (int)'3',
			/// <summary>
			/// <para>soft-dollar step-in</para>
			/// </summary>
			SoftDollarStepIn = (int)'4',
			/// <summary>
			/// <para>soft-dollar step-out</para>
			/// </summary>
			SoftDollarStepOut = (int)'5',
			/// <summary>
			/// <para>plan sponsor</para>
			/// </summary>
			PlanSponsor = (int)'6',
		}

		/// <summary>
		/// <para>Indicates whether the broker is to locate the stock in conjunction with a short sell order.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Indicates the broker is responsible for locating the stock</para>
		/// <para>N = Indicates the broker is not required to locate</para>
		/// </summary>
		public enum LocateReqd
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Indicates the broker is not required to locate</para>
			/// </summary>
			No = (int)'N',
			/// <summary>
			/// <para>Indicates the broker is responsible for locating the stock</para>
			/// </summary>
			Yes = (int)'Y',
		}

		/// <summary>
		/// <para>Used for options</para>
		/// <para>Valid values:</para>
		/// <para>0 = Covered</para>
		/// <para>1 = Uncovered</para>
		/// </summary>
		public enum CoveredOrUncovered
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Covered</para>
			/// </summary>
			Covered = (int)'0',
			/// <summary>
			/// <para>Uncovered</para>
			/// </summary>
			Uncovered = (int)'1',
		}

		/// <summary>
		/// <para>Used for options when delivering the order to an execution system/exchange to specify if the order is for a customer or the firm placing the order itself.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Customer</para>
		/// <para>1 = Firm</para>
		/// </summary>
		public enum CustomerOrFirm
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Customer</para>
			/// </summary>
			Customer = (int)'0',
			/// <summary>
			/// <para>Firm</para>
			/// </summary>
			Firm = (int)'1',
		}

		/// <summary>
		/// <para>Reason for execution rejection.</para>
		/// <para>Valid values:</para>
		/// <para>A = Unknown symbol</para>
		/// <para>B = Wrong side</para>
		/// <para>C = Quantity exceeds order</para>
		/// <para>D = No matching order</para>
		/// <para>E = Price exceeds limit</para>
		/// <para>Z = Other</para>
		/// </summary>
		public enum DKReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Unknown symbol</para>
			/// </summary>
			UnknownSymbol = (int)'A',
			/// <summary>
			/// <para>Wrong side</para>
			/// </summary>
			WrongSide = (int)'B',
			/// <summary>
			/// <para>Quantity exceeds order</para>
			/// </summary>
			QuantityExceedsOrder = (int)'C',
			/// <summary>
			/// <para>No matching order</para>
			/// </summary>
			NoMatchingOrder = (int)'D',
			/// <summary>
			/// <para>Price exceeds limit</para>
			/// </summary>
			PriceExceedsLimit = (int)'E',
			/// <summary>
			/// <para>Other</para>
			/// </summary>
			Other = (int)'Z',
		}

		/// <summary>
		/// <para>Identifies the type of ListExecInst.</para>
		/// <para>Valid values:</para>
		/// <para>1 - Immediate</para>
		/// <para>2 - Wait for Execute Instruction (e.g. a List Execute message or phone call before proceeding with execution of the list)</para>
		/// </summary>
		public enum ListExecInstType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Immediate</para>
			/// </summary>
			Immediate = (int)'1',
			/// <summary>
			/// <para>Wait for Execute Instruction (e.g. a List Execute message or phone call before proceeding with execution of the list)</para>
			/// </summary>
			WaitForInstruction = (int)'2',
		}

		/// <summary>
		/// <para>Indicates mode used for Settlement Instructions</para>
		/// <para>Valid values:</para>
		/// <para>0 = Default</para>
		/// <para>1 = Standing Instructions Provided</para>
		/// <para>2 = Specific AllocationAccount Overriding</para>
		/// <para>3 = Specific AllocationAccount Standing</para>
		/// </summary>
		public enum SettlInstMode
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Default</para>
			/// </summary>
			Default = (int)'0',
			/// <summary>
			/// <para>Standing Instructions Provided</para>
			/// </summary>
			StandingInstructionsProvided = (int)'1',
			/// <summary>
			/// <para>Specific AllocationAccount Overriding</para>
			/// </summary>
			SpecificAllocationAccountOverriding = (int)'2',
			/// <summary>
			/// <para>Specific AllocationAccount Standing</para>
			/// </summary>
			SpecificAllocationAccountStanding = (int)'3',
		}

		/// <summary>
		/// <para>Identifies allocation transaction type</para>
		/// <para>Valid values:</para>
		/// <para>0 = New</para>
		/// <para>1 = Replace</para>
		/// <para>2 = Cancel</para>
		/// <para>3 = Preliminary (without MiscFees and NetMoney)</para>
		/// <para>4 = Calculated (includes MiscFees and NetMoney)</para>
		/// <para>5 = Calculated without Preliminary (sent unsolicited by broker, includes MiscFees and NetMoney)</para>
		/// </summary>
		public enum AllocTransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'0',
			/// <summary>
			/// <para>Replace</para>
			/// </summary>
			Replace = (int)'1',
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'2',
			/// <summary>
			/// <para>Preliminary (without MiscFees and NetMoney)</para>
			/// </summary>
			Preliminary = (int)'3',
			/// <summary>
			/// <para>Calculated (includes MiscFees and NetMoney)</para>
			/// </summary>
			Calculated = (int)'4',
			/// <summary>
			/// <para>Calculated without Preliminary (sent unsolicited by broker, includes MiscFees and NetMoney)</para>
			/// </summary>
			CalculatedWithoutPreliminary = (int)'5',
		}

		/// <summary>
		/// <para>Identifies the type of Allocation linkage when AllocLinkID is used.</para>
		/// <para>Valid values:</para>
		/// <para>0 = F/X Netting</para>
		/// <para>1 = F/X Swap</para>
		/// </summary>
		public enum AllocLinkType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>F/X Netting</para>
			/// </summary>
			FXNetting = (int)'0',
			/// <summary>
			/// <para>F/X Swap</para>
			/// </summary>
			FXSwap = (int)'1',
		}

		/// <summary>
		/// <para>Indicates whether or not details should be communicated to BrokerOfCredit (i.e. step-in broker).</para>
		/// <para>Valid values:</para>
		/// <para>Y = Details should be communicated</para>
		/// <para>N = Details should not be communicated</para>
		/// </summary>
		public enum NotifyBrokerOfCredit
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Details should not be communicated</para>
			/// </summary>
			DetailsShouldNotBeCommunicated = (int)'N',
			/// <summary>
			/// <para>Details should be communicated</para>
			/// </summary>
			DetailsShouldBeCommunicated = (int)'Y',
		}

		/// <summary>
		/// <para>Indicates how the receiver (i.e. third party) of Allocation message should handle/process the account details.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Match</para>
		/// <para>2 = Forward</para>
		/// <para>3 = Forward and Match</para>
		/// </summary>
		public enum AllocHandlInst
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Match</para>
			/// </summary>
			Match = (int)'1',
			/// <summary>
			/// <para>Forward</para>
			/// </summary>
			Forward = (int)'2',
			/// <summary>
			/// <para>Forward and Match</para>
			/// </summary>
			ForwardAndMatch = (int)'3',
		}

		/// <summary>
		/// <para>Indicates type of miscellaneous fee.</para>
		/// <para>Valid values:</para>
		/// <para>1 = Regulatory (e.g. SEC)</para>
		/// <para>2 = Tax</para>
		/// <para>3 = Local Commission</para>
		/// <para>4 = Exchange Fees</para>
		/// <para>5 = Stamp</para>
		/// <para>6 = Levy</para>
		/// <para>7 = Other</para>
		/// <para>8 = Markup</para>
		/// <para>9 = Consumption Tax</para>
		/// </summary>
		public enum MiscFeeType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Regulatory (e.g. SEC)</para>
			/// </summary>
			Regulatory = (int)'1',
			/// <summary>
			/// <para>Tax</para>
			/// </summary>
			Tax = (int)'2',
			/// <summary>
			/// <para>Local Commission</para>
			/// </summary>
			LocalCommission = (int)'3',
			/// <summary>
			/// <para>Exchange Fees</para>
			/// </summary>
			ExchangeFees = (int)'4',
			/// <summary>
			/// <para>Stamp</para>
			/// </summary>
			Stamp = (int)'5',
			/// <summary>
			/// <para>Levy</para>
			/// </summary>
			Levy = (int)'6',
			/// <summary>
			/// <para>Other</para>
			/// </summary>
			Other = (int)'7',
			/// <summary>
			/// <para>Markup</para>
			/// </summary>
			Markup = (int)'8',
			/// <summary>
			/// <para>Consumption Tax</para>
			/// </summary>
			ConsumptionTax = (int)'9',
		}

		/// <summary>
		/// <para>Identifies status of allocation.</para>
		/// <para>Valid values:</para>
		/// <para>0 = accepted (successfully processed)</para>
		/// <para>1 = rejected</para>
		/// <para>2 = partial accept</para>
		/// <para>3 = received (received, not yet processed)</para>
		/// </summary>
		public enum AllocStatus
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>accepted (successfully processed)</para>
			/// </summary>
			Accepted = (int)'0',
			/// <summary>
			/// <para>rejected</para>
			/// </summary>
			BlockLevelReject = (int)'1',
			/// <summary>
			/// <para>partial accept</para>
			/// </summary>
			AccountLevelReject = (int)'2',
			/// <summary>
			/// <para>received (received, not yet processed)</para>
			/// </summary>
			Received = (int)'3',
		}

		/// <summary>
		/// <para>Identifies reason for rejection.</para>
		/// <para>Valid values:</para>
		/// <para>0 = unknown account(s)</para>
		/// <para>1 = incorrect quantity</para>
		/// <para>2 = incorrect average price</para>
		/// <para>3 = unknown executing broker mnemonic</para>
		/// <para>4 = commission difference</para>
		/// <para>5 = unknown OrderID</para>
		/// <para>6 = unknown ListID</para>
		/// <para>7 = other</para>
		/// </summary>
		public enum AllocRejCode
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>unknown account(s)</para>
			/// </summary>
			UnknownAccount = (int)'0',
			/// <summary>
			/// <para>incorrect quantity</para>
			/// </summary>
			IncorrectQuantity = (int)'1',
			/// <summary>
			/// <para>incorrect average price</para>
			/// </summary>
			IncorrectAveragegPrice = (int)'2',
			/// <summary>
			/// <para>unknown executing broker mnemonic</para>
			/// </summary>
			UnknownExecutingBrokerMnemonic = (int)'3',
			/// <summary>
			/// <para>commission difference</para>
			/// </summary>
			CommissionDifference = (int)'4',
			/// <summary>
			/// <para>unknown OrderID</para>
			/// </summary>
			UnknownOrderID = (int)'5',
			/// <summary>
			/// <para>unknown ListID</para>
			/// </summary>
			UnknownListID = (int)'6',
			/// <summary>
			/// <para>other</para>
			/// </summary>
			OtherSeeText = (int)'7',
		}

		/// <summary>
		/// <para>Settlement Instructions message transaction type</para>
		/// <para>Valid values:</para>
		/// <para>N = New</para>
		/// <para>C = Cancel</para>
		/// <para>R = Replace</para>
		/// </summary>
		public enum SettlInstTransType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Cancel</para>
			/// </summary>
			Cancel = (int)'C',
			/// <summary>
			/// <para>New</para>
			/// </summary>
			New = (int)'N',
			/// <summary>
			/// <para>Replace</para>
			/// </summary>
			Replace = (int)'R',
		}

		/// <summary>
		/// <para>Indicates source of Settlement Instructions</para>
		/// <para>Valid values:</para>
		/// <para>1 = Broker's Instructions</para>
		/// <para>2 = Institution's Instructions</para>
		/// </summary>
		public enum SettlInstSource
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Brokers Instructions</para>
			/// </summary>
			BrokerCredit = (int)'1',
			/// <summary>
			/// <para>Institutions Instructions</para>
			/// </summary>
			Institution = (int)'2',
		}

		/// <summary>
		/// <para>Identifies Settlement Depository or Country Code (ISITC spec)</para>
		/// <para>Valid values:</para>
		/// <para>CED = CEDEL</para>
		/// <para>DTC = Depository Trust Company</para>
		/// <para>EUR = Euroclear</para>
		/// <para>FED = Federal Book Entry</para>
		/// <para>PNY= Physical</para>
		/// <para>PTC = Participant Trust Company</para>
		/// <para>ISO Country Code = Local Market Settle Location</para>
		/// </summary>
		public enum SettlLocation
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>CEDEL</para>
			/// </summary>
			CEDEL,
			/// <summary>
			/// <para>Depository Trust Company</para>
			/// </summary>
			DepositoryTrustCompany,
			/// <summary>
			/// <para>Euroclear</para>
			/// </summary>
			EuroClear,
			/// <summary>
			/// <para>Federal Book Entry</para>
			/// </summary>
			FederalBookEntry,
			/// <summary>
			/// <para>Local Market Settle Location</para>
			/// </summary>
			LocalMarketSettleLocation,
			/// <summary>
			/// <para>Physical</para>
			/// </summary>
			Physical,
			/// <summary>
			/// <para>Participant Trust Company</para>
			/// </summary>
			ParticipantTrustCompany,
		}

		/// <summary>
		/// <para>Identifies the Standing Instruction database used</para>
		/// <para>Valid values:</para>
		/// <para>0 = Other</para>
		/// <para>1 = DTC SID</para>
		/// <para>2 = Thomson ALERT</para>
		/// <para>3 = A Global Custodian (StandInstDbName must be provided)</para>
		/// </summary>
		public enum StandInstDbType
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Other</para>
			/// </summary>
			Other = (int)'0',
			/// <summary>
			/// <para>DTC SID</para>
			/// </summary>
			DTCSID = (int)'1',
			/// <summary>
			/// <para>Thomson ALERT</para>
			/// </summary>
			ThomsonALERT = (int)'2',
			/// <summary>
			/// <para>A Global Custodian (StandInstDbName must be provided)</para>
			/// </summary>
			AGlobalCustodian = (int)'3',
		}

		/// <summary>
		/// <para>Code to identify reason for a Business Message Reject message.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Other</para>
		/// <para>1 = Unkown ID</para>
		/// <para>2 = Unknown Security</para>
		/// <para>3 = Unsupported Message Type</para>
		/// <para>4 = Application not available</para>
		/// <para>5 = Conditionally Required Field Missing</para>
		/// </summary>
		public enum BusinessRejectReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Other</para>
			/// </summary>
			Other = (int)'0',
			/// <summary>
			/// <para>Unkown ID</para>
			/// </summary>
			UnknownID = (int)'1',
			/// <summary>
			/// <para>Unknown Security</para>
			/// </summary>
			UnknownSecurity = (int)'2',
			/// <summary>
			/// <para>Unsupported Message Type</para>
			/// </summary>
			UnsupportedMessageType = (int)'3',
			/// <summary>
			/// <para>Application not available</para>
			/// </summary>
			ApplicationNotAvailable = (int)'4',
			/// <summary>
			/// <para>Conditionally Required Field Missing</para>
			/// </summary>
			ConditionallyRequiredFieldMissing = (int)'5',
		}

		/// <summary>
		/// <para>Code to identify reason for a session-level Reject message.</para>
		/// <para>Valid values:</para>
		/// <para>0 = Invalid tag number</para>
		/// <para>1 = Required tag missing</para>
		/// <para>2 = Tag not defined for this message type</para>
		/// <para>3 = Undefined Tag</para>
		/// <para>4 = Tag specified without a value</para>
		/// <para>5 = Value is incorrect (out of range) for this tag</para>
		/// <para>6 = Incorrect data format for value</para>
		/// <para>7 = Decryption problem</para>
		/// <para>8 = Signature problem</para>
		/// <para>9 = CompID problem</para>
		/// <para>10 = SendingTime accuracy problem</para>
		/// <para>11 = Invalid MsgType</para>
		/// </summary>
		public enum SessionRejectReason
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Invalid tag number</para>
			/// </summary>
			InvalidTagNumber,
			/// <summary>
			/// <para>Required tag missing</para>
			/// </summary>
			RequiredTagMissing,
			/// <summary>
			/// <para>Tag not defined for this message type</para>
			/// </summary>
			TagNotDefinedForThisMessageType,
			/// <summary>
			/// <para>Undefined Tag</para>
			/// </summary>
			UndefinedTag,
			/// <summary>
			/// <para>Tag specified without a value</para>
			/// </summary>
			TagSpecifiedWithoutAValue,
			/// <summary>
			/// <para>Value is incorrect (out of range) for this tag</para>
			/// </summary>
			ValueIsIncorrect,
			/// <summary>
			/// <para>Incorrect data format for value</para>
			/// </summary>
			IncorrectDataFormatForValue,
			/// <summary>
			/// <para>Decryption problem</para>
			/// </summary>
			DecryptionProblem,
			/// <summary>
			/// <para>Signature problem</para>
			/// </summary>
			SignatureProblem,
			/// <summary>
			/// <para>CompID problem</para>
			/// </summary>
			CompIDProblem,
			/// <summary>
			/// <para>SendingTime accuracy problem</para>
			/// </summary>
			SendingTimeAccuracyProblem,
			/// <summary>
			/// <para>Invalid MsgType</para>
			/// </summary>
			InvalidMsgType,
		}

		/// <summary>
		/// <para>Indicates that the Sequence Reset message is replacing administrative or application messages which will not be resent.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Gap Fill message, MsgSeqNum field valid</para>
		/// <para>N = Sequence Reset, ignore MsgSeqNum</para>
		/// </summary>
		public enum GapFillFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Sequence Reset, ignore MsgSeqNum</para>
			/// </summary>
			SequenceReset = (int)'N',
			/// <summary>
			/// <para>Gap Fill message, MsgSeqNum field valid</para>
			/// </summary>
			GapFillMessage = (int)'Y',
		}

		/// <summary>
		/// <para>Method of encryption.</para>
		/// <para>Valid values:</para>
		/// <para>0 = None / other</para>
		/// <para>1 = PKCS (proprietary)</para>
		/// <para>2 = DES (ECB mode)</para>
		/// <para>3 = PKCS/DES (proprietary)</para>
		/// <para>4 = PGP/DES (defunct)</para>
		/// <para>5 = PGP/DES-MD5 (see app note on FIX web site)</para>
		/// <para>6 = PEM/DES-MD5 (see app note on FIX web site)</para>
		/// </summary>
		public enum EncryptMethod
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>None / other</para>
			/// </summary>
			None = (int)'0',
			/// <summary>
			/// <para>PKCS (proprietary)</para>
			/// </summary>
			PKCS = (int)'1',
			/// <summary>
			/// <para>DES (ECB mode)</para>
			/// </summary>
			DES = (int)'2',
			/// <summary>
			/// <para>PKCS/DES (proprietary)</para>
			/// </summary>
			PKCSDES = (int)'3',
			/// <summary>
			/// <para>PGP/DES (defunct)</para>
			/// </summary>
			PGPDES = (int)'4',
			/// <summary>
			/// <para>PGP/DES-MD5 (see app note on FIX web site)</para>
			/// </summary>
			PGPDESMD5 = (int)'5',
			/// <summary>
			/// <para>PEM/DES-MD5 (see app note on FIX web site)</para>
			/// </summary>
			PEM = (int)'6',
		}

		/// <summary>
		/// <para>Indicates that the both sides of the FIX session should reset sequence numbers.</para>
		/// <para>Valid values:</para>
		/// <para>Y = Yes, reset sequence numbers</para>
		/// <para>N = No</para>
		/// </summary>
		public enum ResetSeqNumFlag
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>No</para>
			/// </summary>
			No = (int)'N',
			/// <summary>
			/// <para>Yes, reset sequence numbers</para>
			/// </summary>
			Yes = (int)'Y',
		}

		/// <summary>
		/// <para>Specifies the direction of the messsage.</para>
		/// <para>Valid values:</para>
		/// <para>S = Send</para>
		/// <para>R = Receive</para>
		/// </summary>
		public enum MsgDirection
		{
			/// <summary>
			/// Undefined value
			/// </summary>
			Undefined = -1,
			/// <summary>
			/// <para>Receive</para>
			/// </summary>
			Receive = (int)'R',
			/// <summary>
			/// <para>Send</para>
			/// </summary>
			Send = (int)'S',
		}

		/// <summary>
		/// <para>Number of repeating groups of IOIQualifiers.</para>
		/// <para>Required if any IOIQualifiers are specified. Indicates the number of repeating IOIQualifiers.</para>
		/// </summary>
		public class IndicationOfInterestNoIOIQualifiersInstance
		{
			/// <summary>
			/// <para>Code to qualify IOI use.</para>
			/// <para>Valid values:</para>
			/// <para>A = All or none</para>
			/// <para>C = At the close</para>
			/// <para>I = In touch with</para>
			/// <para>L = Limit</para>
			/// <para>M = More behind</para>
			/// <para>O = At the open</para>
			/// <para>P = Taking a position</para>
			/// <para>Q = At the Market (previously called Current Quote)</para>
			/// <para>R = Ready to trade</para>
			/// <para>S = Portfolio show-n</para>
			/// <para>T = Through the day</para>
			/// <para>V = Versus</para>
			/// <para>W = Indication - Working away</para>
			/// <para>X = Crossing opportunity</para>
			/// <para>Y = At the Midpoint</para>
			/// <para>Z = Pre-open</para>
			/// <para>Required if NoIOIQualifiers &gt; 0</para>
			/// </summary>
			public IOIQualifier? IOIQualifier
			{
				get
				{
					IOIQualifier v;
					if (fieldSet.TryGetIOIQualifier(Tags.IOIQualifier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IOIQualifier); else fieldSet.Set(Tags.IOIQualifier, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating groups of IOIQualifiers.</para>
			/// <para>Required if any IOIQualifiers are specified. Indicates the number of repeating IOIQualifiers.</para>
			/// </summary>
			internal IndicationOfInterestNoIOIQualifiersInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// IndicationOfInterestNoIOIQualifiersInstance collection.
		/// </summary>
		#region IndicationOfInterestNoIOIQualifiersCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class IndicationOfInterestNoIOIQualifiersCollection : IEnumerable<IndicationOfInterestNoIOIQualifiersInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<IndicationOfInterestNoIOIQualifiersInstance> entries;

			internal IndicationOfInterestNoIOIQualifiersCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<IndicationOfInterestNoIOIQualifiersInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new IndicationOfInterestNoIOIQualifiersInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public IndicationOfInterestNoIOIQualifiersInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public IndicationOfInterestNoIOIQualifiersInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoIOIQualifiers, 1);
				else
					parent.SetGroup(Tags.NoIOIQualifiers, group.NumberOfInstances + 1);
				IndicationOfInterestNoIOIQualifiersInstance text = new IndicationOfInterestNoIOIQualifiersInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoIOIQualifiers, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoIOIQualifiers, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(IndicationOfInterestNoIOIQualifiersInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<IndicationOfInterestNoIOIQualifiersInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<IndicationOfInterestNoIOIQualifiersInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion IndicationOfInterestNoIOIQualifiersCollection
		/// <summary>
		/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
		/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
		/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
		/// </summary>
		public class IndicationOfInterestNoRoutingIDsInstance
		{
			/// <summary>
			/// <para>Indicates the type of RoutingID specified.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Target Firm</para>
			/// <para>2 = Target List</para>
			/// <para>3 = Block Firm</para>
			/// <para>4 = Block List</para>
			/// <para>Indicates type of RoutingID. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public RoutingType? RoutingType
			{
				get
				{
					RoutingType v;
					if (fieldSet.TryGetRoutingType(Tags.RoutingType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingType); else fieldSet.Set(Tags.RoutingType, value.Value);
				}
			}

			/// <summary>
			/// <para>Assigned value used to identify a specific routing destination.</para>
			/// <para>Identifies routing destination. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public System.String RoutingID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RoutingID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingID); else fieldSet.Set(Tags.RoutingID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
			/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
			/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
			/// </summary>
			internal IndicationOfInterestNoRoutingIDsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// IndicationOfInterestNoRoutingIDsInstance collection.
		/// </summary>
		#region IndicationOfInterestNoRoutingIDsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class IndicationOfInterestNoRoutingIDsCollection : IEnumerable<IndicationOfInterestNoRoutingIDsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<IndicationOfInterestNoRoutingIDsInstance> entries;

			internal IndicationOfInterestNoRoutingIDsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<IndicationOfInterestNoRoutingIDsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new IndicationOfInterestNoRoutingIDsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public IndicationOfInterestNoRoutingIDsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public IndicationOfInterestNoRoutingIDsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRoutingIDs, 1);
				else
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances + 1);
				IndicationOfInterestNoRoutingIDsInstance text = new IndicationOfInterestNoRoutingIDsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRoutingIDs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(IndicationOfInterestNoRoutingIDsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<IndicationOfInterestNoRoutingIDsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<IndicationOfInterestNoRoutingIDsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion IndicationOfInterestNoRoutingIDsCollection
		/// <summary>
		/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
		/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
		/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
		/// </summary>
		public class NewsNoRoutingIDsInstance
		{
			/// <summary>
			/// <para>Indicates the type of RoutingID specified.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Target Firm</para>
			/// <para>2 = Target List</para>
			/// <para>3 = Block Firm</para>
			/// <para>4 = Block List</para>
			/// <para>Indicates type of RoutingID. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public RoutingType? RoutingType
			{
				get
				{
					RoutingType v;
					if (fieldSet.TryGetRoutingType(Tags.RoutingType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingType); else fieldSet.Set(Tags.RoutingType, value.Value);
				}
			}

			/// <summary>
			/// <para>Assigned value used to identify a specific routing destination.</para>
			/// <para>Identifies routing destination. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public System.String RoutingID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RoutingID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingID); else fieldSet.Set(Tags.RoutingID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
			/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
			/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
			/// </summary>
			internal NewsNoRoutingIDsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// NewsNoRoutingIDsInstance collection.
		/// </summary>
		#region NewsNoRoutingIDsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class NewsNoRoutingIDsCollection : IEnumerable<NewsNoRoutingIDsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<NewsNoRoutingIDsInstance> entries;

			internal NewsNoRoutingIDsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<NewsNoRoutingIDsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new NewsNoRoutingIDsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public NewsNoRoutingIDsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public NewsNoRoutingIDsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRoutingIDs, 1);
				else
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances + 1);
				NewsNoRoutingIDsInstance text = new NewsNoRoutingIDsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRoutingIDs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(NewsNoRoutingIDsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<NewsNoRoutingIDsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<NewsNoRoutingIDsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion NewsNoRoutingIDsCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Specifies the number of repeating symbols specified</para>
		/// </summary>
		public class NewsNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Symbol of issue related to story. Can be repeated within message to identify multiple companies.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String RelatdSym
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RelatdSym, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RelatdSym); else fieldSet.Set(Tags.RelatdSym, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: RelatdSym, SecurityType, and MaturityMonthYear are required. If an Option: RelatdSym, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Specifies the number of repeating symbols specified</para>
			/// </summary>
			internal NewsNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// NewsNoRelatedSymInstance collection.
		/// </summary>
		#region NewsNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class NewsNoRelatedSymCollection : IEnumerable<NewsNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<NewsNoRelatedSymInstance> entries;

			internal NewsNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<NewsNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new NewsNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public NewsNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public NewsNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				NewsNoRelatedSymInstance text = new NewsNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(NewsNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<NewsNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<NewsNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion NewsNoRelatedSymCollection
		/// <summary>
		/// <para>Identifies number of lines of text body</para>
		/// <para>Specifies the number of repeating lines of text specified</para>
		/// </summary>
		public class NewsLinesOfTextInstance
		{
			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// <para>Repeating field, number of instances defined in LinesOfText</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					return fieldSet.Get(Tags.Text);
				}
				set
				{
					fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Identifies number of lines of text body</para>
			/// <para>Specifies the number of repeating lines of text specified</para>
			/// </summary>
			internal NewsLinesOfTextInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// NewsLinesOfTextInstance collection.
		/// </summary>
		#region NewsLinesOfTextCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class NewsLinesOfTextCollection : IEnumerable<NewsLinesOfTextInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<NewsLinesOfTextInstance> entries;

			internal NewsLinesOfTextCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<NewsLinesOfTextInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new NewsLinesOfTextInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public NewsLinesOfTextInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public NewsLinesOfTextInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.LinesOfText, 1);
				else
					parent.SetGroup(Tags.LinesOfText, group.NumberOfInstances + 1);
				NewsLinesOfTextInstance text = new NewsLinesOfTextInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.LinesOfText, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.LinesOfText, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(NewsLinesOfTextInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<NewsLinesOfTextInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<NewsLinesOfTextInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion NewsLinesOfTextCollection
		/// <summary>
		/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
		/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
		/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
		/// </summary>
		public class EmailNoRoutingIDsInstance
		{
			/// <summary>
			/// <para>Indicates the type of RoutingID specified.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Target Firm</para>
			/// <para>2 = Target List</para>
			/// <para>3 = Block Firm</para>
			/// <para>4 = Block List</para>
			/// <para>Indicates type of RoutingID. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public RoutingType? RoutingType
			{
				get
				{
					RoutingType v;
					if (fieldSet.TryGetRoutingType(Tags.RoutingType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingType); else fieldSet.Set(Tags.RoutingType, value.Value);
				}
			}

			/// <summary>
			/// <para>Assigned value used to identify a specific routing destination.</para>
			/// <para>Identifies routing destination. Required if NoRoutingIDs is &gt; 0.</para>
			/// </summary>
			public System.String RoutingID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RoutingID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RoutingID); else fieldSet.Set(Tags.RoutingID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
			/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
			/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
			/// </summary>
			internal EmailNoRoutingIDsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// EmailNoRoutingIDsInstance collection.
		/// </summary>
		#region EmailNoRoutingIDsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class EmailNoRoutingIDsCollection : IEnumerable<EmailNoRoutingIDsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<EmailNoRoutingIDsInstance> entries;

			internal EmailNoRoutingIDsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<EmailNoRoutingIDsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new EmailNoRoutingIDsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public EmailNoRoutingIDsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public EmailNoRoutingIDsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRoutingIDs, 1);
				else
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances + 1);
				EmailNoRoutingIDsInstance text = new EmailNoRoutingIDsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRoutingIDs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRoutingIDs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(EmailNoRoutingIDsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<EmailNoRoutingIDsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<EmailNoRoutingIDsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion EmailNoRoutingIDsCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Specifies the number of repeating symbols specified</para>
		/// </summary>
		public class EmailNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Symbol of issue related to story. Can be repeated within message to identify multiple companies.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String RelatdSym
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RelatdSym, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RelatdSym); else fieldSet.Set(Tags.RelatdSym, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: RelatdSym, SecurityType, and MaturityMonthYear are required. If an Option: RelatdSym, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Specifies the number of repeating symbols specified</para>
			/// </summary>
			internal EmailNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// EmailNoRelatedSymInstance collection.
		/// </summary>
		#region EmailNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class EmailNoRelatedSymCollection : IEnumerable<EmailNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<EmailNoRelatedSymInstance> entries;

			internal EmailNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<EmailNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new EmailNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public EmailNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public EmailNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				EmailNoRelatedSymInstance text = new EmailNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(EmailNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<EmailNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<EmailNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion EmailNoRelatedSymCollection
		/// <summary>
		/// <para>Identifies number of lines of text body</para>
		/// <para>Specifies the number of repeating lines of text specified</para>
		/// </summary>
		public class EmailLinesOfTextInstance
		{
			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// <para>Repeating field, number of instances defined in LinesOfText</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					return fieldSet.Get(Tags.Text);
				}
				set
				{
					fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Identifies number of lines of text body</para>
			/// <para>Specifies the number of repeating lines of text specified</para>
			/// </summary>
			internal EmailLinesOfTextInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// EmailLinesOfTextInstance collection.
		/// </summary>
		#region EmailLinesOfTextCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class EmailLinesOfTextCollection : IEnumerable<EmailLinesOfTextInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<EmailLinesOfTextInstance> entries;

			internal EmailLinesOfTextCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<EmailLinesOfTextInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new EmailLinesOfTextInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public EmailLinesOfTextInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public EmailLinesOfTextInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.LinesOfText, 1);
				else
					parent.SetGroup(Tags.LinesOfText, group.NumberOfInstances + 1);
				EmailLinesOfTextInstance text = new EmailLinesOfTextInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.LinesOfText, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.LinesOfText, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(EmailLinesOfTextInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<EmailLinesOfTextInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<EmailLinesOfTextInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion EmailLinesOfTextCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Number of related symbols in Request</para>
		/// </summary>
		public class QuoteRequestNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Ticker symbol</para>
			/// <para>Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					return fieldSet.Get(Tags.Symbol);
				}
				set
				{
					fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future:Symbol, SecurityType, and MaturityMonthYear are required. If an Option:Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Previous closing price of security.</para>
			/// <para>Useful for verifying security identification</para>
			/// </summary>
			public System.Double? PrevClosePx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.PrevClosePx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PrevClosePx); else fieldSet.Set(Tags.PrevClosePx, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates the type of Quote Request being generated</para>
			/// <para>Valid values:</para>
			/// <para>1-Manual</para>
			/// <para>2-Automatic</para>
			/// <para>Indicates the type of Quote Request (e.g. Manual vs. Automatic) being generated.</para>
			/// </summary>
			public QuoteRequestType? QuoteRequestType
			{
				get
				{
					QuoteRequestType v;
					if (fieldSet.TryGetQuoteRequestType(Tags.QuoteRequestType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteRequestType); else fieldSet.Set(Tags.QuoteRequestType, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>If OrdType = 'Forex - Swap', should be the side of the future portion of a F/X swap</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? OrderQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
			/// <para>Can be used with forex quotes to specify the desired 'value date'</para>
			/// </summary>
			public System.DateTime? FutSettDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Order type.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Market</para>
			/// <para>2 = Limit</para>
			/// <para>3 = Stop</para>
			/// <para>4 = Stop limit</para>
			/// <para>5 = Market on close</para>
			/// <para>6 = With or without</para>
			/// <para>7 = Limit or better</para>
			/// <para>8 = Limit with or without</para>
			/// <para>9 = On basis</para>
			/// <para>A = On close</para>
			/// <para>B = Limit on close</para>
			/// <para>C =Forex - Market</para>
			/// <para>D = Previously quoted</para>
			/// <para>E = Previously indicated</para>
			/// <para>F = Forex - Limit</para>
			/// <para>G = Forex - Swap</para>
			/// <para>H = Forex - Previously Quoted</para>
			/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
			/// <para>P = Pegged</para>
			/// <para>Can be used to specify the type of order the quote request is for</para>
			/// </summary>
			public OrdType? OrdType
			{
				get
				{
					OrdType v;
					if (fieldSet.TryGetOrdType(Tags.OrdType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrdType); else fieldSet.Set(Tags.OrdType, value.Value);
				}
			}

			/// <summary>
			/// <para>FutSettDate of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
			/// </summary>
			public System.DateTime? FutSettDate2
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>OrderQty of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
			/// </summary>
			public System.Double? OrderQty2
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
				}
			}

			/// <summary>
			/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// <para>The time when Quote Request will expire.</para>
			/// </summary>
			public System.DateTime? ExpireTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// <para>Time transaction was entered</para>
			/// </summary>
			public System.DateTime? TransactTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// <para>Can be used to specify the currency of the quoted price.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Number of related symbols in Request</para>
			/// </summary>
			internal QuoteRequestNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// QuoteRequestNoRelatedSymInstance collection.
		/// </summary>
		#region QuoteRequestNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class QuoteRequestNoRelatedSymCollection : IEnumerable<QuoteRequestNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<QuoteRequestNoRelatedSymInstance> entries;

			internal QuoteRequestNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<QuoteRequestNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new QuoteRequestNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public QuoteRequestNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public QuoteRequestNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				QuoteRequestNoRelatedSymInstance text = new QuoteRequestNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(QuoteRequestNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<QuoteRequestNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<QuoteRequestNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion QuoteRequestNoRelatedSymCollection
		/// <summary>
		/// <para>The number of quote entries for a QuoteSet.</para>
		/// <para>The number of securities whose quotes are to be canceled</para>
		/// </summary>
		public class QuoteCancelNoQuoteEntriesInstance
		{
			/// <summary>
			/// <para>Ticker symbol</para>
			/// <para>Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					return fieldSet.Get(Tags.Symbol);
				}
				set
				{
					fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future:Symbol, SecurityType, and MaturityMonthYear are required. If an Option:Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Symbol.</para>
			/// <para>See Symbol field for description</para>
			/// <para>The symbol of the underlying security of options that should be canceled.</para>
			/// </summary>
			public System.String UnderlyingSymbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbol); else fieldSet.Set(Tags.UnderlyingSymbol, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of quote entries for a QuoteSet.</para>
			/// <para>The number of securities whose quotes are to be canceled</para>
			/// </summary>
			internal QuoteCancelNoQuoteEntriesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// QuoteCancelNoQuoteEntriesInstance collection.
		/// </summary>
		#region QuoteCancelNoQuoteEntriesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class QuoteCancelNoQuoteEntriesCollection : IEnumerable<QuoteCancelNoQuoteEntriesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<QuoteCancelNoQuoteEntriesInstance> entries;

			internal QuoteCancelNoQuoteEntriesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<QuoteCancelNoQuoteEntriesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new QuoteCancelNoQuoteEntriesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public QuoteCancelNoQuoteEntriesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public QuoteCancelNoQuoteEntriesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoQuoteEntries, 1);
				else
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances + 1);
				QuoteCancelNoQuoteEntriesInstance text = new QuoteCancelNoQuoteEntriesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoQuoteEntries, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(QuoteCancelNoQuoteEntriesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<QuoteCancelNoQuoteEntriesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<QuoteCancelNoQuoteEntriesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion QuoteCancelNoQuoteEntriesCollection
		/// <summary>
		/// <para>The number of sets of quotes in the message.</para>
		/// <para>The number of sets of quotes in the message</para>
		/// </summary>
		public class QuoteAcknowledgementNoQuoteSetsInstance
		{
			/// <summary>
			/// <para>Unique id for the Quote Set.</para>
			/// <para>First field in repeating group. Required if NoQuoteSets &gt; 0</para>
			/// </summary>
			public System.String QuoteSetID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.QuoteSetID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteSetID); else fieldSet.Set(Tags.QuoteSetID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Symbol.</para>
			/// <para>See Symbol field for description</para>
			/// <para>Required if NoQuoteSets &gt; 0</para>
			/// </summary>
			public System.String UnderlyingSymbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbol); else fieldSet.Set(Tags.UnderlyingSymbol, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SymbolSfx.</para>
			/// <para>See SymbolSfx field for description</para>
			/// </summary>
			public System.String UnderlyingSymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbolSfx); else fieldSet.Set(Tags.UnderlyingSymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityID.</para>
			/// <para>See SecurityID field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityID); else fieldSet.Set(Tags.UnderlyingSecurityID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's IDSource.</para>
			/// <para>Valid values: see IDSource field</para>
			/// </summary>
			public System.String UnderlyingIDSource
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIDSource); else fieldSet.Set(Tags.UnderlyingIDSource, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityType.</para>
			/// <para>Valid values: see SecurityType field</para>
			/// </summary>
			public System.String UnderlyingSecurityType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityType); else fieldSet.Set(Tags.UnderlyingSecurityType, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityMonthYear. Required if UnderlyingMaturityDay is specified.</para>
			/// <para>See MaturityMonthYear field for description</para>
			/// <para>Required if UnderlyingMaturityDay is specified.</para>
			/// </summary>
			public System.String UnderlyingMaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityMonthYear); else fieldSet.Set(Tags.UnderlyingMaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityDay.</para>
			/// <para>See MaturityDay field for description</para>
			/// </summary>
			public System.Int32? UnderlyingMaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityDay); else fieldSet.Set(Tags.UnderlyingMaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's PutOrCall.</para>
			/// <para>See PutOrCall field for description</para>
			/// </summary>
			public System.String UnderlyingPutOrCall
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingPutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingPutOrCall); else fieldSet.Set(Tags.UnderlyingPutOrCall, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's StrikePrice.</para>
			/// <para>See StrikePrice field for description</para>
			/// </summary>
			public System.Double? UnderlyingStrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.UnderlyingStrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingStrikePrice); else fieldSet.Set(Tags.UnderlyingStrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's OptAttribute.</para>
			/// <para>See OptAttribute field for description</para>
			/// </summary>
			public System.Char? UnderlyingOptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.UnderlyingOptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingOptAttribute); else fieldSet.Set(Tags.UnderlyingOptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's ContractMultiplier.</para>
			/// <para>See ContractMultiplier field for description</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc.</para>
			/// </summary>
			public System.String UnderlyingContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingContractMultiplier); else fieldSet.Set(Tags.UnderlyingContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's CouponRate.</para>
			/// <para>See CouponRate field for description</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String UnderlyingCouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCouponRate); else fieldSet.Set(Tags.UnderlyingCouponRate, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityExchange. Can be used to identify the underlying security.</para>
			/// <para>Valid values: see SecurityExchange</para>
			/// </summary>
			public System.String UnderlyingSecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityExchange); else fieldSet.Set(Tags.UnderlyingSecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Issuer.</para>
			/// <para>See Issuer field for description</para>
			/// </summary>
			public System.String UnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIssuer); else fieldSet.Set(Tags.UnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingIssuer field.</para>
			/// <para>Must be set if EncodedUnderlyingIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuerLen); else fieldSet.Set(Tags.EncodedUnderlyingIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingIssuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuer); else fieldSet.Set(Tags.EncodedUnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityDesc.</para>
			/// <para>See SecurityDesc field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityDesc); else fieldSet.Set(Tags.UnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingSecurityDesc field.</para>
			/// <para>Must be set if EncodedUnderlyingSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDescLen); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingSecurityeDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDesc); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set.</para>
			/// <para>Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set.</para>
			/// <para>Required if NoQuoteEntries &gt; 0</para>
			/// </summary>
			public System.String TotQuoteEntries
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TotQuoteEntries, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TotQuoteEntries); else fieldSet.Set(Tags.TotQuoteEntries, value);
				}
			}

			private QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection noQuoteEntries;
			/// <summary>
			/// <para>The number of quote entries for a QuoteSet.</para>
			/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
			/// </summary>
			public QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection NoQuoteEntries
			{
				get
				{
					return noQuoteEntries;
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of sets of quotes in the message.</para>
			/// <para>The number of sets of quotes in the message</para>
			/// </summary>
			internal QuoteAcknowledgementNoQuoteSetsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
				this.noQuoteEntries = new QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteEntries));
			}

		}

		/// <summary>
		/// QuoteAcknowledgementNoQuoteSetsInstance collection.
		/// </summary>
		#region QuoteAcknowledgementNoQuoteSetsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class QuoteAcknowledgementNoQuoteSetsCollection : IEnumerable<QuoteAcknowledgementNoQuoteSetsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<QuoteAcknowledgementNoQuoteSetsInstance> entries;

			internal QuoteAcknowledgementNoQuoteSetsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<QuoteAcknowledgementNoQuoteSetsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new QuoteAcknowledgementNoQuoteSetsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public QuoteAcknowledgementNoQuoteSetsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public QuoteAcknowledgementNoQuoteSetsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoQuoteSets, 1);
				else
					parent.SetGroup(Tags.NoQuoteSets, group.NumberOfInstances + 1);
				QuoteAcknowledgementNoQuoteSetsInstance text = new QuoteAcknowledgementNoQuoteSetsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoQuoteSets, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoQuoteSets, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(QuoteAcknowledgementNoQuoteSetsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<QuoteAcknowledgementNoQuoteSetsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<QuoteAcknowledgementNoQuoteSetsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion QuoteAcknowledgementNoQuoteSetsCollection
		/// <summary>
		/// <para>The number of quote entries for a QuoteSet.</para>
		/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
		/// </summary>
		public class QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance
		{
			/// <summary>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>First field in repeating group. Required if NoQuoteEntries &gt; 0.</para>
			/// </summary>
			public System.String QuoteEntryID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.QuoteEntryID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteEntryID); else fieldSet.Set(Tags.QuoteEntryID, value);
				}
			}

			/// <summary>
			/// <para>Ticker symbol</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Symbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Symbol); else fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Reason Quote Entry was rejected:</para>
			/// <para>Valid values:</para>
			/// <para>1 = Unknown symbol (Security)</para>
			/// <para>2 = Exchange(Security) closed</para>
			/// <para>3 = Quote exceeds limit</para>
			/// <para>4 = Too late to enter</para>
			/// <para>5 = Unknown Quote</para>
			/// <para>6 = Duplicate Quote</para>
			/// <para>7 = Invalid bid/ask spread</para>
			/// <para>8 = Invalid price</para>
			/// <para>9 = Not authorized to quote security</para>
			/// <para>Reason Quote Entry was rejected.</para>
			/// </summary>
			public QuoteEntryRejectReason? QuoteEntryRejectReason
			{
				get
				{
					QuoteEntryRejectReason v;
					if (fieldSet.TryGetQuoteEntryRejectReason(Tags.QuoteEntryRejectReason, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteEntryRejectReason); else fieldSet.Set(Tags.QuoteEntryRejectReason, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of quote entries for a QuoteSet.</para>
			/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
			/// </summary>
			internal QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance collection.
		/// </summary>
		#region QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection : IEnumerable<QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance> entries;

			internal QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoQuoteEntries, 1);
				else
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances + 1);
				QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance text = new QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoQuoteEntries, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion QuoteAcknowledgementNoQuoteSetsNoQuoteEntriesCollection
		/// <summary>
		/// <para>The number of sets of quotes in the message.</para>
		/// <para>The number of sets of quotes in the message</para>
		/// </summary>
		public class MassQuoteNoQuoteSetsInstance
		{
			/// <summary>
			/// <para>Unique id for the Quote Set.</para>
			/// <para>Sequential number for the Quote Set. For a given QuoteID - assumed to start at 1.</para>
			/// <para>Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String QuoteSetID
			{
				get
				{
					return fieldSet.Get(Tags.QuoteSetID);
				}
				set
				{
					fieldSet.Set(Tags.QuoteSetID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Symbol.</para>
			/// <para>See Symbol field for description</para>
			/// </summary>
			public System.String UnderlyingSymbol
			{
				get
				{
					return fieldSet.Get(Tags.UnderlyingSymbol);
				}
				set
				{
					fieldSet.Set(Tags.UnderlyingSymbol, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SymbolSfx.</para>
			/// <para>See SymbolSfx field for description</para>
			/// </summary>
			public System.String UnderlyingSymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbolSfx); else fieldSet.Set(Tags.UnderlyingSymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityID.</para>
			/// <para>See SecurityID field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityID); else fieldSet.Set(Tags.UnderlyingSecurityID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's IDSource.</para>
			/// <para>Valid values: see IDSource field</para>
			/// </summary>
			public System.String UnderlyingIDSource
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIDSource); else fieldSet.Set(Tags.UnderlyingIDSource, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityType.</para>
			/// <para>Valid values: see SecurityType field</para>
			/// </summary>
			public System.String UnderlyingSecurityType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityType); else fieldSet.Set(Tags.UnderlyingSecurityType, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityMonthYear. Required if UnderlyingMaturityDay is specified.</para>
			/// <para>See MaturityMonthYear field for description</para>
			/// <para>Required if UnderlyingMaturityDay is specified.</para>
			/// </summary>
			public System.String UnderlyingMaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityMonthYear); else fieldSet.Set(Tags.UnderlyingMaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityDay.</para>
			/// <para>See MaturityDay field for description</para>
			/// </summary>
			public System.Int32? UnderlyingMaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityDay); else fieldSet.Set(Tags.UnderlyingMaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's PutOrCall.</para>
			/// <para>See PutOrCall field for description</para>
			/// </summary>
			public System.String UnderlyingPutOrCall
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingPutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingPutOrCall); else fieldSet.Set(Tags.UnderlyingPutOrCall, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's StrikePrice.</para>
			/// <para>See StrikePrice field for description</para>
			/// </summary>
			public System.Double? UnderlyingStrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.UnderlyingStrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingStrikePrice); else fieldSet.Set(Tags.UnderlyingStrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's OptAttribute.</para>
			/// <para>See OptAttribute field for description</para>
			/// </summary>
			public System.Char? UnderlyingOptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.UnderlyingOptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingOptAttribute); else fieldSet.Set(Tags.UnderlyingOptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's ContractMultiplier.</para>
			/// <para>See ContractMultiplier field for description</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc.</para>
			/// </summary>
			public System.String UnderlyingContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingContractMultiplier); else fieldSet.Set(Tags.UnderlyingContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's CouponRate.</para>
			/// <para>See CouponRate field for description</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String UnderlyingCouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCouponRate); else fieldSet.Set(Tags.UnderlyingCouponRate, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityExchange. Can be used to identify the underlying security.</para>
			/// <para>Valid values: see SecurityExchange</para>
			/// </summary>
			public System.String UnderlyingSecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityExchange); else fieldSet.Set(Tags.UnderlyingSecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Issuer.</para>
			/// <para>See Issuer field for description</para>
			/// </summary>
			public System.String UnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIssuer); else fieldSet.Set(Tags.UnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingIssuer field.</para>
			/// <para>Must be set if EncodedUnderlyingIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuerLen); else fieldSet.Set(Tags.EncodedUnderlyingIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingIssuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuer); else fieldSet.Set(Tags.EncodedUnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityDesc.</para>
			/// <para>See SecurityDesc field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityDesc); else fieldSet.Set(Tags.UnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingSecurityDesc field.</para>
			/// <para>Must be set if EncodedUnderlyingSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDescLen); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingSecurityeDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDesc); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Indicates expiration time of this particular QuoteSet (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? QuoteSetValidUntilTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.QuoteSetValidUntilTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteSetValidUntilTime); else fieldSet.Set(Tags.QuoteSetValidUntilTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set.</para>
			/// <para>Total number of quotes for the quote set across all messages. Should be the sum of all NoQuoteEntries in each message that has repeating quotes that are part of the same quote set.</para>
			/// </summary>
			public System.String TotQuoteEntries
			{
				get
				{
					return fieldSet.Get(Tags.TotQuoteEntries);
				}
				set
				{
					fieldSet.Set(Tags.TotQuoteEntries, value);
				}
			}

			private MassQuoteNoQuoteSetsNoQuoteEntriesCollection noQuoteEntries;
			/// <summary>
			/// <para>The number of quote entries for a QuoteSet.</para>
			/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
			/// <para>** Nested Repeating Group follows **</para>
			/// </summary>
			public MassQuoteNoQuoteSetsNoQuoteEntriesCollection NoQuoteEntries
			{
				get
				{
					return noQuoteEntries;
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of sets of quotes in the message.</para>
			/// <para>The number of sets of quotes in the message</para>
			/// </summary>
			internal MassQuoteNoQuoteSetsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
				this.noQuoteEntries = new MassQuoteNoQuoteSetsNoQuoteEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteEntries));
			}

		}

		/// <summary>
		/// MassQuoteNoQuoteSetsInstance collection.
		/// </summary>
		#region MassQuoteNoQuoteSetsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MassQuoteNoQuoteSetsCollection : IEnumerable<MassQuoteNoQuoteSetsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MassQuoteNoQuoteSetsInstance> entries;

			internal MassQuoteNoQuoteSetsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MassQuoteNoQuoteSetsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MassQuoteNoQuoteSetsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MassQuoteNoQuoteSetsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MassQuoteNoQuoteSetsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoQuoteSets, 1);
				else
					parent.SetGroup(Tags.NoQuoteSets, group.NumberOfInstances + 1);
				MassQuoteNoQuoteSetsInstance text = new MassQuoteNoQuoteSetsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoQuoteSets, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoQuoteSets, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MassQuoteNoQuoteSetsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MassQuoteNoQuoteSetsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MassQuoteNoQuoteSetsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MassQuoteNoQuoteSetsCollection
		/// <summary>
		/// <para>The number of quote entries for a QuoteSet.</para>
		/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
		/// <para>** Nested Repeating Group follows **</para>
		/// </summary>
		public class MassQuoteNoQuoteSetsNoQuoteEntriesInstance
		{
			/// <summary>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>Must be used if NoQuoteEntries is used</para>
			/// </summary>
			public System.String QuoteEntryID
			{
				get
				{
					return fieldSet.Get(Tags.QuoteEntryID);
				}
				set
				{
					fieldSet.Set(Tags.QuoteEntryID, value);
				}
			}

			/// <summary>
			/// <para>Ticker symbol</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Symbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Symbol); else fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Bid price/rate</para>
			/// <para>If F/X quote, should be the 'all-in' rate (spot rate adjusted for forward points). Note that either BidPx, OfferPx or both must be specified.</para>
			/// </summary>
			public System.Double? BidPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.BidPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidPx); else fieldSet.Set(Tags.BidPx, value.Value);
				}
			}

			/// <summary>
			/// <para>Offer price/rate</para>
			/// <para>If F/X quote, should be the 'all-in' rate (spot rate adjusted for forward points). Note that either BidPx, OfferPx or both must be specified.</para>
			/// </summary>
			public System.Double? OfferPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OfferPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OfferPx); else fieldSet.Set(Tags.OfferPx, value.Value);
				}
			}

			/// <summary>
			/// <para>Quantity of bid</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? BidSize
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.BidSize, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidSize); else fieldSet.Set(Tags.BidSize, value.Value);
				}
			}

			/// <summary>
			/// <para>Quantity of offer</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? OfferSize
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OfferSize, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OfferSize); else fieldSet.Set(Tags.OfferSize, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates expiration time of indication message (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? ValidUntilTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ValidUntilTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ValidUntilTime); else fieldSet.Set(Tags.ValidUntilTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Bid F/X spot rate.y vary and not limited to four)</para>
			/// <para>May be applicable for F/X quotes</para>
			/// </summary>
			public System.Double? BidSpotRate
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.BidSpotRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidSpotRate); else fieldSet.Set(Tags.BidSpotRate, value.Value);
				}
			}

			/// <summary>
			/// <para>Offer F/X spot rate.</para>
			/// <para>May be applicable for F/X quotes</para>
			/// </summary>
			public System.Double? OfferSpotRate
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OfferSpotRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OfferSpotRate); else fieldSet.Set(Tags.OfferSpotRate, value.Value);
				}
			}

			/// <summary>
			/// <para>Bid F/X forward points added to spot rate. May be a negative value.</para>
			/// <para>May be applicable for F/X quotes</para>
			/// </summary>
			public System.Double? BidForwardPoints
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.BidForwardPoints, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidForwardPoints); else fieldSet.Set(Tags.BidForwardPoints, value.Value);
				}
			}

			/// <summary>
			/// <para>Offer F/X forward points added to spot rate. May be a negative value.</para>
			/// <para>May be applicable for F/X quotes</para>
			/// </summary>
			public System.Double? OfferForwardPoints
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OfferForwardPoints, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OfferForwardPoints); else fieldSet.Set(Tags.OfferForwardPoints, value.Value);
				}
			}

			/// <summary>
			/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? TransactTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
			/// <para>Can be used with forex quotes to specify a specific 'value date'</para>
			/// </summary>
			public System.DateTime? FutSettDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Order type.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Market</para>
			/// <para>2 = Limit</para>
			/// <para>3 = Stop</para>
			/// <para>4 = Stop limit</para>
			/// <para>5 = Market on close</para>
			/// <para>6 = With or without</para>
			/// <para>7 = Limit or better</para>
			/// <para>8 = Limit with or without</para>
			/// <para>9 = On basis</para>
			/// <para>A = On close</para>
			/// <para>B = Limit on close</para>
			/// <para>C =Forex - Market</para>
			/// <para>D = Previously quoted</para>
			/// <para>E = Previously indicated</para>
			/// <para>F = Forex - Limit</para>
			/// <para>G = Forex - Swap</para>
			/// <para>H = Forex - Previously Quoted</para>
			/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
			/// <para>P = Pegged</para>
			/// <para>Can be used to specify the type of order the quote is for</para>
			/// </summary>
			public OrdType? OrdType
			{
				get
				{
					OrdType v;
					if (fieldSet.TryGetOrdType(Tags.OrdType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrdType); else fieldSet.Set(Tags.OrdType, value.Value);
				}
			}

			/// <summary>
			/// <para>FutSettDate of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
			/// </summary>
			public System.DateTime? FutSettDate2
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>OrderQty of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
			/// </summary>
			public System.Double? OrderQty2
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// <para>Can be used to specify the currency of the quoted price.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of quote entries for a QuoteSet.</para>
			/// <para>The number of quotes for this Symbol (QuoteSet) that follow in this message.</para>
			/// <para>** Nested Repeating Group follows **</para>
			/// </summary>
			internal MassQuoteNoQuoteSetsNoQuoteEntriesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// MassQuoteNoQuoteSetsNoQuoteEntriesInstance collection.
		/// </summary>
		#region MassQuoteNoQuoteSetsNoQuoteEntriesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MassQuoteNoQuoteSetsNoQuoteEntriesCollection : IEnumerable<MassQuoteNoQuoteSetsNoQuoteEntriesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MassQuoteNoQuoteSetsNoQuoteEntriesInstance> entries;

			internal MassQuoteNoQuoteSetsNoQuoteEntriesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MassQuoteNoQuoteSetsNoQuoteEntriesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MassQuoteNoQuoteSetsNoQuoteEntriesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MassQuoteNoQuoteSetsNoQuoteEntriesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MassQuoteNoQuoteSetsNoQuoteEntriesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoQuoteEntries, 1);
				else
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances + 1);
				MassQuoteNoQuoteSetsNoQuoteEntriesInstance text = new MassQuoteNoQuoteSetsNoQuoteEntriesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoQuoteEntries, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoQuoteEntries, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MassQuoteNoQuoteSetsNoQuoteEntriesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MassQuoteNoQuoteSetsNoQuoteEntriesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MassQuoteNoQuoteSetsNoQuoteEntriesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MassQuoteNoQuoteSetsNoQuoteEntriesCollection
		/// <summary>
		/// <para>Number of MDEntryType fields requested.</para>
		/// <para>Number of MDEntryType fields requested.</para>
		/// </summary>
		public class MarketDataRequestNoMDEntryTypesInstance
		{
			/// <summary>
			/// <para>Type Market Data entry.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Bid</para>
			/// <para>1 = Offer</para>
			/// <para>2 = Trade</para>
			/// <para>3 = Index Value</para>
			/// <para>4 = Opening Price</para>
			/// <para>5 = Closing Price</para>
			/// <para>6 = Settlement Price</para>
			/// <para>7 = Trading Session High Price</para>
			/// <para>8 = Trading Session Low Price</para>
			/// <para>9 = Trading Session VWAP Price</para>
			/// <para>Must be the first field in this repeating group. This is a list of all the types of Market Data Entries that the firm requesting the Market Data is interested in receiving.</para>
			/// </summary>
			public MDEntryType MDEntryType
			{
				get
				{
					return fieldSet.GetMDEntryType(Tags.MDEntryType);
				}
				set
				{
					fieldSet.Set(Tags.MDEntryType, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of MDEntryType fields requested.</para>
			/// <para>Number of MDEntryType fields requested.</para>
			/// </summary>
			internal MarketDataRequestNoMDEntryTypesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// MarketDataRequestNoMDEntryTypesInstance collection.
		/// </summary>
		#region MarketDataRequestNoMDEntryTypesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MarketDataRequestNoMDEntryTypesCollection : IEnumerable<MarketDataRequestNoMDEntryTypesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MarketDataRequestNoMDEntryTypesInstance> entries;

			internal MarketDataRequestNoMDEntryTypesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MarketDataRequestNoMDEntryTypesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MarketDataRequestNoMDEntryTypesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MarketDataRequestNoMDEntryTypesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MarketDataRequestNoMDEntryTypesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoMDEntryTypes, 1);
				else
					parent.SetGroup(Tags.NoMDEntryTypes, group.NumberOfInstances + 1);
				MarketDataRequestNoMDEntryTypesInstance text = new MarketDataRequestNoMDEntryTypesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoMDEntryTypes, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoMDEntryTypes, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MarketDataRequestNoMDEntryTypesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MarketDataRequestNoMDEntryTypesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MarketDataRequestNoMDEntryTypesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MarketDataRequestNoMDEntryTypesCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Number of symbols requested.</para>
		/// </summary>
		public class MarketDataRequestNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Ticker symbol</para>
			/// <para>Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					return fieldSet.Get(Tags.Symbol);
				}
				set
				{
					fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future:Symbol, SecurityType, and MaturityMonthYear are required. If an Option:Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Number of symbols requested.</para>
			/// </summary>
			internal MarketDataRequestNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// MarketDataRequestNoRelatedSymInstance collection.
		/// </summary>
		#region MarketDataRequestNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MarketDataRequestNoRelatedSymCollection : IEnumerable<MarketDataRequestNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MarketDataRequestNoRelatedSymInstance> entries;

			internal MarketDataRequestNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MarketDataRequestNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MarketDataRequestNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MarketDataRequestNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MarketDataRequestNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				MarketDataRequestNoRelatedSymInstance text = new MarketDataRequestNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MarketDataRequestNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MarketDataRequestNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MarketDataRequestNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MarketDataRequestNoRelatedSymCollection
		/// <summary>
		/// <para>Number of entries in Market Data message.</para>
		/// <para>Number of entries following.</para>
		/// </summary>
		public class MarketDataSnapshotFullRefreshNoMDEntriesInstance
		{
			/// <summary>
			/// <para>Type Market Data entry.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Bid</para>
			/// <para>1 = Offer</para>
			/// <para>2 = Trade</para>
			/// <para>3 = Index Value</para>
			/// <para>4 = Opening Price</para>
			/// <para>5 = Closing Price</para>
			/// <para>6 = Settlement Price</para>
			/// <para>7 = Trading Session High Price</para>
			/// <para>8 = Trading Session Low Price</para>
			/// <para>9 = Trading Session VWAP Price</para>
			/// <para>Must be the first field in this repeating group.</para>
			/// </summary>
			public MDEntryType MDEntryType
			{
				get
				{
					return fieldSet.GetMDEntryType(Tags.MDEntryType);
				}
				set
				{
					fieldSet.Set(Tags.MDEntryType, value);
				}
			}

			/// <summary>
			/// <para>Price of the Market Data Entry.</para>
			/// </summary>
			public System.Double MDEntryPx
			{
				get
				{
					return fieldSet.GetDouble(Tags.MDEntryPx);
				}
				set
				{
					fieldSet.Set(Tags.MDEntryPx, value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// <para>Can be used to specify the currency of the quoted price.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			/// <summary>
			/// <para>Number of shares represented by the Market Data Entry.</para>
			/// <para>Conditionally required if MDEntryType = Bid(0), Offer(1), or Trade(2)</para>
			/// </summary>
			public System.Double? MDEntrySize
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MDEntrySize, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntrySize); else fieldSet.Set(Tags.MDEntrySize, value.Value);
				}
			}

			/// <summary>
			/// <para>Date of Market Data Entry.</para>
			/// </summary>
			public System.String MDEntryDate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryDate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryDate); else fieldSet.Set(Tags.MDEntryDate, value);
				}
			}

			/// <summary>
			/// <para>Time of Market Data Entry.</para>
			/// </summary>
			public System.TimeSpan? MDEntryTime
			{
				get
				{
					System.TimeSpan v;
					if (fieldSet.TryGetValue(Tags.MDEntryTime, "UTCTimeOnly", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryTime); else fieldSet.Set(Tags.MDEntryTime, "UTCTimeOnly", value.Value);
				}
			}

			/// <summary>
			/// <para>Direction of the "tick".</para>
			/// <para>Valid values:</para>
			/// <para>0 = Plus Tick</para>
			/// <para>1 = Zero-Plus Tick</para>
			/// <para>2 = Minus Tick</para>
			/// <para>3 = Zero-Minus Tick</para>
			/// </summary>
			public TickDirection? TickDirection
			{
				get
				{
					TickDirection v;
					if (fieldSet.TryGetTickDirection(Tags.TickDirection, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TickDirection); else fieldSet.Set(Tags.TickDirection, value.Value);
				}
			}

			/// <summary>
			/// <para>Market posting quote / trade.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Market posting quote / trade. Valid values:</para>
			/// <para>See Appendix C</para>
			/// </summary>
			public System.String MDMkt
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDMkt, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDMkt); else fieldSet.Set(Tags.MDMkt, value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Space-delimited list of conditions describing a quote.</para>
			/// <para>Valid values:</para>
			/// <para>A = Open / Active</para>
			/// <para>B = Closed / Inactive</para>
			/// <para>C = Exchange Best</para>
			/// <para>D = Consolidated Best</para>
			/// <para>E = Locked</para>
			/// <para>F = Crossed</para>
			/// <para>G = Depth</para>
			/// <para>H = Fast Trading</para>
			/// <para>I = Non-Firm</para>
			/// <para>Space-delimited list of conditions describing a quote.</para>
			/// </summary>
			public QuoteCondition? QuoteCondition
			{
				get
				{
					QuoteCondition v;
					if (fieldSet.TryGetQuoteCondition(Tags.QuoteCondition, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteCondition); else fieldSet.Set(Tags.QuoteCondition, value.Value);
				}
			}

			/// <summary>
			/// <para>Space-delimited list of conditions describing a trade</para>
			/// <para>Valid values:</para>
			/// <para>A = Cash (only) Market</para>
			/// <para>B = Average Price Trade</para>
			/// <para>C = Cash Trade (same day clearing)</para>
			/// <para>D = Next Day (only) Market</para>
			/// <para>E = Opening / Reopening Trade Detail</para>
			/// <para>F = Intraday Trade Detail</para>
			/// <para>G = Rule 127 Trade (NYSE)</para>
			/// <para>H = Rule 155 Trade (Amex)</para>
			/// <para>I = Sold Last (late reporting)</para>
			/// <para>J = Next Day Trade (next day clearing)</para>
			/// <para>K = Opened (late report of opened trade)</para>
			/// <para>L = Seller</para>
			/// <para>M = Sold (out of sequence)</para>
			/// <para>N = Stopped Stock (guarantee of price but does not execute the order)</para>
			/// <para>Space-delimited list of conditions describing a trade</para>
			/// </summary>
			public TradeCondition? TradeCondition
			{
				get
				{
					TradeCondition v;
					if (fieldSet.TryGetTradeCondition(Tags.TradeCondition, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradeCondition); else fieldSet.Set(Tags.TradeCondition, value.Value);
				}
			}

			/// <summary>
			/// <para>Originator of a Market Data Entry</para>
			/// </summary>
			public System.String MDEntryOriginator
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryOriginator, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryOriginator); else fieldSet.Set(Tags.MDEntryOriginator, value);
				}
			}

			/// <summary>
			/// <para>Identification of a Market Maker's location</para>
			/// </summary>
			public System.String LocationID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.LocationID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LocationID); else fieldSet.Set(Tags.LocationID, value);
				}
			}

			/// <summary>
			/// <para>Identification of a Market Maker's desk</para>
			/// </summary>
			public System.String DeskID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.DeskID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.DeskID); else fieldSet.Set(Tags.DeskID, value);
				}
			}

			/// <summary>
			/// <para>Flag that identifies a price.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Daily Open / Close / Settlement price</para>
			/// <para>1 = Session Open / Close / Settlement price</para>
			/// <para>2 = Delivery Settlement price</para>
			/// <para>Used if MDEntryType = Opening Price(4), Closing Price(5), or Settlement Price(6).</para>
			/// </summary>
			public OpenCloseSettleFlag? OpenCloseSettleFlag
			{
				get
				{
					OpenCloseSettleFlag v;
					if (fieldSet.TryGetOpenCloseSettleFlag(Tags.OpenCloseSettleFlag, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OpenCloseSettleFlag); else fieldSet.Set(Tags.OpenCloseSettleFlag, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Day</para>
			/// <para>1 = Good Till Cancel (GTC)</para>
			/// <para>2 = At the Opening (OPG)</para>
			/// <para>3 = Immediate or Cancel (IOC)</para>
			/// <para>4 = Fill or Kill (FOK)</para>
			/// <para>5 = Good Till Crossing (GTX)</para>
			/// <para>6 = Good Till Date</para>
			/// <para>For optional use when this Bid or Offer represents an order</para>
			/// </summary>
			public TimeInForce? TimeInForce
			{
				get
				{
					TimeInForce v;
					if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
				}
			}

			/// <summary>
			/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
			/// <para>For optional use when this Bid or Offer represents an order. ExpireDate and ExpireTime cannot both be specified in one Market Data Entry.</para>
			/// </summary>
			public System.DateTime? ExpireDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// <para>For optional use when this Bid or Offer represents an order. ExpireDate and ExpireTime cannot both be specified in one Market Data Entry.</para>
			/// </summary>
			public System.DateTime? ExpireTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Minimum quantity of an order to be executed.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// <para>For optional use when this Bid or Offer represents an order</para>
			/// </summary>
			public System.Double? MinQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Not held</para>
			/// <para>2 = Work</para>
			/// <para>3 = Go along</para>
			/// <para>4 = Over the day</para>
			/// <para>5 = Held</para>
			/// <para>6 = Participate don't initiate</para>
			/// <para>7 = Strict scale</para>
			/// <para>8 = Try to scale</para>
			/// <para>9 = Stay on bidside</para>
			/// <para>0 = Stay on offerside</para>
			/// <para>A = No cross (cross is forbidden)</para>
			/// <para>B = OK to cross</para>
			/// <para>C = Call first</para>
			/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
			/// <para>E = Do not increase - DNI</para>
			/// <para>F = Do not reduce - DNR</para>
			/// <para>G = All or none - AON</para>
			/// <para>I = Institutions only</para>
			/// <para>L = Last peg (last sale)</para>
			/// <para>M = Mid-price peg (midprice of inside quote)</para>
			/// <para>N = Non-negotiable</para>
			/// <para>O = Opening peg</para>
			/// <para>P = Market peg</para>
			/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
			/// <para>S = Suspend</para>
			/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
			/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
			/// <para>V = Netting (for Forex)</para>
			/// <para>W = Peg to VWAP</para>
			/// <para>Can contain multiple instructions, space delimited.</para>
			/// </summary>
			public ExecInst? ExecInst
			{
				get
				{
					ExecInst v;
					if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the number of days that may elapse before delivery of the security</para>
			/// </summary>
			public System.String SellerDays
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SellerDays, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SellerDays); else fieldSet.Set(Tags.SellerDays, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
			/// <para>For optional use when this Bid, Offer, or Trade represents an order</para>
			/// </summary>
			public System.String OrderID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
				}
			}

			/// <summary>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>For optional use when this Bid, Offer, or Trade represents a quote</para>
			/// </summary>
			public System.String QuoteEntryID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.QuoteEntryID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteEntryID); else fieldSet.Set(Tags.QuoteEntryID, value);
				}
			}

			/// <summary>
			/// <para>Buying party in a trade</para>
			/// <para>For optional use in reporting Trades</para>
			/// </summary>
			public System.String MDEntryBuyer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryBuyer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryBuyer); else fieldSet.Set(Tags.MDEntryBuyer, value);
				}
			}

			/// <summary>
			/// <para>Selling party in a trade</para>
			/// <para>For optional use in reporting Trades</para>
			/// </summary>
			public System.String MDEntrySeller
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntrySeller, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntrySeller); else fieldSet.Set(Tags.MDEntrySeller, value);
				}
			}

			/// <summary>
			/// <para>Number of orders in the market.</para>
			/// <para>In an Aggregated Book, used to show how many individual orders make up an MDEntry</para>
			/// </summary>
			public System.String NumberOfOrders
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.NumberOfOrders, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.NumberOfOrders); else fieldSet.Set(Tags.NumberOfOrders, value);
				}
			}

			/// <summary>
			/// <para>Display position of a bid or offer, numbered from most competitive to least competitive, per market side, beginning with 1.</para>
			/// <para>Display position of a bid or offer, numbered from most competitive to least competitive, per market side, beginning with 1</para>
			/// </summary>
			public System.String MDEntryPositionNo
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryPositionNo, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryPositionNo); else fieldSet.Set(Tags.MDEntryPositionNo, value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// <para>Text to describe the Market Data Entry. Part of repeating group.</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of entries in Market Data message.</para>
			/// <para>Number of entries following.</para>
			/// </summary>
			internal MarketDataSnapshotFullRefreshNoMDEntriesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// MarketDataSnapshotFullRefreshNoMDEntriesInstance collection.
		/// </summary>
		#region MarketDataSnapshotFullRefreshNoMDEntriesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MarketDataSnapshotFullRefreshNoMDEntriesCollection : IEnumerable<MarketDataSnapshotFullRefreshNoMDEntriesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MarketDataSnapshotFullRefreshNoMDEntriesInstance> entries;

			internal MarketDataSnapshotFullRefreshNoMDEntriesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MarketDataSnapshotFullRefreshNoMDEntriesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MarketDataSnapshotFullRefreshNoMDEntriesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MarketDataSnapshotFullRefreshNoMDEntriesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MarketDataSnapshotFullRefreshNoMDEntriesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoMDEntries, 1);
				else
					parent.SetGroup(Tags.NoMDEntries, group.NumberOfInstances + 1);
				MarketDataSnapshotFullRefreshNoMDEntriesInstance text = new MarketDataSnapshotFullRefreshNoMDEntriesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoMDEntries, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoMDEntries, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MarketDataSnapshotFullRefreshNoMDEntriesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MarketDataSnapshotFullRefreshNoMDEntriesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MarketDataSnapshotFullRefreshNoMDEntriesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MarketDataSnapshotFullRefreshNoMDEntriesCollection
		/// <summary>
		/// <para>Number of entries in Market Data message.</para>
		/// <para>Number of entries following.</para>
		/// </summary>
		public class MarketDataIncrementalRefreshNoMDEntriesInstance
		{
			/// <summary>
			/// <para>Type of Market Data update action.</para>
			/// <para>Valid values:</para>
			/// <para>0 = New</para>
			/// <para>1 = Change</para>
			/// <para>2 = Delete</para>
			/// <para>Must be first field in this repeating group.</para>
			/// </summary>
			public MDUpdateAction MDUpdateAction
			{
				get
				{
					return fieldSet.GetMDUpdateAction(Tags.MDUpdateAction);
				}
				set
				{
					fieldSet.Set(Tags.MDUpdateAction, value);
				}
			}

			/// <summary>
			/// <para>Reason for deletion.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Cancelation / Trade Bust</para>
			/// <para>1 = Error</para>
			/// <para>If MDUpdateAction = Delete(2), can be used to specify a reason for the deletion.</para>
			/// </summary>
			public DeleteReason? DeleteReason
			{
				get
				{
					DeleteReason v;
					if (fieldSet.TryGetDeleteReason(Tags.DeleteReason, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.DeleteReason); else fieldSet.Set(Tags.DeleteReason, value.Value);
				}
			}

			/// <summary>
			/// <para>Type Market Data entry.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Bid</para>
			/// <para>1 = Offer</para>
			/// <para>2 = Trade</para>
			/// <para>3 = Index Value</para>
			/// <para>4 = Opening Price</para>
			/// <para>5 = Closing Price</para>
			/// <para>6 = Settlement Price</para>
			/// <para>7 = Trading Session High Price</para>
			/// <para>8 = Trading Session Low Price</para>
			/// <para>9 = Trading Session VWAP Price</para>
			/// <para>Conditionally required if MDUpdateAction = New(0). Cannot be changed.</para>
			/// </summary>
			public MDEntryType? MDEntryType
			{
				get
				{
					MDEntryType v;
					if (fieldSet.TryGetMDEntryType(Tags.MDEntryType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryType); else fieldSet.Set(Tags.MDEntryType, value.Value);
				}
			}

			/// <summary>
			/// <para>Unique Market Data Entry identifier.</para>
			/// <para>If specified, must be unique among currently active entries if MDUpdateAction = New (0), must be the same as a previous MDEntryID if MDUpdateAction = Delete (2), and must be the same as a previous MDEntryID if MDUpdateAction = Change (1) and MDEntryRefID is not specified, or must be unique among currently active entries if MDUpdateAction = Change(1) and MDEntryRefID is specified..</para>
			/// </summary>
			public System.String MDEntryID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryID); else fieldSet.Set(Tags.MDEntryID, value);
				}
			}

			/// <summary>
			/// <para>Refers to a previous MDEntryID.</para>
			/// <para>If MDUpdateAction = New(0), for the first Market Data Entry in a message, either this field or a Symbol must be specified. If MDUpdateAction = Change(1), this must refer to a previous MDEntryID.</para>
			/// </summary>
			public System.String MDEntryRefID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryRefID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryRefID); else fieldSet.Set(Tags.MDEntryRefID, value);
				}
			}

			/// <summary>
			/// <para>Ticker symbol</para>
			/// <para>Either Symbol or MDEntryRefID must be specified if MDUpdateAction = New(0) for the first Market Data Entry in a message. For subsequent Market Data Entries where MDUpdateAction = New(0), the default is the instrument used in the previous Market Data Entry if neither Symbol nor MDEntryRefID are specified, or in the case of options and futures, the previous instrument with changes specified in MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange. May not be changed.</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Symbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Symbol); else fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>May not be changed.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>May not be changed.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>May not be changed.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required. May not be changed.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified. May not be changed.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date. May not be changed.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options. May not be changed.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options. May not be changed.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options. May not be changed.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security. May not be changed.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>May not be changed.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>May not be changed.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Identifies a firm's financial status.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Bankrupt</para>
			/// </summary>
			public FinancialStatus? FinancialStatus
			{
				get
				{
					FinancialStatus v;
					if (fieldSet.TryGetFinancialStatus(Tags.FinancialStatus, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FinancialStatus); else fieldSet.Set(Tags.FinancialStatus, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifies the type of Corporate Action.</para>
			/// <para>Valid values:</para>
			/// <para>A = Ex-Dividend</para>
			/// <para>B = Ex-Distribution</para>
			/// <para>C = Ex-Rights</para>
			/// <para>D = New</para>
			/// <para>E = Ex-Interest</para>
			/// </summary>
			public CorporateAction? CorporateAction
			{
				get
				{
					CorporateAction v;
					if (fieldSet.TryGetCorporateAction(Tags.CorporateAction, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CorporateAction); else fieldSet.Set(Tags.CorporateAction, value.Value);
				}
			}

			/// <summary>
			/// <para>Price of the Market Data Entry.</para>
			/// <para>Conditionally required when MDUpdateAction = New(0).</para>
			/// </summary>
			public System.Double? MDEntryPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MDEntryPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryPx); else fieldSet.Set(Tags.MDEntryPx, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// <para>Can be used to specify the currency of the quoted price.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			/// <summary>
			/// <para>Number of shares represented by the Market Data Entry.</para>
			/// <para>Conditionally required when MDUpdateAction = New(0) andMDEntryType = Bid(0), Offer(1), or Trade(2).</para>
			/// </summary>
			public System.Double? MDEntrySize
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MDEntrySize, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntrySize); else fieldSet.Set(Tags.MDEntrySize, value.Value);
				}
			}

			/// <summary>
			/// <para>Date of Market Data Entry.</para>
			/// </summary>
			public System.String MDEntryDate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryDate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryDate); else fieldSet.Set(Tags.MDEntryDate, value);
				}
			}

			/// <summary>
			/// <para>Time of Market Data Entry.</para>
			/// </summary>
			public System.TimeSpan? MDEntryTime
			{
				get
				{
					System.TimeSpan v;
					if (fieldSet.TryGetValue(Tags.MDEntryTime, "UTCTimeOnly", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryTime); else fieldSet.Set(Tags.MDEntryTime, "UTCTimeOnly", value.Value);
				}
			}

			/// <summary>
			/// <para>Direction of the "tick".</para>
			/// <para>Valid values:</para>
			/// <para>0 = Plus Tick</para>
			/// <para>1 = Zero-Plus Tick</para>
			/// <para>2 = Minus Tick</para>
			/// <para>3 = Zero-Minus Tick</para>
			/// </summary>
			public TickDirection? TickDirection
			{
				get
				{
					TickDirection v;
					if (fieldSet.TryGetTickDirection(Tags.TickDirection, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TickDirection); else fieldSet.Set(Tags.TickDirection, value.Value);
				}
			}

			/// <summary>
			/// <para>Market posting quote / trade.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Market posting quote / trade. Valid values:</para>
			/// <para>See Appendix C</para>
			/// </summary>
			public System.String MDMkt
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDMkt, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDMkt); else fieldSet.Set(Tags.MDMkt, value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Space-delimited list of conditions describing a quote.</para>
			/// <para>Valid values:</para>
			/// <para>A = Open / Active</para>
			/// <para>B = Closed / Inactive</para>
			/// <para>C = Exchange Best</para>
			/// <para>D = Consolidated Best</para>
			/// <para>E = Locked</para>
			/// <para>F = Crossed</para>
			/// <para>G = Depth</para>
			/// <para>H = Fast Trading</para>
			/// <para>I = Non-Firm</para>
			/// <para>Space-delimited list of conditions describing a quote.</para>
			/// </summary>
			public QuoteCondition? QuoteCondition
			{
				get
				{
					QuoteCondition v;
					if (fieldSet.TryGetQuoteCondition(Tags.QuoteCondition, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteCondition); else fieldSet.Set(Tags.QuoteCondition, value.Value);
				}
			}

			/// <summary>
			/// <para>Space-delimited list of conditions describing a trade</para>
			/// <para>Valid values:</para>
			/// <para>A = Cash (only) Market</para>
			/// <para>B = Average Price Trade</para>
			/// <para>C = Cash Trade (same day clearing)</para>
			/// <para>D = Next Day (only) Market</para>
			/// <para>E = Opening / Reopening Trade Detail</para>
			/// <para>F = Intraday Trade Detail</para>
			/// <para>G = Rule 127 Trade (NYSE)</para>
			/// <para>H = Rule 155 Trade (Amex)</para>
			/// <para>I = Sold Last (late reporting)</para>
			/// <para>J = Next Day Trade (next day clearing)</para>
			/// <para>K = Opened (late report of opened trade)</para>
			/// <para>L = Seller</para>
			/// <para>M = Sold (out of sequence)</para>
			/// <para>N = Stopped Stock (guarantee of price but does not execute the order)</para>
			/// <para>Space-delimited list of conditions describing a trade</para>
			/// </summary>
			public TradeCondition? TradeCondition
			{
				get
				{
					TradeCondition v;
					if (fieldSet.TryGetTradeCondition(Tags.TradeCondition, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradeCondition); else fieldSet.Set(Tags.TradeCondition, value.Value);
				}
			}

			/// <summary>
			/// <para>Originator of a Market Data Entry</para>
			/// </summary>
			public System.String MDEntryOriginator
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryOriginator, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryOriginator); else fieldSet.Set(Tags.MDEntryOriginator, value);
				}
			}

			/// <summary>
			/// <para>Identification of a Market Maker's location</para>
			/// </summary>
			public System.String LocationID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.LocationID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LocationID); else fieldSet.Set(Tags.LocationID, value);
				}
			}

			/// <summary>
			/// <para>Identification of a Market Maker's desk</para>
			/// </summary>
			public System.String DeskID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.DeskID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.DeskID); else fieldSet.Set(Tags.DeskID, value);
				}
			}

			/// <summary>
			/// <para>Flag that identifies a price.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Daily Open / Close / Settlement price</para>
			/// <para>1 = Session Open / Close / Settlement price</para>
			/// <para>2 = Delivery Settlement price</para>
			/// <para>Used if MDEntryType = Opening Price(4), Closing Price(5), or Settlement Price(6).</para>
			/// </summary>
			public OpenCloseSettleFlag? OpenCloseSettleFlag
			{
				get
				{
					OpenCloseSettleFlag v;
					if (fieldSet.TryGetOpenCloseSettleFlag(Tags.OpenCloseSettleFlag, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OpenCloseSettleFlag); else fieldSet.Set(Tags.OpenCloseSettleFlag, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Day</para>
			/// <para>1 = Good Till Cancel (GTC)</para>
			/// <para>2 = At the Opening (OPG)</para>
			/// <para>3 = Immediate or Cancel (IOC)</para>
			/// <para>4 = Fill or Kill (FOK)</para>
			/// <para>5 = Good Till Crossing (GTX)</para>
			/// <para>6 = Good Till Date</para>
			/// <para>For optional use when this Bid or Offer represents an order</para>
			/// </summary>
			public TimeInForce? TimeInForce
			{
				get
				{
					TimeInForce v;
					if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
				}
			}

			/// <summary>
			/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
			/// <para>For optional use when this Bid or Offer represents an order. ExpireDate and ExpireTime cannot both be specified in one Market Data Entry.</para>
			/// </summary>
			public System.DateTime? ExpireDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// <para>For optional use when this Bid or Offer represents an order. ExpireDate and ExpireTime cannot both be specified in one Market Data Entry.</para>
			/// </summary>
			public System.DateTime? ExpireTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Minimum quantity of an order to be executed.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// <para>For optional use when this Bid or Offer represents an order</para>
			/// </summary>
			public System.Double? MinQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Not held</para>
			/// <para>2 = Work</para>
			/// <para>3 = Go along</para>
			/// <para>4 = Over the day</para>
			/// <para>5 = Held</para>
			/// <para>6 = Participate don't initiate</para>
			/// <para>7 = Strict scale</para>
			/// <para>8 = Try to scale</para>
			/// <para>9 = Stay on bidside</para>
			/// <para>0 = Stay on offerside</para>
			/// <para>A = No cross (cross is forbidden)</para>
			/// <para>B = OK to cross</para>
			/// <para>C = Call first</para>
			/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
			/// <para>E = Do not increase - DNI</para>
			/// <para>F = Do not reduce - DNR</para>
			/// <para>G = All or none - AON</para>
			/// <para>I = Institutions only</para>
			/// <para>L = Last peg (last sale)</para>
			/// <para>M = Mid-price peg (midprice of inside quote)</para>
			/// <para>N = Non-negotiable</para>
			/// <para>O = Opening peg</para>
			/// <para>P = Market peg</para>
			/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
			/// <para>S = Suspend</para>
			/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
			/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
			/// <para>V = Netting (for Forex)</para>
			/// <para>W = Peg to VWAP</para>
			/// <para>Can contain multiple instructions, space delimited.</para>
			/// </summary>
			public ExecInst? ExecInst
			{
				get
				{
					ExecInst v;
					if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the number of days that may elapse before delivery of the security</para>
			/// </summary>
			public System.String SellerDays
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SellerDays, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SellerDays); else fieldSet.Set(Tags.SellerDays, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
			/// <para>For optional use when this Bid, Offer, or Trade represents an order</para>
			/// </summary>
			public System.String OrderID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
				}
			}

			/// <summary>
			/// <para>Uniquely identifies the quote as part of a QuoteSet.</para>
			/// <para>For optional use when this Bid, Offer, or Trade represents a quote</para>
			/// </summary>
			public System.String QuoteEntryID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.QuoteEntryID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteEntryID); else fieldSet.Set(Tags.QuoteEntryID, value);
				}
			}

			/// <summary>
			/// <para>Buying party in a trade</para>
			/// <para>For optional use in reporting Trades</para>
			/// </summary>
			public System.String MDEntryBuyer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryBuyer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryBuyer); else fieldSet.Set(Tags.MDEntryBuyer, value);
				}
			}

			/// <summary>
			/// <para>Selling party in a trade</para>
			/// <para>For optional use in reporting Trades</para>
			/// </summary>
			public System.String MDEntrySeller
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntrySeller, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntrySeller); else fieldSet.Set(Tags.MDEntrySeller, value);
				}
			}

			/// <summary>
			/// <para>Number of orders in the market.</para>
			/// <para>In an Aggregated Book, used to show how many individual orders make up an MDEntry</para>
			/// </summary>
			public System.String NumberOfOrders
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.NumberOfOrders, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.NumberOfOrders); else fieldSet.Set(Tags.NumberOfOrders, value);
				}
			}

			/// <summary>
			/// <para>Display position of a bid or offer, numbered from most competitive to least competitive, per market side, beginning with 1.</para>
			/// <para>Display position of a bid or offer, numbered from most competitive to least competitive, per market side, beginning with 1</para>
			/// </summary>
			public System.String MDEntryPositionNo
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MDEntryPositionNo, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MDEntryPositionNo); else fieldSet.Set(Tags.MDEntryPositionNo, value);
				}
			}

			/// <summary>
			/// <para>Total volume (quantity) traded.</para>
			/// <para>Total volume traded in this trading session for this security.</para>
			/// </summary>
			public System.Double? TotalVolumeTraded
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.TotalVolumeTraded, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TotalVolumeTraded); else fieldSet.Set(Tags.TotalVolumeTraded, value.Value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// <para>Text to describe the Market Data Entry. Part of repeating group.</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of entries in Market Data message.</para>
			/// <para>Number of entries following.</para>
			/// </summary>
			internal MarketDataIncrementalRefreshNoMDEntriesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// MarketDataIncrementalRefreshNoMDEntriesInstance collection.
		/// </summary>
		#region MarketDataIncrementalRefreshNoMDEntriesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class MarketDataIncrementalRefreshNoMDEntriesCollection : IEnumerable<MarketDataIncrementalRefreshNoMDEntriesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<MarketDataIncrementalRefreshNoMDEntriesInstance> entries;

			internal MarketDataIncrementalRefreshNoMDEntriesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<MarketDataIncrementalRefreshNoMDEntriesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new MarketDataIncrementalRefreshNoMDEntriesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public MarketDataIncrementalRefreshNoMDEntriesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public MarketDataIncrementalRefreshNoMDEntriesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoMDEntries, 1);
				else
					parent.SetGroup(Tags.NoMDEntries, group.NumberOfInstances + 1);
				MarketDataIncrementalRefreshNoMDEntriesInstance text = new MarketDataIncrementalRefreshNoMDEntriesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoMDEntries, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoMDEntries, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(MarketDataIncrementalRefreshNoMDEntriesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<MarketDataIncrementalRefreshNoMDEntriesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<MarketDataIncrementalRefreshNoMDEntriesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion MarketDataIncrementalRefreshNoMDEntriesCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Number of legs that make up the Security</para>
		/// </summary>
		public class SecurityDefinitionRequestNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Underlying security's Symbol.</para>
			/// <para>See Symbol field for description</para>
			/// <para>The UnderlyingSymbol must be specified as the first field in the repeating group.</para>
			/// <para>Required if NoRelatedSym &gt; 0.</para>
			/// </summary>
			public System.String UnderlyingSymbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbol); else fieldSet.Set(Tags.UnderlyingSymbol, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SymbolSfx.</para>
			/// <para>See SymbolSfx field for description</para>
			/// </summary>
			public System.String UnderlyingSymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbolSfx); else fieldSet.Set(Tags.UnderlyingSymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityID.</para>
			/// <para>See SecurityID field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityID); else fieldSet.Set(Tags.UnderlyingSecurityID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's IDSource.</para>
			/// <para>Valid values: see IDSource field</para>
			/// </summary>
			public System.String UnderlyingIDSource
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIDSource); else fieldSet.Set(Tags.UnderlyingIDSource, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityType.</para>
			/// <para>Valid values: see SecurityType field</para>
			/// <para>Must be specified if a Future or Option. If a Future: UnderlyingSymbol, UnderlyingSecurityType, and UnderlyingMaturityMonthYear are required. If an Option: UnderlyingSymbol, UnderlyingSecurityType, UnderlyingMaturityMonthYear, UnderlyingPutOrCall, and UnderlyingStrikePrice are required.</para>
			/// </summary>
			public System.String UnderlyingSecurityType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityType); else fieldSet.Set(Tags.UnderlyingSecurityType, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityMonthYear. Required if UnderlyingMaturityDay is specified.</para>
			/// <para>See MaturityMonthYear field for description</para>
			/// <para>Specifiesthe month and year of maturity. Required if UnderlyingMaturityDay is specified.</para>
			/// </summary>
			public System.String UnderlyingMaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityMonthYear); else fieldSet.Set(Tags.UnderlyingMaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityDay.</para>
			/// <para>See MaturityDay field for description</para>
			/// <para>Can be used in conjunction with UnderlyingMaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? UnderlyingMaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityDay); else fieldSet.Set(Tags.UnderlyingMaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's PutOrCall.</para>
			/// <para>See PutOrCall field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.String UnderlyingPutOrCall
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingPutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingPutOrCall); else fieldSet.Set(Tags.UnderlyingPutOrCall, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's StrikePrice.</para>
			/// <para>See StrikePrice field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? UnderlyingStrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.UnderlyingStrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingStrikePrice); else fieldSet.Set(Tags.UnderlyingStrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's OptAttribute.</para>
			/// <para>See OptAttribute field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? UnderlyingOptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.UnderlyingOptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingOptAttribute); else fieldSet.Set(Tags.UnderlyingOptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's ContractMultiplier.</para>
			/// <para>See ContractMultiplier field for description</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc.</para>
			/// </summary>
			public System.String UnderlyingContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingContractMultiplier); else fieldSet.Set(Tags.UnderlyingContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's CouponRate.</para>
			/// <para>See CouponRate field for description</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String UnderlyingCouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCouponRate); else fieldSet.Set(Tags.UnderlyingCouponRate, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityExchange. Can be used to identify the underlying security.</para>
			/// <para>Valid values: see SecurityExchange</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String UnderlyingSecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityExchange); else fieldSet.Set(Tags.UnderlyingSecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Issuer.</para>
			/// <para>See Issuer field for description</para>
			/// </summary>
			public System.String UnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIssuer); else fieldSet.Set(Tags.UnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingIssuer field.</para>
			/// <para>Must be set if EncodedUnderlyingIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuerLen); else fieldSet.Set(Tags.EncodedUnderlyingIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingIssuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuer); else fieldSet.Set(Tags.EncodedUnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityDesc.</para>
			/// <para>See SecurityDesc field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityDesc); else fieldSet.Set(Tags.UnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingSecurityDesc field.</para>
			/// <para>Must be set if EncodedUnderlyingSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDescLen); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingSecurityeDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDesc); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Quantity of a particular leg in the security.</para>
			/// <para>Quantity of particular leg in the Security</para>
			/// </summary>
			public System.String RatioQty
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RatioQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RatioQty); else fieldSet.Set(Tags.RatioQty, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>Indicates if this leg of the security is to be Bought or Sold as part of this complex security.</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Currency.</para>
			/// <para>See Currency field for description and valid values</para>
			/// </summary>
			public System.String UnderlyingCurrency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCurrency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCurrency); else fieldSet.Set(Tags.UnderlyingCurrency, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Number of legs that make up the Security</para>
			/// </summary>
			internal SecurityDefinitionRequestNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// SecurityDefinitionRequestNoRelatedSymInstance collection.
		/// </summary>
		#region SecurityDefinitionRequestNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class SecurityDefinitionRequestNoRelatedSymCollection : IEnumerable<SecurityDefinitionRequestNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<SecurityDefinitionRequestNoRelatedSymInstance> entries;

			internal SecurityDefinitionRequestNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<SecurityDefinitionRequestNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new SecurityDefinitionRequestNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public SecurityDefinitionRequestNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public SecurityDefinitionRequestNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				SecurityDefinitionRequestNoRelatedSymInstance text = new SecurityDefinitionRequestNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(SecurityDefinitionRequestNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<SecurityDefinitionRequestNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<SecurityDefinitionRequestNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion SecurityDefinitionRequestNoRelatedSymCollection
		/// <summary>
		/// <para>Specifies the number of repeating symbols specified.</para>
		/// <para>Number of legs that make up the Security</para>
		/// </summary>
		public class SecurityDefinitionNoRelatedSymInstance
		{
			/// <summary>
			/// <para>Underlying security's Symbol.</para>
			/// <para>See Symbol field for description</para>
			/// <para>Must be specified as the first field in the repeating group. Required if NoRelatedSym &gt; 0.</para>
			/// </summary>
			public System.String UnderlyingSymbol
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbol, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbol); else fieldSet.Set(Tags.UnderlyingSymbol, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SymbolSfx.</para>
			/// <para>See SymbolSfx field for description</para>
			/// </summary>
			public System.String UnderlyingSymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSymbolSfx); else fieldSet.Set(Tags.UnderlyingSymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityID.</para>
			/// <para>See SecurityID field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityID); else fieldSet.Set(Tags.UnderlyingSecurityID, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's IDSource.</para>
			/// <para>Valid values: see IDSource field</para>
			/// </summary>
			public System.String UnderlyingIDSource
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIDSource); else fieldSet.Set(Tags.UnderlyingIDSource, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityType.</para>
			/// <para>Valid values: see SecurityType field</para>
			/// <para>Must be specified if a Future or Option. If a Future: UnderlyingSymbol, UnderlyingSecurityType, and UnderlyingMaturityMonthYear are required. If an Option: UnderlyingSymbol, UnderlyingSecurityType, UnderlyingMaturityMonthYear, PutOrCall, and UnderlyingStrikePrice are required.</para>
			/// </summary>
			public System.String UnderlyingSecurityType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityType); else fieldSet.Set(Tags.UnderlyingSecurityType, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityMonthYear. Required if UnderlyingMaturityDay is specified.</para>
			/// <para>See MaturityMonthYear field for description</para>
			/// <para>Specifiesthe month and year of maturity. Required if UnderlyingMaturityDay is specified.</para>
			/// </summary>
			public System.String UnderlyingMaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityMonthYear); else fieldSet.Set(Tags.UnderlyingMaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's MaturityDay.</para>
			/// <para>See MaturityDay field for description</para>
			/// <para>Can be used in conjunction with UnderlyingMaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? UnderlyingMaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.UnderlyingMaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingMaturityDay); else fieldSet.Set(Tags.UnderlyingMaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's PutOrCall.</para>
			/// <para>See PutOrCall field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.String UnderlyingPutOrCall
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingPutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingPutOrCall); else fieldSet.Set(Tags.UnderlyingPutOrCall, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's StrikePrice.</para>
			/// <para>See StrikePrice field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? UnderlyingStrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.UnderlyingStrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingStrikePrice); else fieldSet.Set(Tags.UnderlyingStrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's OptAttribute.</para>
			/// <para>See OptAttribute field for description</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? UnderlyingOptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.UnderlyingOptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingOptAttribute); else fieldSet.Set(Tags.UnderlyingOptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's ContractMultiplier.</para>
			/// <para>See ContractMultiplier field for description</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc.</para>
			/// </summary>
			public System.String UnderlyingContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingContractMultiplier); else fieldSet.Set(Tags.UnderlyingContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's CouponRate.</para>
			/// <para>See CouponRate field for description</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String UnderlyingCouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCouponRate); else fieldSet.Set(Tags.UnderlyingCouponRate, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityExchange. Can be used to identify the underlying security.</para>
			/// <para>Valid values: see SecurityExchange</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String UnderlyingSecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityExchange); else fieldSet.Set(Tags.UnderlyingSecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Issuer.</para>
			/// <para>See Issuer field for description</para>
			/// </summary>
			public System.String UnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingIssuer); else fieldSet.Set(Tags.UnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingIssuer field.</para>
			/// <para>Must be set if EncodedUnderlyingIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuerLen); else fieldSet.Set(Tags.EncodedUnderlyingIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingIssuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingIssuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingIssuer); else fieldSet.Set(Tags.EncodedUnderlyingIssuer, value);
				}
			}

			/// <summary>
			/// <para>Underlying security's SecurityDesc.</para>
			/// <para>See SecurityDesc field for description</para>
			/// </summary>
			public System.String UnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingSecurityDesc); else fieldSet.Set(Tags.UnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedUnderlyingSecurityDesc field.</para>
			/// <para>Must be set if EncodedUnderlyingSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedUnderlyingSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDescLen); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the UnderlyingSecurityeDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the UnderlyingSecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedUnderlyingSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedUnderlyingSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedUnderlyingSecurityDesc); else fieldSet.Set(Tags.EncodedUnderlyingSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Quantity of a particular leg in the security.</para>
			/// <para>Quantity of particular leg in the Security</para>
			/// </summary>
			public System.String RatioQty
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RatioQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RatioQty); else fieldSet.Set(Tags.RatioQty, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>Indicates if this leg of the security is to be Bought or Sold as part of this complex security.</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Underlying security's Currency.</para>
			/// <para>See Currency field for description and valid values</para>
			/// </summary>
			public System.String UnderlyingCurrency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.UnderlyingCurrency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.UnderlyingCurrency); else fieldSet.Set(Tags.UnderlyingCurrency, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Specifies the number of repeating symbols specified.</para>
			/// <para>Number of legs that make up the Security</para>
			/// </summary>
			internal SecurityDefinitionNoRelatedSymInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// SecurityDefinitionNoRelatedSymInstance collection.
		/// </summary>
		#region SecurityDefinitionNoRelatedSymCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class SecurityDefinitionNoRelatedSymCollection : IEnumerable<SecurityDefinitionNoRelatedSymInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<SecurityDefinitionNoRelatedSymInstance> entries;

			internal SecurityDefinitionNoRelatedSymCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<SecurityDefinitionNoRelatedSymInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new SecurityDefinitionNoRelatedSymInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public SecurityDefinitionNoRelatedSymInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public SecurityDefinitionNoRelatedSymInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoRelatedSym, 1);
				else
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances + 1);
				SecurityDefinitionNoRelatedSymInstance text = new SecurityDefinitionNoRelatedSymInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoRelatedSym, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoRelatedSym, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(SecurityDefinitionNoRelatedSymInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<SecurityDefinitionNoRelatedSymInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<SecurityDefinitionNoRelatedSymInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion SecurityDefinitionNoRelatedSymCollection
		/// <summary>
		/// <para>Number of BidDescriptor entries.</para>
		/// <para>Used if BidType='Non Disclosed'</para>
		/// </summary>
		public class BidRequestNoBidDescriptorsInstance
		{
			/// <summary>
			/// <para>Code to identify the type of BidDescriptor.</para>
			/// <para>Valid values:</para>
			/// <para>1 - Sector</para>
			/// <para>2 - Country</para>
			/// <para>3 - Index</para>
			/// <para>Required if NoBidDescriptors &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String BidDescriptorType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.BidDescriptorType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidDescriptorType); else fieldSet.Set(Tags.BidDescriptorType, value);
				}
			}

			/// <summary>
			/// <para>BidDescriptor value. Usage depends upon BidDescriptorType.</para>
			/// <para>If BidDescriptorType =1</para>
			/// <para>Industrials etc - Free text</para>
			/// <para>If BidDescriptorType =2</para>
			/// <para>"FR" etc - ISO Country Codes</para>
			/// <para>If BidDescriptorType =3</para>
			/// <para>FT100, FT250, STOX - Free text</para>
			/// </summary>
			public System.String BidDescriptor
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.BidDescriptor, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BidDescriptor); else fieldSet.Set(Tags.BidDescriptor, value);
				}
			}

			/// <summary>
			/// <para>Code to identify which "SideValue" the value refers to. SideValue1 and SideValue2 are used as opposed to Buy or Sell so that the basket can be quoted either way as Buy or Sell.</para>
			/// <para>Valid values:</para>
			/// <para>1 - SideValue1</para>
			/// <para>2 - SideValue 2</para>
			/// <para>Refers to the SideValue1 or SideValue2. These are used as opposed to Buy or Sell so that the basket can be quoted either way as Buy or Sell.</para>
			/// </summary>
			public System.String SideValueInd
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SideValueInd, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SideValueInd); else fieldSet.Set(Tags.SideValueInd, value);
				}
			}

			/// <summary>
			/// <para>Value between LiquidityPctLow and LiquidityPctHigh in Currency</para>
			/// <para>Value between LiquidityPctLow and LiquidityPctHigh in Currency</para>
			/// </summary>
			public System.Double? LiquidityValue
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.LiquidityValue, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LiquidityValue); else fieldSet.Set(Tags.LiquidityValue, value.Value);
				}
			}

			/// <summary>
			/// <para>Number of Securites between LiquidityPctLow and LiquidityPctHigh in Currency.</para>
			/// <para>Number of Securites between LiquidityPctLow and LiquidityPctHigh in Currency</para>
			/// </summary>
			public System.String LiquidityNumSecurities
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.LiquidityNumSecurities, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LiquidityNumSecurities); else fieldSet.Set(Tags.LiquidityNumSecurities, value);
				}
			}

			/// <summary>
			/// <para>Liquidity indicator or lower limit if TotalNumSecurities &gt; 1. Represented as a percentage.</para>
			/// <para>Liquidity indicator or lower limit if LiquidityNumSecurities &gt; 1</para>
			/// </summary>
			public System.String LiquidityPctLow
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.LiquidityPctLow, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LiquidityPctLow); else fieldSet.Set(Tags.LiquidityPctLow, value);
				}
			}

			/// <summary>
			/// <para>Upper liquidity indicator if TotalNumSecurities &gt; 1. Represented as a percentage.</para>
			/// <para>Upper liquidity indicator if LiquidityNumSecurities &gt; 1</para>
			/// </summary>
			public System.String LiquidityPctHigh
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.LiquidityPctHigh, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LiquidityPctHigh); else fieldSet.Set(Tags.LiquidityPctHigh, value);
				}
			}

			/// <summary>
			/// <para>Eg Used in EFP trades 12% (EFP - Exchange for Physical ). Represented as a percentage.</para>
			/// <para>Eg Used in EFP (Exchange For Physical) trades 12%</para>
			/// </summary>
			public System.String EFPTrackingError
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EFPTrackingError, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EFPTrackingError); else fieldSet.Set(Tags.EFPTrackingError, value);
				}
			}

			/// <summary>
			/// <para>Used in EFP trades</para>
			/// <para>Used in EFP trades</para>
			/// </summary>
			public System.Double? FairValue
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.FairValue, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FairValue); else fieldSet.Set(Tags.FairValue, value.Value);
				}
			}

			/// <summary>
			/// <para>Used in EFP trades. Represented as a percentage.</para>
			/// <para>Used in EFP trades</para>
			/// </summary>
			public System.String OutsideIndexPct
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.OutsideIndexPct, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OutsideIndexPct); else fieldSet.Set(Tags.OutsideIndexPct, value);
				}
			}

			/// <summary>
			/// <para>Used in EFP trades</para>
			/// <para>Used in EFP trades</para>
			/// </summary>
			public System.Double? ValueOfFutures
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.ValueOfFutures, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ValueOfFutures); else fieldSet.Set(Tags.ValueOfFutures, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of BidDescriptor entries.</para>
			/// <para>Used if BidType='Non Disclosed'</para>
			/// </summary>
			internal BidRequestNoBidDescriptorsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// BidRequestNoBidDescriptorsInstance collection.
		/// </summary>
		#region BidRequestNoBidDescriptorsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class BidRequestNoBidDescriptorsCollection : IEnumerable<BidRequestNoBidDescriptorsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<BidRequestNoBidDescriptorsInstance> entries;

			internal BidRequestNoBidDescriptorsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<BidRequestNoBidDescriptorsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new BidRequestNoBidDescriptorsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public BidRequestNoBidDescriptorsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public BidRequestNoBidDescriptorsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoBidDescriptors, 1);
				else
					parent.SetGroup(Tags.NoBidDescriptors, group.NumberOfInstances + 1);
				BidRequestNoBidDescriptorsInstance text = new BidRequestNoBidDescriptorsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoBidDescriptors, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoBidDescriptors, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(BidRequestNoBidDescriptorsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<BidRequestNoBidDescriptorsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<BidRequestNoBidDescriptorsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion BidRequestNoBidDescriptorsCollection
		/// <summary>
		/// <para>Indicates the number of list entries.</para>
		/// <para>Used if BidType='Disclosed'</para>
		/// </summary>
		public class BidRequestNoBidComponentsInstance
		{
			/// <summary>
			/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
			/// <para>Required if NoBidComponents &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String ListID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>When used in request for a 'Disclosed' bid indicates that bid is required on assumption that SideValue1 is Buy or Sell. SideValue2 can be derived by inference.</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// <para>Indicates off-exchange type activities for Detail.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Code to represent whether value is net (inclusive of tax) or gross.</para>
			/// <para>Valid values:</para>
			/// <para>1 - Net</para>
			/// <para>2 - Gross</para>
			/// <para>Indicates Net or Gross for selling Detail.</para>
			/// </summary>
			public NetGrossInd? NetGrossInd
			{
				get
				{
					NetGrossInd v;
					if (fieldSet.TryGetNetGrossInd(Tags.NetGrossInd, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.NetGrossInd); else fieldSet.Set(Tags.NetGrossInd, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Regular</para>
			/// <para>1 = Cash</para>
			/// <para>2 = Next Day</para>
			/// <para>3 = T+2</para>
			/// <para>4 = T+3</para>
			/// <para>5 = T+4</para>
			/// <para>6 = Future</para>
			/// <para>7 = When Issued</para>
			/// <para>8 = Sellers Option</para>
			/// <para>9 = T+ 5</para>
			/// <para>Indicates order settlement period for Detail.</para>
			/// </summary>
			public SettlmntTyp? SettlmntTyp
			{
				get
				{
					SettlmntTyp v;
					if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
				}
			}

			/// <summary>
			/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
			/// </summary>
			public System.DateTime? FutSettDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Account mnemonic as agreed between broker and institution.</para>
			/// </summary>
			public System.String Account
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Indicates the number of list entries.</para>
			/// <para>Used if BidType='Disclosed'</para>
			/// </summary>
			internal BidRequestNoBidComponentsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// BidRequestNoBidComponentsInstance collection.
		/// </summary>
		#region BidRequestNoBidComponentsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class BidRequestNoBidComponentsCollection : IEnumerable<BidRequestNoBidComponentsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<BidRequestNoBidComponentsInstance> entries;

			internal BidRequestNoBidComponentsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<BidRequestNoBidComponentsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new BidRequestNoBidComponentsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public BidRequestNoBidComponentsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public BidRequestNoBidComponentsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoBidComponents, 1);
				else
					parent.SetGroup(Tags.NoBidComponents, group.NumberOfInstances + 1);
				BidRequestNoBidComponentsInstance text = new BidRequestNoBidComponentsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoBidComponents, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoBidComponents, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(BidRequestNoBidComponentsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<BidRequestNoBidComponentsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<BidRequestNoBidComponentsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion BidRequestNoBidComponentsCollection
		/// <summary>
		/// <para>Indicates the number of list entries.</para>
		/// <para>Number of bid repeating groups</para>
		/// </summary>
		public class BidResponseNoBidComponentsInstance
		{
			/// <summary>
			/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
			/// <para>First element of price. Required if NoBidComponents &gt; 0.</para>
			/// </summary>
			public System.Double Commission
			{
				get
				{
					return fieldSet.GetDouble(Tags.Commission);
				}
				set
				{
					fieldSet.Set(Tags.Commission, value);
				}
			}

			/// <summary>
			/// <para>Commission type</para>
			/// <para>Valid values:</para>
			/// <para>1 = per share</para>
			/// <para>2 = percentage</para>
			/// <para>3 = absolute</para>
			/// </summary>
			public CommType CommType
			{
				get
				{
					return fieldSet.GetCommType(Tags.CommType);
				}
				set
				{
					fieldSet.Set(Tags.CommType, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
			/// </summary>
			public System.String ListID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
				}
			}

			/// <summary>
			/// <para>ISO Country Code in field</para>
			/// <para>ISO Country Code</para>
			/// </summary>
			public System.String Country
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Country, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Country); else fieldSet.Set(Tags.Country, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>When used in response to a 'Disclosed' request indicates whether SideValue1 is Buy or Sell. SideValue2 can be derived by inference.</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Price per share</para>
			/// <para>Second element of price</para>
			/// </summary>
			public System.Double? Price
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
				}
			}

			/// <summary>
			/// <para>Code to represent the price type.</para>
			/// <para>Valid values:</para>
			/// <para>1 - Percentage</para>
			/// <para>2 - per share (e.g. cents per share)</para>
			/// <para>3 - Fixed Amount (absolute value)</para>
			/// </summary>
			public PriceType? PriceType
			{
				get
				{
					PriceType v;
					if (fieldSet.TryGetPriceType(Tags.PriceType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PriceType); else fieldSet.Set(Tags.PriceType, value.Value);
				}
			}

			/// <summary>
			/// <para>Used in EFP trades</para>
			/// <para>The difference between the value of a future and the value of the underlying equities after allowing for the discounted cash flows associated with the underlying stocks (E.g. Dividends etc).</para>
			/// </summary>
			public System.Double? FairValue
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.FairValue, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FairValue); else fieldSet.Set(Tags.FairValue, value.Value);
				}
			}

			/// <summary>
			/// <para>Code to represent whether value is net (inclusive of tax) or gross.</para>
			/// <para>Valid values:</para>
			/// <para>1 - Net</para>
			/// <para>2 - Gross</para>
			/// <para>Net/Gross</para>
			/// </summary>
			public NetGrossInd? NetGrossInd
			{
				get
				{
					NetGrossInd v;
					if (fieldSet.TryGetNetGrossInd(Tags.NetGrossInd, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.NetGrossInd); else fieldSet.Set(Tags.NetGrossInd, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Regular</para>
			/// <para>1 = Cash</para>
			/// <para>2 = Next Day</para>
			/// <para>3 = T+2</para>
			/// <para>4 = T+3</para>
			/// <para>5 = T+4</para>
			/// <para>6 = Future</para>
			/// <para>7 = When Issued</para>
			/// <para>8 = Sellers Option</para>
			/// <para>9 = T+ 5</para>
			/// <para>Indicates order settlement period for Detail.</para>
			/// </summary>
			public SettlmntTyp? SettlmntTyp
			{
				get
				{
					SettlmntTyp v;
					if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
				}
			}

			/// <summary>
			/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
			/// </summary>
			public System.DateTime? FutSettDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Indicates the number of list entries.</para>
			/// <para>Number of bid repeating groups</para>
			/// </summary>
			internal BidResponseNoBidComponentsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// BidResponseNoBidComponentsInstance collection.
		/// </summary>
		#region BidResponseNoBidComponentsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class BidResponseNoBidComponentsCollection : IEnumerable<BidResponseNoBidComponentsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<BidResponseNoBidComponentsInstance> entries;

			internal BidResponseNoBidComponentsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<BidResponseNoBidComponentsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new BidResponseNoBidComponentsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public BidResponseNoBidComponentsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public BidResponseNoBidComponentsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoBidComponents, 1);
				else
					parent.SetGroup(Tags.NoBidComponents, group.NumberOfInstances + 1);
				BidResponseNoBidComponentsInstance text = new BidResponseNoBidComponentsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoBidComponents, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoBidComponents, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(BidResponseNoBidComponentsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<BidResponseNoBidComponentsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<BidResponseNoBidComponentsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion BidResponseNoBidComponentsCollection
		/// <summary>
		/// <para>The number of ContraBroker entries.</para>
		/// <para>Number of ContraBrokers repeating group instances.</para>
		/// </summary>
		public class ExecutionReportNoContraBrokersInstance
		{
			/// <summary>
			/// <para>Identifies contra broker. Standard NASD market-maker mnemonic is preferred.</para>
			/// <para>First field in repeating group. Required if NoContraBrokers &gt; 0.</para>
			/// </summary>
			public System.String ContraBroker
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContraBroker, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContraBroker); else fieldSet.Set(Tags.ContraBroker, value);
				}
			}

			/// <summary>
			/// <para>Identifies the trader (e.g. "badge number") of the ContraBroker.</para>
			/// </summary>
			public System.String ContraTrader
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContraTrader, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContraTrader); else fieldSet.Set(Tags.ContraTrader, value);
				}
			}

			/// <summary>
			/// <para>Quantity traded with the ContraBroker.</para>
			/// </summary>
			public System.Double? ContraTradeQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.ContraTradeQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContraTradeQty); else fieldSet.Set(Tags.ContraTradeQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifes the time of the trade with the ContraBroker. (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? ContraTradeTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ContraTradeTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContraTradeTime); else fieldSet.Set(Tags.ContraTradeTime, "UTCTimestamp", value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>The number of ContraBroker entries.</para>
			/// <para>Number of ContraBrokers repeating group instances.</para>
			/// </summary>
			internal ExecutionReportNoContraBrokersInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// ExecutionReportNoContraBrokersInstance collection.
		/// </summary>
		#region ExecutionReportNoContraBrokersCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class ExecutionReportNoContraBrokersCollection : IEnumerable<ExecutionReportNoContraBrokersInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<ExecutionReportNoContraBrokersInstance> entries;

			internal ExecutionReportNoContraBrokersCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<ExecutionReportNoContraBrokersInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new ExecutionReportNoContraBrokersInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public ExecutionReportNoContraBrokersInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public ExecutionReportNoContraBrokersInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoContraBrokers, 1);
				else
					parent.SetGroup(Tags.NoContraBrokers, group.NumberOfInstances + 1);
				ExecutionReportNoContraBrokersInstance text = new ExecutionReportNoContraBrokersInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoContraBrokers, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoContraBrokers, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(ExecutionReportNoContraBrokersInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<ExecutionReportNoContraBrokersInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<ExecutionReportNoContraBrokersInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion ExecutionReportNoContraBrokersCollection
		/// <summary>
		/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
		/// <para>Number of repeating groups for pre-trade allocation</para>
		/// </summary>
		public class OrderSingleNoAllocsInstance
		{
			/// <summary>
			/// <para>Sub-account mnemonic</para>
			/// <para>Required if NoAllocs &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String AllocAccount
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.AllocAccount, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocAccount); else fieldSet.Set(Tags.AllocAccount, value);
				}
			}

			/// <summary>
			/// <para>Number of shares to be allocated to specific sub-account</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? AllocShares
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocShares, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocShares); else fieldSet.Set(Tags.AllocShares, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
			/// <para>Number of repeating groups for pre-trade allocation</para>
			/// </summary>
			internal OrderSingleNoAllocsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderSingleNoAllocsInstance collection.
		/// </summary>
		#region OrderSingleNoAllocsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderSingleNoAllocsCollection : IEnumerable<OrderSingleNoAllocsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderSingleNoAllocsInstance> entries;

			internal OrderSingleNoAllocsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderSingleNoAllocsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderSingleNoAllocsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderSingleNoAllocsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderSingleNoAllocsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoAllocs, 1);
				else
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances + 1);
				OrderSingleNoAllocsInstance text = new OrderSingleNoAllocsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoAllocs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderSingleNoAllocsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderSingleNoAllocsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderSingleNoAllocsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderSingleNoAllocsCollection
		/// <summary>
		/// <para>Number of TradingSessionIDs in repeating group.</para>
		/// <para>Specifies the number of repeating TradingSessionIDs</para>
		/// </summary>
		public class OrderSingleNoTradingSessionsInstance
		{
			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// <para>Required if NoTradingSessions is &gt; 0.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of TradingSessionIDs in repeating group.</para>
			/// <para>Specifies the number of repeating TradingSessionIDs</para>
			/// </summary>
			internal OrderSingleNoTradingSessionsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderSingleNoTradingSessionsInstance collection.
		/// </summary>
		#region OrderSingleNoTradingSessionsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderSingleNoTradingSessionsCollection : IEnumerable<OrderSingleNoTradingSessionsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderSingleNoTradingSessionsInstance> entries;

			internal OrderSingleNoTradingSessionsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderSingleNoTradingSessionsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderSingleNoTradingSessionsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderSingleNoTradingSessionsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderSingleNoTradingSessionsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoTradingSessions, 1);
				else
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances + 1);
				OrderSingleNoTradingSessionsInstance text = new OrderSingleNoTradingSessionsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoTradingSessions, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderSingleNoTradingSessionsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderSingleNoTradingSessionsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderSingleNoTradingSessionsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderSingleNoTradingSessionsCollection
		/// <summary>
		/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
		/// <para>Number of repeating groups for pre-trade allocation</para>
		/// </summary>
		public class OrderCancelReplaceRequestNoAllocsInstance
		{
			/// <summary>
			/// <para>Sub-account mnemonic</para>
			/// <para>Required if NoAllocs &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String AllocAccount
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.AllocAccount, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocAccount); else fieldSet.Set(Tags.AllocAccount, value);
				}
			}

			/// <summary>
			/// <para>Number of shares to be allocated to specific sub-account</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? AllocShares
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocShares, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocShares); else fieldSet.Set(Tags.AllocShares, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
			/// <para>Number of repeating groups for pre-trade allocation</para>
			/// </summary>
			internal OrderCancelReplaceRequestNoAllocsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderCancelReplaceRequestNoAllocsInstance collection.
		/// </summary>
		#region OrderCancelReplaceRequestNoAllocsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderCancelReplaceRequestNoAllocsCollection : IEnumerable<OrderCancelReplaceRequestNoAllocsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderCancelReplaceRequestNoAllocsInstance> entries;

			internal OrderCancelReplaceRequestNoAllocsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderCancelReplaceRequestNoAllocsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderCancelReplaceRequestNoAllocsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderCancelReplaceRequestNoAllocsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderCancelReplaceRequestNoAllocsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoAllocs, 1);
				else
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances + 1);
				OrderCancelReplaceRequestNoAllocsInstance text = new OrderCancelReplaceRequestNoAllocsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoAllocs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderCancelReplaceRequestNoAllocsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderCancelReplaceRequestNoAllocsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderCancelReplaceRequestNoAllocsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderCancelReplaceRequestNoAllocsCollection
		/// <summary>
		/// <para>Number of TradingSessionIDs in repeating group.</para>
		/// <para>Specifies the number of repeating TradingSessionIDs</para>
		/// </summary>
		public class OrderCancelReplaceRequestNoTradingSessionsInstance
		{
			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// <para>Required if NoTradingSessions is &gt; 0.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of TradingSessionIDs in repeating group.</para>
			/// <para>Specifies the number of repeating TradingSessionIDs</para>
			/// </summary>
			internal OrderCancelReplaceRequestNoTradingSessionsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderCancelReplaceRequestNoTradingSessionsInstance collection.
		/// </summary>
		#region OrderCancelReplaceRequestNoTradingSessionsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderCancelReplaceRequestNoTradingSessionsCollection : IEnumerable<OrderCancelReplaceRequestNoTradingSessionsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderCancelReplaceRequestNoTradingSessionsInstance> entries;

			internal OrderCancelReplaceRequestNoTradingSessionsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderCancelReplaceRequestNoTradingSessionsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderCancelReplaceRequestNoTradingSessionsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderCancelReplaceRequestNoTradingSessionsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderCancelReplaceRequestNoTradingSessionsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoTradingSessions, 1);
				else
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances + 1);
				OrderCancelReplaceRequestNoTradingSessionsInstance text = new OrderCancelReplaceRequestNoTradingSessionsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoTradingSessions, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderCancelReplaceRequestNoTradingSessionsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderCancelReplaceRequestNoTradingSessionsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderCancelReplaceRequestNoTradingSessionsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderCancelReplaceRequestNoTradingSessionsCollection
		/// <summary>
		/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
		/// <para>Number of orders in this message (number of repeating groups to follow)</para>
		/// </summary>
		public class OrderListNoOrdersInstance
		{
			/// <summary>
			/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
			/// <para>Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String ClOrdID
			{
				get
				{
					return fieldSet.Get(Tags.ClOrdID);
				}
				set
				{
					fieldSet.Set(Tags.ClOrdID, value);
				}
			}

			/// <summary>
			/// <para>Sequence of individual order within list (i.e. ListSeqNo of ListNoOrds, 2 of 25, 3 of 25, . . . )</para>
			/// <para>Order number within the list</para>
			/// </summary>
			public System.String ListSeqNo
			{
				get
				{
					return fieldSet.Get(Tags.ListSeqNo);
				}
				set
				{
					fieldSet.Set(Tags.ListSeqNo, value);
				}
			}

			/// <summary>
			/// <para>Indicates mode used for Settlement Instructions</para>
			/// <para>Valid values:</para>
			/// <para>0 = Default</para>
			/// <para>1 = Standing Instructions Provided</para>
			/// <para>2 = Specific AllocationAccount Overriding</para>
			/// <para>3 = Specific AllocationAccount Standing</para>
			/// </summary>
			public SettlInstMode? SettlInstMode
			{
				get
				{
					SettlInstMode v;
					if (fieldSet.TryGetSettlInstMode(Tags.SettlInstMode, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlInstMode); else fieldSet.Set(Tags.SettlInstMode, value.Value);
				}
			}

			/// <summary>
			/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
			/// </summary>
			public System.String ClientID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
				}
			}

			/// <summary>
			/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
			/// </summary>
			public System.String ExecBroker
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
				}
			}

			/// <summary>
			/// <para>Account mnemonic as agreed between broker and institution.</para>
			/// </summary>
			public System.String Account
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
				}
			}

			private OrderListNoOrdersNoAllocsCollection noAllocs;
			/// <summary>
			/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
			/// <para>Indicates number of pre-trade allocation accounts to follow</para>
			/// </summary>
			public OrderListNoOrdersNoAllocsCollection NoAllocs
			{
				get
				{
					return noAllocs;
				}
			}

			/// <summary>
			/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Regular</para>
			/// <para>1 = Cash</para>
			/// <para>2 = Next Day</para>
			/// <para>3 = T+2</para>
			/// <para>4 = T+3</para>
			/// <para>5 = T+4</para>
			/// <para>6 = Future</para>
			/// <para>7 = When Issued</para>
			/// <para>8 = Sellers Option</para>
			/// <para>9 = T+ 5</para>
			/// </summary>
			public SettlmntTyp? SettlmntTyp
			{
				get
				{
					SettlmntTyp v;
					if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
				}
			}

			/// <summary>
			/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
			/// </summary>
			public System.DateTime? FutSettDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Instructions for order handling on Broker trading floor</para>
			/// <para>Valid values:</para>
			/// <para>1 = Automated execution order, private, no Broker intervention</para>
			/// <para>2 = Automated execution order, public, Broker intervention OK</para>
			/// <para>3 = Manual order, best execution</para>
			/// </summary>
			public HandlInst? HandlInst
			{
				get
				{
					HandlInst v;
					if (fieldSet.TryGetHandlInst(Tags.HandlInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.HandlInst); else fieldSet.Set(Tags.HandlInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Not held</para>
			/// <para>2 = Work</para>
			/// <para>3 = Go along</para>
			/// <para>4 = Over the day</para>
			/// <para>5 = Held</para>
			/// <para>6 = Participate don't initiate</para>
			/// <para>7 = Strict scale</para>
			/// <para>8 = Try to scale</para>
			/// <para>9 = Stay on bidside</para>
			/// <para>0 = Stay on offerside</para>
			/// <para>A = No cross (cross is forbidden)</para>
			/// <para>B = OK to cross</para>
			/// <para>C = Call first</para>
			/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
			/// <para>E = Do not increase - DNI</para>
			/// <para>F = Do not reduce - DNR</para>
			/// <para>G = All or none - AON</para>
			/// <para>I = Institutions only</para>
			/// <para>L = Last peg (last sale)</para>
			/// <para>M = Mid-price peg (midprice of inside quote)</para>
			/// <para>N = Non-negotiable</para>
			/// <para>O = Opening peg</para>
			/// <para>P = Market peg</para>
			/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
			/// <para>S = Suspend</para>
			/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
			/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
			/// <para>V = Netting (for Forex)</para>
			/// <para>W = Peg to VWAP</para>
			/// <para>Can contain multiple instructions, space delimited. If OrdType=P, exactly one of the following values (ExecInst = L, R, M, P, O, T, or W) must be specified.</para>
			/// </summary>
			public ExecInst? ExecInst
			{
				get
				{
					ExecInst v;
					if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Minimum quantity of an order to be executed.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? MinQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Maximum number of shares within an order to be shown on the exchange floor at any given time.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? MaxFloor
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MaxFloor, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaxFloor); else fieldSet.Set(Tags.MaxFloor, value.Value);
				}
			}

			/// <summary>
			/// <para>Execution destination as defined by institution when order is entered.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// </summary>
			public System.String ExDestination
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ExDestination, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExDestination); else fieldSet.Set(Tags.ExDestination, value);
				}
			}

			private OrderListNoOrdersNoTradingSessionsCollection noTradingSessions;
			/// <summary>
			/// <para>Number of TradingSessionIDs in repeating group.</para>
			/// </summary>
			public OrderListNoOrdersNoTradingSessionsCollection NoTradingSessions
			{
				get
				{
					return noTradingSessions;
				}
			}

			/// <summary>
			/// <para>Processing code for sub-account. Absence of this field in AllocAccount / AllocPrice/AllocShares / ProcessCode instance indicates regular trade.</para>
			/// <para>Valid values:</para>
			/// <para>0 = regular</para>
			/// <para>1 = soft dollar</para>
			/// <para>2 = step-in</para>
			/// <para>3 = step-out</para>
			/// <para>4 = soft-dollar step-in</para>
			/// <para>5 = soft-dollar step-out</para>
			/// <para>6 = plan sponsor</para>
			/// </summary>
			public ProcessCode? ProcessCode
			{
				get
				{
					ProcessCode v;
					if (fieldSet.TryGetProcessCode(Tags.ProcessCode, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ProcessCode); else fieldSet.Set(Tags.ProcessCode, value.Value);
				}
			}

			/// <summary>
			/// <para>Ticker symbol</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					return fieldSet.Get(Tags.Symbol);
				}
				set
				{
					fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// <para>Can be repeated multiple times if message is related to multiple symbols.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Previous closing price of security.</para>
			/// <para>Useful for verifying security identification</para>
			/// </summary>
			public System.Double? PrevClosePx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.PrevClosePx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PrevClosePx); else fieldSet.Set(Tags.PrevClosePx, value.Value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// <para>Note: to indicate the side of SideValue1 or SideValue2, specify Side=Undisclosed and SideValueInd=either the SideValue1 or SideValue2 indicator.</para>
			/// </summary>
			public Side Side
			{
				get
				{
					return fieldSet.GetSide(Tags.Side);
				}
				set
				{
					fieldSet.Set(Tags.Side, value);
				}
			}

			/// <summary>
			/// <para>Code to identify which "SideValue" the value refers to. SideValue1 and SideValue2 are used as opposed to Buy or Sell so that the basket can be quoted either way as Buy or Sell.</para>
			/// <para>Valid values:</para>
			/// <para>1 - SideValue1</para>
			/// <para>2 - SideValue 2</para>
			/// <para>Refers to the SideValue1 or SideValue2. These are used as opposed to Buy or Sell so that the basket can be quoted either way as Buy or Sell.</para>
			/// </summary>
			public System.String SideValueInd
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SideValueInd, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SideValueInd); else fieldSet.Set(Tags.SideValueInd, value);
				}
			}

			/// <summary>
			/// <para>Indicates whether the broker is to locate the stock in conjunction with a short sell order.</para>
			/// <para>Valid values:</para>
			/// <para>Y = Indicates the broker is responsible for locating the stock</para>
			/// <para>N = Indicates the broker is not required to locate</para>
			/// </summary>
			public LocateReqd? LocateReqd
			{
				get
				{
					LocateReqd v;
					if (fieldSet.TryGetLocateReqd(Tags.LocateReqd, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LocateReqd); else fieldSet.Set(Tags.LocateReqd, value.Value);
				}
			}

			/// <summary>
			/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? TransactTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified.</para>
			/// </summary>
			public System.Double? OrderQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
			/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified. Specifies the approximate "monetary quantity" for the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages.</para>
			/// </summary>
			public System.Double? CashOrderQty
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
				}
			}

			/// <summary>
			/// <para>Order type.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Market</para>
			/// <para>2 = Limit</para>
			/// <para>3 = Stop</para>
			/// <para>4 = Stop limit</para>
			/// <para>5 = Market on close</para>
			/// <para>6 = With or without</para>
			/// <para>7 = Limit or better</para>
			/// <para>8 = Limit with or without</para>
			/// <para>9 = On basis</para>
			/// <para>A = On close</para>
			/// <para>B = Limit on close</para>
			/// <para>C =Forex - Market</para>
			/// <para>D = Previously quoted</para>
			/// <para>E = Previously indicated</para>
			/// <para>F = Forex - Limit</para>
			/// <para>G = Forex - Swap</para>
			/// <para>H = Forex - Previously Quoted</para>
			/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
			/// <para>P = Pegged</para>
			/// </summary>
			public OrdType? OrdType
			{
				get
				{
					OrdType v;
					if (fieldSet.TryGetOrdType(Tags.OrdType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrdType); else fieldSet.Set(Tags.OrdType, value.Value);
				}
			}

			/// <summary>
			/// <para>Price per share</para>
			/// </summary>
			public System.Double? Price
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
				}
			}

			/// <summary>
			/// <para>Price per share</para>
			/// </summary>
			public System.Double? StopPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StopPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StopPx); else fieldSet.Set(Tags.StopPx, value.Value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			/// <summary>
			/// <para>ID used to represent this transaction for compliance purposes (e.g. OATS reporting).</para>
			/// </summary>
			public System.String ComplianceID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ComplianceID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ComplianceID); else fieldSet.Set(Tags.ComplianceID, value);
				}
			}

			/// <summary>
			/// <para>Indicates whether or not the order was solicited.</para>
			/// <para>Valid values:</para>
			/// <para>Y = Was solcitied</para>
			/// <para>N = Was not solicited</para>
			/// </summary>
			public SolicitedFlag? SolicitedFlag
			{
				get
				{
					SolicitedFlag v;
					if (fieldSet.TryGetSolicitedFlag(Tags.SolicitedFlag, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SolicitedFlag); else fieldSet.Set(Tags.SolicitedFlag, value.Value);
				}
			}

			/// <summary>
			/// <para>Unique identifier of IOI message.</para>
			/// <para>(Prior to FIX 4.1 this field was of type int)</para>
			/// <para>Required for Previously Indicated Orders (OrdType=E)</para>
			/// </summary>
			public System.String IOIid
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.IOIid, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IOIid); else fieldSet.Set(Tags.IOIid, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for quote</para>
			/// <para>Required for Previously Quoted Orders (OrdType=D)</para>
			/// </summary>
			public System.String QuoteID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.QuoteID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.QuoteID); else fieldSet.Set(Tags.QuoteID, value);
				}
			}

			/// <summary>
			/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Day</para>
			/// <para>1 = Good Till Cancel (GTC)</para>
			/// <para>2 = At the Opening (OPG)</para>
			/// <para>3 = Immediate or Cancel (IOC)</para>
			/// <para>4 = Fill or Kill (FOK)</para>
			/// <para>5 = Good Till Crossing (GTX)</para>
			/// <para>6 = Good Till Date</para>
			/// </summary>
			public TimeInForce? TimeInForce
			{
				get
				{
					TimeInForce v;
					if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
				}
			}

			/// <summary>
			/// <para>Time the details within the message should take effect (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// </summary>
			public System.DateTime? EffectiveTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.EffectiveTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EffectiveTime); else fieldSet.Set(Tags.EffectiveTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
			/// <para>Conditionally required if TimeInForce = GTD and ExpireTime is not specified.</para>
			/// </summary>
			public System.DateTime? ExpireDate
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
			/// <para>Conditionally required if TimeInForce = GTD and ExpireDate is not specified.</para>
			/// </summary>
			public System.DateTime? ExpireTime
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
				}
			}

			/// <summary>
			/// <para>Code to identify whether to book out executions on a part-filled GT order on the day of execution or to accumulate.</para>
			/// <para>Valid values:</para>
			/// <para>0 = book out all trades on day of execution</para>
			/// <para>1 = accumulate executions until order is filled or expires</para>
			/// <para>2 = accumulate until verbally notified otherwise</para>
			/// <para>States whether executions are booked out or accumulated on a partially filled GT order</para>
			/// </summary>
			public GTBookingInst? GTBookingInst
			{
				get
				{
					GTBookingInst v;
					if (fieldSet.TryGetGTBookingInst(Tags.GTBookingInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.GTBookingInst); else fieldSet.Set(Tags.GTBookingInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
			/// </summary>
			public System.Double? Commission
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.Commission, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Commission); else fieldSet.Set(Tags.Commission, value.Value);
				}
			}

			/// <summary>
			/// <para>Commission type</para>
			/// <para>Valid values:</para>
			/// <para>1 = per share</para>
			/// <para>2 = percentage</para>
			/// <para>3 = absolute</para>
			/// </summary>
			public CommType? CommType
			{
				get
				{
					CommType v;
					if (fieldSet.TryGetCommType(Tags.CommType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CommType); else fieldSet.Set(Tags.CommType, value.Value);
				}
			}

			/// <summary>
			/// <para>Note that the name of this field is changing to 'OrderCapacity' as Rule80A is a very US market-specific term. Other world markets need to convey similar information, however, often a subset of the US values. . See the 'Rule80A (aka OrderCapacity) Usage by Market' appendix for market-specific usage of this field.Valid values:</para>
			/// <para>A = Agency single order</para>
			/// <para>B = Short exempt transaction (refer to A type)</para>
			/// <para>C = Program Order, non-index arb, for Member firm/org</para>
			/// <para>D = Program Order, index arb, for Member firm/org</para>
			/// <para>E = Registered Equity Market Maker trades</para>
			/// <para>F = Short exempt transaction (refer to W type)</para>
			/// <para>H = Short exempt transaction (refer to I type)</para>
			/// <para>I = Individual Investor, single order</para>
			/// <para>J = Program Order, index arb, for individual customer</para>
			/// <para>K = Program Order, non-index arb, for individual customer</para>
			/// <para>L = Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
			/// <para>M = Program Order, index arb, for other member</para>
			/// <para>N = Program Order, non-index arb, for other member</para>
			/// <para>O = Competing dealer trades</para>
			/// <para>P = Principal</para>
			/// <para>R = Competing dealer trades</para>
			/// <para>S = Specialist trades</para>
			/// <para>T = Competing dealer trades</para>
			/// <para>U = Program Order, index arb, for other agency</para>
			/// <para>W = All other orders as agent for other member</para>
			/// <para>X = Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
			/// <para>Y = Program Order, non-index arb, for other agency</para>
			/// <para>Z = Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
			/// </summary>
			public Rule80AAkaOrderCapacity? Rule80AAkaOrderCapacity
			{
				get
				{
					Rule80AAkaOrderCapacity v;
					if (fieldSet.TryGetRule80AAkaOrderCapacity(Tags.Rule80A, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Rule80A); else fieldSet.Set(Tags.Rule80A, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates request for forex accommodation trade to be executed along with security transaction.</para>
			/// <para>Valid values:</para>
			/// <para>Y = Execute Forex after security trade</para>
			/// <para>N = Do not execute Forex after security trade</para>
			/// </summary>
			public ForexReq? ForexReq
			{
				get
				{
					ForexReq v;
					if (fieldSet.TryGetForexReq(Tags.ForexReq, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ForexReq); else fieldSet.Set(Tags.ForexReq, value.Value);
				}
			}

			/// <summary>
			/// <para>Currency code of settlement denomination.</para>
			/// </summary>
			public System.String SettlCurrency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SettlCurrency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlCurrency); else fieldSet.Set(Tags.SettlCurrency, value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			/// <summary>
			/// <para>FutSettDate of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
			/// </summary>
			public System.DateTime? FutSettDate2
			{
				get
				{
					System.DateTime v;
					if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
				}
			}

			/// <summary>
			/// <para>OrderQty of the future part of a F/X swap order.</para>
			/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
			/// </summary>
			public System.Double? OrderQty2
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
			/// <para>Valid Values:</para>
			/// <para>O=Open</para>
			/// <para>C=Close</para>
			/// </summary>
			public OpenClose? OpenClose
			{
				get
				{
					OpenClose v;
					if (fieldSet.TryGetOpenClose(Tags.OpenClose, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OpenClose); else fieldSet.Set(Tags.OpenClose, value.Value);
				}
			}

			/// <summary>
			/// <para>Used for options</para>
			/// <para>Valid values:</para>
			/// <para>0 = Covered</para>
			/// <para>1 = Uncovered</para>
			/// </summary>
			public CoveredOrUncovered? CoveredOrUncovered
			{
				get
				{
					CoveredOrUncovered v;
					if (fieldSet.TryGetCoveredOrUncovered(Tags.CoveredOrUncovered, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CoveredOrUncovered); else fieldSet.Set(Tags.CoveredOrUncovered, value.Value);
				}
			}

			/// <summary>
			/// <para>Used for options when delivering the order to an execution system/exchange to specify if the order is for a customer or the firm placing the order itself.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Customer</para>
			/// <para>1 = Firm</para>
			/// </summary>
			public CustomerOrFirm? CustomerOrFirm
			{
				get
				{
					CustomerOrFirm v;
					if (fieldSet.TryGetCustomerOrFirm(Tags.CustomerOrFirm, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CustomerOrFirm); else fieldSet.Set(Tags.CustomerOrFirm, value.Value);
				}
			}

			/// <summary>
			/// <para>Maximum number of shares within an order to be shown to other customers (i.e. sent via an IOI).</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? MaxShow
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MaxShow, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaxShow); else fieldSet.Set(Tags.MaxShow, value.Value);
				}
			}

			/// <summary>
			/// <para>Amount (signed) added to the price of the peg for a pegged order.</para>
			/// </summary>
			public System.Double? PegDifference
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.PegDifference, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PegDifference); else fieldSet.Set(Tags.PegDifference, value.Value);
				}
			}

			/// <summary>
			/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Related to displayed price</para>
			/// <para>1 = Related to market price</para>
			/// <para>2 = Related to primary price</para>
			/// <para>3 = Related to local primary price</para>
			/// <para>4 = Related to midpoint price</para>
			/// <para>5 = Related to last trade price</para>
			/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to. Required if DiscretionOffset is specified.</para>
			/// </summary>
			public DiscretionInst? DiscretionInst
			{
				get
				{
					DiscretionInst v;
					if (fieldSet.TryGetDiscretionInst(Tags.DiscretionInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.DiscretionInst); else fieldSet.Set(Tags.DiscretionInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
			/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
			/// </summary>
			public System.Double? DiscretionOffset
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.DiscretionOffset, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.DiscretionOffset); else fieldSet.Set(Tags.DiscretionOffset, value.Value);
				}
			}

			/// <summary>
			/// <para>Firm that will clear the trade. Used if different from the executing firm.</para>
			/// </summary>
			public System.String ClearingFirm
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClearingFirm, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClearingFirm); else fieldSet.Set(Tags.ClearingFirm, value);
				}
			}

			/// <summary>
			/// <para>Supplemental accounting information forwared to clearing house/firm.</para>
			/// </summary>
			public System.String ClearingAccount
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClearingAccount, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClearingAccount); else fieldSet.Set(Tags.ClearingAccount, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
			/// <para>Number of orders in this message (number of repeating groups to follow)</para>
			/// </summary>
			internal OrderListNoOrdersInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
				this.noAllocs = new OrderListNoOrdersNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
				this.noTradingSessions = new OrderListNoOrdersNoTradingSessionsCollection(fieldSet, fieldSet.GetGroup(Tags.NoTradingSessions));
			}

		}

		/// <summary>
		/// OrderListNoOrdersInstance collection.
		/// </summary>
		#region OrderListNoOrdersCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderListNoOrdersCollection : IEnumerable<OrderListNoOrdersInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderListNoOrdersInstance> entries;

			internal OrderListNoOrdersCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderListNoOrdersInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderListNoOrdersInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderListNoOrdersInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderListNoOrdersInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoOrders, 1);
				else
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances + 1);
				OrderListNoOrdersInstance text = new OrderListNoOrdersInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoOrders, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderListNoOrdersInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderListNoOrdersInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderListNoOrdersInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderListNoOrdersCollection
		/// <summary>
		/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
		/// <para>Indicates number of pre-trade allocation accounts to follow</para>
		/// </summary>
		public class OrderListNoOrdersNoAllocsInstance
		{
			/// <summary>
			/// <para>Sub-account mnemonic</para>
			/// <para>Required if NoAllocs &gt; 0. Must be the first field in the repeating group.</para>
			/// </summary>
			public System.String AllocAccount
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.AllocAccount, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocAccount); else fieldSet.Set(Tags.AllocAccount, value);
				}
			}

			/// <summary>
			/// <para>Number of shares to be allocated to specific sub-account</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double? AllocShares
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocShares, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocShares); else fieldSet.Set(Tags.AllocShares, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
			/// <para>Indicates number of pre-trade allocation accounts to follow</para>
			/// </summary>
			internal OrderListNoOrdersNoAllocsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderListNoOrdersNoAllocsInstance collection.
		/// </summary>
		#region OrderListNoOrdersNoAllocsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderListNoOrdersNoAllocsCollection : IEnumerable<OrderListNoOrdersNoAllocsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderListNoOrdersNoAllocsInstance> entries;

			internal OrderListNoOrdersNoAllocsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderListNoOrdersNoAllocsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderListNoOrdersNoAllocsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderListNoOrdersNoAllocsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderListNoOrdersNoAllocsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoAllocs, 1);
				else
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances + 1);
				OrderListNoOrdersNoAllocsInstance text = new OrderListNoOrdersNoAllocsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoAllocs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderListNoOrdersNoAllocsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderListNoOrdersNoAllocsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderListNoOrdersNoAllocsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderListNoOrdersNoAllocsCollection
		/// <summary>
		/// <para>Number of TradingSessionIDs in repeating group.</para>
		/// </summary>
		public class OrderListNoOrdersNoTradingSessionsInstance
		{
			/// <summary>
			/// <para>Identifier for Trading Session</para>
			/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
			/// <para>Values should be bi-laterally agreed to between counterparties.</para>
			/// <para>First field in repeating group. Required if NoTradingSessions &gt; 0.</para>
			/// </summary>
			public System.String TradingSessionID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of TradingSessionIDs in repeating group.</para>
			/// </summary>
			internal OrderListNoOrdersNoTradingSessionsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// OrderListNoOrdersNoTradingSessionsInstance collection.
		/// </summary>
		#region OrderListNoOrdersNoTradingSessionsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class OrderListNoOrdersNoTradingSessionsCollection : IEnumerable<OrderListNoOrdersNoTradingSessionsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<OrderListNoOrdersNoTradingSessionsInstance> entries;

			internal OrderListNoOrdersNoTradingSessionsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<OrderListNoOrdersNoTradingSessionsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new OrderListNoOrdersNoTradingSessionsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public OrderListNoOrdersNoTradingSessionsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public OrderListNoOrdersNoTradingSessionsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoTradingSessions, 1);
				else
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances + 1);
				OrderListNoOrdersNoTradingSessionsInstance text = new OrderListNoOrdersNoTradingSessionsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoTradingSessions, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoTradingSessions, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(OrderListNoOrdersNoTradingSessionsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<OrderListNoOrdersNoTradingSessionsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<OrderListNoOrdersNoTradingSessionsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion OrderListNoOrdersNoTradingSessionsCollection
		/// <summary>
		/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
		/// <para>Number of orders statused in this message, i.e. number of repeating groups to follow.</para>
		/// </summary>
		public class ListStatusNoOrdersInstance
		{
			/// <summary>
			/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
			/// </summary>
			public System.String ClOrdID
			{
				get
				{
					return fieldSet.Get(Tags.ClOrdID);
				}
				set
				{
					fieldSet.Set(Tags.ClOrdID, value);
				}
			}

			/// <summary>
			/// <para>Total number of shares filled.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double CumQty
			{
				get
				{
					return fieldSet.GetDouble(Tags.CumQty);
				}
				set
				{
					fieldSet.Set(Tags.CumQty, value);
				}
			}

			/// <summary>
			/// <para>Identifies current status of order.</para>
			/// <para>Valid values:</para>
			/// <para>0 = New</para>
			/// <para>1 = Partially filled</para>
			/// <para>2 = Filled</para>
			/// <para>3 = Done for day</para>
			/// <para>4 = Canceled</para>
			/// <para>5 = Replaced</para>
			/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request) 7 = Stopped</para>
			/// <para>8 = Rejected</para>
			/// <para>9 = Suspended</para>
			/// <para>A = Pending New</para>
			/// <para>B = Calculated</para>
			/// <para>C = Expired</para>
			/// <para>D = Accepted for bidding</para>
			/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
			/// </summary>
			public OrdStatus OrdStatus
			{
				get
				{
					return fieldSet.GetOrdStatus(Tags.OrdStatus);
				}
				set
				{
					fieldSet.Set(Tags.OrdStatus, value);
				}
			}

			/// <summary>
			/// <para>Amount of shares open for further execution. If the OrdStatus is Canceled, DoneForTheDay, Expired, Calculated, or Rejected (in which case the order is no longer active) then LeavesQty could be 0, otherwise LeavesQty = OrderQty - CumQty.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// <para>Amount of shares open for further execution. LeavesQty = OrderQty - CumQty.</para>
			/// </summary>
			public System.Double LeavesQty
			{
				get
				{
					return fieldSet.GetDouble(Tags.LeavesQty);
				}
				set
				{
					fieldSet.Set(Tags.LeavesQty, value);
				}
			}

			/// <summary>
			/// <para>Total number of shares canceled for this order.</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double CxlQty
			{
				get
				{
					return fieldSet.GetDouble(Tags.CxlQty);
				}
				set
				{
					fieldSet.Set(Tags.CxlQty, value);
				}
			}

			/// <summary>
			/// <para>Calculated average price of all fills on this order.</para>
			/// </summary>
			public System.Double AvgPx
			{
				get
				{
					return fieldSet.GetDouble(Tags.AvgPx);
				}
				set
				{
					fieldSet.Set(Tags.AvgPx, value);
				}
			}

			/// <summary>
			/// <para>Code to identify reason for order rejection.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Broker option</para>
			/// <para>1 = Unknown symbol</para>
			/// <para>2 = Exchange closed</para>
			/// <para>3 = Order exceeds limit</para>
			/// <para>4 = Too late to enter</para>
			/// <para>5 = Unknown Order</para>
			/// <para>6 = Duplicate Order (e.g. dupe ClOrdID)</para>
			/// <para>7 = Duplicate of a verbally communicated order</para>
			/// <para>8 = Stale Order</para>
			/// <para>Used if the order is rejected</para>
			/// </summary>
			public OrdRejReason? OrdRejReason
			{
				get
				{
					OrdRejReason v;
					if (fieldSet.TryGetOrdRejReason(Tags.OrdRejReason, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrdRejReason); else fieldSet.Set(Tags.OrdRejReason, value.Value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
			/// <para>Number of orders statused in this message, i.e. number of repeating groups to follow.</para>
			/// </summary>
			internal ListStatusNoOrdersInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// ListStatusNoOrdersInstance collection.
		/// </summary>
		#region ListStatusNoOrdersCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class ListStatusNoOrdersCollection : IEnumerable<ListStatusNoOrdersInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<ListStatusNoOrdersInstance> entries;

			internal ListStatusNoOrdersCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<ListStatusNoOrdersInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new ListStatusNoOrdersInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public ListStatusNoOrdersInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public ListStatusNoOrdersInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoOrders, 1);
				else
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances + 1);
				ListStatusNoOrdersInstance text = new ListStatusNoOrdersInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoOrders, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(ListStatusNoOrdersInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<ListStatusNoOrdersInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<ListStatusNoOrdersInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion ListStatusNoOrdersCollection
		/// <summary>
		/// <para>Number of list strike price entries.</para>
		/// <para>Number of strike price entries</para>
		/// </summary>
		public class ListStrikePriceNoStrikesInstance
		{
			/// <summary>
			/// <para>Ticker symbol</para>
			/// <para>Required if NoStrikes &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String Symbol
			{
				get
				{
					return fieldSet.Get(Tags.Symbol);
				}
				set
				{
					fieldSet.Set(Tags.Symbol, value);
				}
			}

			/// <summary>
			/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
			/// <para>Valid values:</para>
			/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
			/// </summary>
			public System.String SymbolSfx
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
				}
			}

			/// <summary>
			/// <para>CUSIP or other alternate security identifier</para>
			/// </summary>
			public System.String SecurityID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
				}
			}

			/// <summary>
			/// <para>Identifies class of alternative SecurityID</para>
			/// <para>Valid values:</para>
			/// <para>1 = CUSIP</para>
			/// <para>2 = SEDOL</para>
			/// <para>3 = QUIK</para>
			/// <para>4 = ISIN number</para>
			/// <para>5 = RIC code</para>
			/// <para>6 = ISO Currency Code</para>
			/// <para>7 = ISO Country Code</para>
			/// <para>8 = Exchange Symbol</para>
			/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
			/// <para>100+ are reserved for private security identifications</para>
			/// </summary>
			public IDSource? IDSource
			{
				get
				{
					IDSource v;
					if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates type of security (ISITC spec)</para>
			/// <para>Valid values:</para>
			/// <para>BA = Bankers Acceptance</para>
			/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
			/// <para>CD = Certificate Of Deposit</para>
			/// <para>CMO = Collateralize Mortgage Obligation</para>
			/// <para>CORP = Corporate Bond</para>
			/// <para>CP = Commercial Paper</para>
			/// <para>CPP = Corporate Private Placement</para>
			/// <para>CS = Common Stock</para>
			/// <para>FHA = Federal Housing Authority</para>
			/// <para>FHL = Federal Home Loan</para>
			/// <para>FN = Federal National Mortgage Association</para>
			/// <para>FOR = Foreign Exchange Contract</para>
			/// <para>FUT = Future</para>
			/// <para>GN = Government National Mortgage Association</para>
			/// <para>GOVT = Treasuries + Agency Debenture</para>
			/// <para>IET Mortgage IOETTE</para>
			/// <para>MF = Mutual Fund</para>
			/// <para>MIO = Mortgage Interest Only</para>
			/// <para>MPO = Mortgage Principal Only</para>
			/// <para>MPP = Mortgage Private Placement</para>
			/// <para>MPT = Miscellaneous Pass-Thru</para>
			/// <para>MUNI = Municipal Bond</para>
			/// <para>NONE = No ISITC Security Type</para>
			/// <para>OPT = Option</para>
			/// <para>PS = Preferred Stock</para>
			/// <para>RP = Repurchase Agreement</para>
			/// <para>RVRP = Reverse Repurchase Agreement</para>
			/// <para>SL = Student Loan Marketing Association</para>
			/// <para>TD = Time Deposit</para>
			/// <para>USTB = US Treasury Bill</para>
			/// <para>WAR = Warrant</para>
			/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
			/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
			/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
			/// </summary>
			public SecurityType? SecurityType
			{
				get
				{
					SecurityType v;
					if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
				}
			}

			/// <summary>
			/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
			/// <para>Format: YYYYMM</para>
			/// <para>(i.e. 199903)</para>
			/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
			/// </summary>
			public System.String MaturityMonthYear
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
				}
			}

			/// <summary>
			/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
			/// <para>Valid values:</para>
			/// <para>1-31</para>
			/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
			/// </summary>
			public System.Int32? MaturityDay
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates whether an Option is for a put or call.</para>
			/// <para>Valid values:</para>
			/// <para>0 = Put</para>
			/// <para>1 = Call</para>
			/// <para>For Options.</para>
			/// </summary>
			public PutOrCall? PutOrCall
			{
				get
				{
					PutOrCall v;
					if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
				}
			}

			/// <summary>
			/// <para>Strike Price for an Option.</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Double? StrikePrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
			/// <para>Valid values vary by SecurityExchange:</para>
			/// <para>For Exchange: MONEP (Paris)</para>
			/// <para>L = Long (a.k.a. 'American')</para>
			/// <para>S = Short (a.k.a. 'European')</para>
			/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
			/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
			/// <para>For Options.</para>
			/// </summary>
			public System.Char? OptAttribute
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
				}
			}

			/// <summary>
			/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
			/// </summary>
			public System.String ContractMultiplier
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
				}
			}

			/// <summary>
			/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
			/// <para>For Fixed Income.</para>
			/// </summary>
			public System.String CouponRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
				}
			}

			/// <summary>
			/// <para>Market used to help identify a security.</para>
			/// <para>Valid values:</para>
			/// <para>See Appendix C</para>
			/// <para>Can be used to identify the security.</para>
			/// </summary>
			public System.String SecurityExchange
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
				}
			}

			/// <summary>
			/// <para>Company name of security issuer (e.g. International Business Machines)</para>
			/// </summary>
			public System.String Issuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
			/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedIssuerLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedIssuer
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
				}
			}

			/// <summary>
			/// <para>Security description.</para>
			/// </summary>
			public System.String SecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
			/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedSecurityDescLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedSecurityDesc
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
				}
			}

			/// <summary>
			/// <para>Previous closing price of security.</para>
			/// <para>Useful for verifying security identification</para>
			/// </summary>
			public System.Double? PrevClosePx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.PrevClosePx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.PrevClosePx); else fieldSet.Set(Tags.PrevClosePx, value.Value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
			/// <para>Can use client order identifier or the symbol and side to uniquely identify the stock in the list.</para>
			/// </summary>
			public System.String ClOrdID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClOrdID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClOrdID); else fieldSet.Set(Tags.ClOrdID, value);
				}
			}

			/// <summary>
			/// <para>Side of order</para>
			/// <para>Valid values:</para>
			/// <para>1 = Buy</para>
			/// <para>2 = Sell</para>
			/// <para>3 = Buy minus</para>
			/// <para>4 = Sell plus</para>
			/// <para>5 = Sell short</para>
			/// <para>6 = Sell short exempt</para>
			/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
			/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
			/// <para>9 = Cross short</para>
			/// </summary>
			public Side? Side
			{
				get
				{
					Side v;
					if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
				}
			}

			/// <summary>
			/// <para>Price per share</para>
			/// </summary>
			public System.Double Price
			{
				get
				{
					return fieldSet.GetDouble(Tags.Price);
				}
				set
				{
					fieldSet.Set(Tags.Price, value);
				}
			}

			/// <summary>
			/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
			/// </summary>
			public System.String Currency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
				}
			}

			/// <summary>
			/// <para>Free format text string</para>
			/// <para>(Note: this field does not have a specified maximum length)</para>
			/// </summary>
			public System.String Text
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
			/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of list strike price entries.</para>
			/// <para>Number of strike price entries</para>
			/// </summary>
			internal ListStrikePriceNoStrikesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// ListStrikePriceNoStrikesInstance collection.
		/// </summary>
		#region ListStrikePriceNoStrikesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class ListStrikePriceNoStrikesCollection : IEnumerable<ListStrikePriceNoStrikesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<ListStrikePriceNoStrikesInstance> entries;

			internal ListStrikePriceNoStrikesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<ListStrikePriceNoStrikesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new ListStrikePriceNoStrikesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public ListStrikePriceNoStrikesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public ListStrikePriceNoStrikesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoStrikes, 1);
				else
					parent.SetGroup(Tags.NoStrikes, group.NumberOfInstances + 1);
				ListStrikePriceNoStrikesInstance text = new ListStrikePriceNoStrikesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoStrikes, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoStrikes, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(ListStrikePriceNoStrikesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<ListStrikePriceNoStrikesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<ListStrikePriceNoStrikesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion ListStrikePriceNoStrikesCollection
		/// <summary>
		/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
		/// <para>Indicates number of orders to be combined for allocation. If order(s) were manually delivered set to 1 (one).</para>
		/// </summary>
		public class AllocationNoOrdersInstance
		{
			/// <summary>
			/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
			/// <para>Order ID assigned by client if order(s) were electronically delivered and executed. If order(s) were manually delivered this field should contain string 'MANUAL'.</para>
			/// </summary>
			public System.String ClOrdID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClOrdID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClOrdID); else fieldSet.Set(Tags.ClOrdID, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
			/// </summary>
			public System.String OrderID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
				}
			}

			/// <summary>
			/// <para>Assigned by the party which accepts the order. Can be used to provide the OrderID used by an exchange or executing system.</para>
			/// <para>Can be used to provide order id used by exchange or executing system.</para>
			/// </summary>
			public System.String SecondaryOrderID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SecondaryOrderID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SecondaryOrderID); else fieldSet.Set(Tags.SecondaryOrderID, value);
				}
			}

			/// <summary>
			/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
			/// <para>Required for List Orders.</para>
			/// </summary>
			public System.String ListID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
				}
			}

			/// <summary>
			/// <para>Identifier to aid in the management of multiple lists derived from a single, master list.</para>
			/// </summary>
			public System.String WaveNo
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.WaveNo, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.WaveNo); else fieldSet.Set(Tags.WaveNo, value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
			/// <para>Indicates number of orders to be combined for allocation. If order(s) were manually delivered set to 1 (one).</para>
			/// </summary>
			internal AllocationNoOrdersInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// AllocationNoOrdersInstance collection.
		/// </summary>
		#region AllocationNoOrdersCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class AllocationNoOrdersCollection : IEnumerable<AllocationNoOrdersInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<AllocationNoOrdersInstance> entries;

			internal AllocationNoOrdersCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<AllocationNoOrdersInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new AllocationNoOrdersInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public AllocationNoOrdersInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public AllocationNoOrdersInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoOrders, 1);
				else
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances + 1);
				AllocationNoOrdersInstance text = new AllocationNoOrdersInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoOrders, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoOrders, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(AllocationNoOrdersInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<AllocationNoOrdersInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<AllocationNoOrdersInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion AllocationNoOrdersCollection
		/// <summary>
		/// <para>No of execution repeating group entries to follow.</para>
		/// <para>Indicates number of individual execution repeating group entries to follow. Absence of this field indicates that no individual execution entries are included. Primarily used to support step-outs.</para>
		/// </summary>
		public class AllocationNoExecsInstance
		{
			/// <summary>
			/// <para>Quantity of shares bought/sold on this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// <para>Number of shares in individual execution. Required if NoExecs &gt; 0</para>
			/// </summary>
			public System.Double? LastShares
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.LastShares, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LastShares); else fieldSet.Set(Tags.LastShares, value.Value);
				}
			}

			/// <summary>
			/// <para>Unique identifier of execution message as assigned by broker (will be 0 (zero) for ExecTransType=3 (Status)).</para>
			/// <para>Uniqueness must be guaranteed within a single trading day or the life of a multi-day order. Firms which accept multi-day orders should consider embedding a date within the ExecID field to assure uniqueness across days.</para>
			/// <para>(Prior to FIX 4.1 this field was of type int)</para>
			/// </summary>
			public System.String ExecID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ExecID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecID); else fieldSet.Set(Tags.ExecID, value);
				}
			}

			/// <summary>
			/// <para>Price of this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
			/// <para>Price of individual execution. Required if NoExecs &gt; 0</para>
			/// </summary>
			public System.Double? LastPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.LastPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LastPx); else fieldSet.Set(Tags.LastPx, value.Value);
				}
			}

			/// <summary>
			/// <para>Broker capacity in order execution</para>
			/// <para>Valid values:</para>
			/// <para>1 = Agent</para>
			/// <para>2 = Cross as agent</para>
			/// <para>3 = Cross as principal</para>
			/// <para>4 = Principal</para>
			/// <para>Can be specified by broker for AllocTransTyp=Calculated</para>
			/// </summary>
			public LastCapacity? LastCapacity
			{
				get
				{
					LastCapacity v;
					if (fieldSet.TryGetLastCapacity(Tags.LastCapacity, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.LastCapacity); else fieldSet.Set(Tags.LastCapacity, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>No of execution repeating group entries to follow.</para>
			/// <para>Indicates number of individual execution repeating group entries to follow. Absence of this field indicates that no individual execution entries are included. Primarily used to support step-outs.</para>
			/// </summary>
			internal AllocationNoExecsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// AllocationNoExecsInstance collection.
		/// </summary>
		#region AllocationNoExecsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class AllocationNoExecsCollection : IEnumerable<AllocationNoExecsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<AllocationNoExecsInstance> entries;

			internal AllocationNoExecsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<AllocationNoExecsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new AllocationNoExecsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public AllocationNoExecsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public AllocationNoExecsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoExecs, 1);
				else
					parent.SetGroup(Tags.NoExecs, group.NumberOfInstances + 1);
				AllocationNoExecsInstance text = new AllocationNoExecsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoExecs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoExecs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(AllocationNoExecsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<AllocationNoExecsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<AllocationNoExecsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion AllocationNoExecsCollection
		/// <summary>
		/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
		/// <para>Indicates number of allocation groups to follow.</para>
		/// </summary>
		public class AllocationNoAllocsInstance
		{
			/// <summary>
			/// <para>Sub-account mnemonic</para>
			/// <para>May be the same value as BrokerOfCredit if ProcessCode is step-out or soft-dollar step-out and Institution does not wish to disclose individual account breakdowns to the ExecBroker. Required if NoAllocs &gt; 0. Must be first field in repeating group.</para>
			/// </summary>
			public System.String AllocAccount
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.AllocAccount, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocAccount); else fieldSet.Set(Tags.AllocAccount, value);
				}
			}

			/// <summary>
			/// <para>Executed price for an AllocAccount entry used when using 'executed price' vs. 'average price' allocations (e.g. Japan).</para>
			/// <para>Used when performing 'executed price' vs. 'average price' allocations (e.g. Japan). AllocAccount plus AllocPrice form a unique Allocs entry. Used in lieu of AllocAvgPx.</para>
			/// </summary>
			public System.Double? AllocPrice
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocPrice, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocPrice); else fieldSet.Set(Tags.AllocPrice, value.Value);
				}
			}

			/// <summary>
			/// <para>Number of shares to be allocated to specific sub-account</para>
			/// <para>(Prior to FIX 4.2 this field was of type int)</para>
			/// </summary>
			public System.Double AllocShares
			{
				get
				{
					return fieldSet.GetDouble(Tags.AllocShares);
				}
				set
				{
					fieldSet.Set(Tags.AllocShares, value);
				}
			}

			/// <summary>
			/// <para>Processing code for sub-account. Absence of this field in AllocAccount / AllocPrice/AllocShares / ProcessCode instance indicates regular trade.</para>
			/// <para>Valid values:</para>
			/// <para>0 = regular</para>
			/// <para>1 = soft dollar</para>
			/// <para>2 = step-in</para>
			/// <para>3 = step-out</para>
			/// <para>4 = soft-dollar step-in</para>
			/// <para>5 = soft-dollar step-out</para>
			/// <para>6 = plan sponsor</para>
			/// </summary>
			public ProcessCode? ProcessCode
			{
				get
				{
					ProcessCode v;
					if (fieldSet.TryGetProcessCode(Tags.ProcessCode, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ProcessCode); else fieldSet.Set(Tags.ProcessCode, value.Value);
				}
			}

			/// <summary>
			/// <para>Broker to receive trade credit.</para>
			/// <para>Required if ProcessCode is step-out or soft-dollar step-out</para>
			/// </summary>
			public System.String BrokerOfCredit
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.BrokerOfCredit, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.BrokerOfCredit); else fieldSet.Set(Tags.BrokerOfCredit, value);
				}
			}

			/// <summary>
			/// <para>Indicates whether or not details should be communicated to BrokerOfCredit (i.e. step-in broker).</para>
			/// <para>Valid values:</para>
			/// <para>Y = Details should be communicated</para>
			/// <para>N = Details should not be communicated</para>
			/// </summary>
			public NotifyBrokerOfCredit? NotifyBrokerOfCredit
			{
				get
				{
					NotifyBrokerOfCredit v;
					if (fieldSet.TryGetNotifyBrokerOfCredit(Tags.NotifyBrokerOfCredit, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.NotifyBrokerOfCredit); else fieldSet.Set(Tags.NotifyBrokerOfCredit, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates how the receiver (i.e. third party) of Allocation message should handle/process the account details.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Match</para>
			/// <para>2 = Forward</para>
			/// <para>3 = Forward and Match</para>
			/// </summary>
			public AllocHandlInst? AllocHandlInst
			{
				get
				{
					AllocHandlInst v;
					if (fieldSet.TryGetAllocHandlInst(Tags.AllocHandlInst, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocHandlInst); else fieldSet.Set(Tags.AllocHandlInst, value.Value);
				}
			}

			/// <summary>
			/// <para>Free format text related to a specific AllocAccount.</para>
			/// <para>Free format Text field related to this AllocAccount</para>
			/// </summary>
			public System.String AllocText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.AllocText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocText); else fieldSet.Set(Tags.AllocText, value);
				}
			}

			/// <summary>
			/// <para>Byte length of encoded (non-ASCII characters) EncodedAllocText field.</para>
			/// <para>Must be set if EncodedAllocText field is specified and must immediately precede it.</para>
			/// </summary>
			public System.Int32? EncodedAllocTextLen
			{
				get
				{
					System.Int32 v;
					if (fieldSet.TryGetValue(Tags.EncodedAllocTextLen, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedAllocTextLen); else fieldSet.Set(Tags.EncodedAllocTextLen, value.Value);
				}
			}

			/// <summary>
			/// <para>Encoded (non-ASCII characters) representation of the AllocText field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the AllocText field.</para>
			/// <para>Encoded (non-ASCII characters) representation of the AllocText field in the encoded format specified via the MessageEncoding field.</para>
			/// </summary>
			public System.String EncodedAllocText
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.EncodedAllocText, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.EncodedAllocText); else fieldSet.Set(Tags.EncodedAllocText, value);
				}
			}

			/// <summary>
			/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
			/// <para>Required for step-in and step-out trades</para>
			/// </summary>
			public System.String ExecBroker
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
				}
			}

			/// <summary>
			/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
			/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
			/// </summary>
			public System.String ClientID
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
				}
			}

			/// <summary>
			/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
			/// </summary>
			public System.Double? Commission
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.Commission, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.Commission); else fieldSet.Set(Tags.Commission, value.Value);
				}
			}

			/// <summary>
			/// <para>Commission type</para>
			/// <para>Valid values:</para>
			/// <para>1 = per share</para>
			/// <para>2 = percentage</para>
			/// <para>3 = absolute</para>
			/// </summary>
			public CommType? CommType
			{
				get
				{
					CommType v;
					if (fieldSet.TryGetCommType(Tags.CommType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.CommType); else fieldSet.Set(Tags.CommType, value.Value);
				}
			}

			/// <summary>
			/// <para>AvgPx for a specific AllocAccount</para>
			/// <para>AvgPx for this AllocAccount. For F/X orders, should be the 'all-in' rate (spot rate adjusted for forward points) for this allocation.</para>
			/// </summary>
			public System.Double? AllocAvgPx
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocAvgPx, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocAvgPx); else fieldSet.Set(Tags.AllocAvgPx, value.Value);
				}
			}

			/// <summary>
			/// <para>NetMoney for a specific AllocAccount</para>
			/// <para>NetMoney for this AllocAccount</para>
			/// <para>((AllocShares * AllocAvgPx) - Commission - sum of MiscFeeAmt + AccruedInterestAmt) if a Sell</para>
			/// <para>((AllocShares * AllocAvgPx) + Commission + sum of MiscFeeAmt + AccruedInterestAmt) if a Buy</para>
			/// </summary>
			public System.Double? AllocNetMoney
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AllocNetMoney, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AllocNetMoney); else fieldSet.Set(Tags.AllocNetMoney, value.Value);
				}
			}

			/// <summary>
			/// <para>Total amount due expressed in settlement currency (includes the effect of the forex transaction)</para>
			/// <para>AllocNetMoney in SettlCurrency for this AllocAccount if SettlCurrency is different from 'overall' Currency</para>
			/// </summary>
			public System.Double? SettlCurrAmt
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.SettlCurrAmt, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlCurrAmt); else fieldSet.Set(Tags.SettlCurrAmt, value.Value);
				}
			}

			/// <summary>
			/// <para>Currency code of settlement denomination.</para>
			/// <para>SettlCurrency for this AllocAccount if different from 'overall' Currency. Required if SettlCurrAmt is specified.</para>
			/// </summary>
			public System.String SettlCurrency
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SettlCurrency, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlCurrency); else fieldSet.Set(Tags.SettlCurrency, value);
				}
			}

			/// <summary>
			/// <para>Foreign exchange rate used to compute SettlCurrAmt from Currency to SettlCurrency</para>
			/// <para>Foreign exchange rate used to compute SettlCurrAmt from Currency to SettlCurrency</para>
			/// </summary>
			public System.String SettlCurrFxRate
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.SettlCurrFxRate, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlCurrFxRate); else fieldSet.Set(Tags.SettlCurrFxRate, value);
				}
			}

			/// <summary>
			/// <para>Specifies whether or not SettlCurrFxRate should be multiplied or divided.</para>
			/// <para>M=Multiply</para>
			/// <para>D=Divide</para>
			/// <para>Specifies whether the SettlCurrFxRate should be multiplied or divided</para>
			/// </summary>
			public System.Char? SettlCurrFxRateCalc
			{
				get
				{
					System.Char v;
					if (fieldSet.TryGetValue(Tags.SettlCurrFxRateCalc, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlCurrFxRateCalc); else fieldSet.Set(Tags.SettlCurrFxRateCalc, value.Value);
				}
			}

			/// <summary>
			/// <para>Amount of Accrued Interest for convertible bonds and fixed income</para>
			/// <para>Applicable for Convertible Bonds and fixed income</para>
			/// </summary>
			public System.Double? AccruedInterestAmt
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.AccruedInterestAmt, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.AccruedInterestAmt); else fieldSet.Set(Tags.AccruedInterestAmt, value.Value);
				}
			}

			/// <summary>
			/// <para>Indicates mode used for Settlement Instructions</para>
			/// <para>Valid values:</para>
			/// <para>0 = Default</para>
			/// <para>1 = Standing Instructions Provided</para>
			/// <para>2 = Specific AllocationAccount Overriding</para>
			/// <para>3 = Specific AllocationAccount Standing</para>
			/// <para>Type of Settlement Instructions which will be provided via Settlement Instructions message (0=Default, 1=Standing Instructions, 2=Specific AllocationAccount Overriding, 3=Specific AllocationAccount Standing)</para>
			/// </summary>
			public SettlInstMode? SettlInstMode
			{
				get
				{
					SettlInstMode v;
					if (fieldSet.TryGetSettlInstMode(Tags.SettlInstMode, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.SettlInstMode); else fieldSet.Set(Tags.SettlInstMode, value.Value);
				}
			}

			private AllocationNoAllocsNoMiscFeesCollection noMiscFees;
			/// <summary>
			/// <para>Number of repeating groups of miscellaneous fees</para>
			/// <para>Required if any miscellaneous fees are reported. Indicates number of repeating entries. Repeating group within Alloc repeating group.</para>
			/// <para>** Nested Repeating Group follows **</para>
			/// </summary>
			public AllocationNoAllocsNoMiscFeesCollection NoMiscFees
			{
				get
				{
					return noMiscFees;
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
			/// <para>Indicates number of allocation groups to follow.</para>
			/// </summary>
			internal AllocationNoAllocsInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
				this.noMiscFees = new AllocationNoAllocsNoMiscFeesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMiscFees));
			}

		}

		/// <summary>
		/// AllocationNoAllocsInstance collection.
		/// </summary>
		#region AllocationNoAllocsCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class AllocationNoAllocsCollection : IEnumerable<AllocationNoAllocsInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<AllocationNoAllocsInstance> entries;

			internal AllocationNoAllocsCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<AllocationNoAllocsInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new AllocationNoAllocsInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public AllocationNoAllocsInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public AllocationNoAllocsInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoAllocs, 1);
				else
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances + 1);
				AllocationNoAllocsInstance text = new AllocationNoAllocsInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoAllocs, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoAllocs, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(AllocationNoAllocsInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<AllocationNoAllocsInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<AllocationNoAllocsInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion AllocationNoAllocsCollection
		/// <summary>
		/// <para>Number of repeating groups of miscellaneous fees</para>
		/// <para>Required if any miscellaneous fees are reported. Indicates number of repeating entries. Repeating group within Alloc repeating group.</para>
		/// <para>** Nested Repeating Group follows **</para>
		/// </summary>
		public class AllocationNoAllocsNoMiscFeesInstance
		{
			/// <summary>
			/// <para>Miscellaneous fee value</para>
			/// <para>Required if NoMiscFees &gt; 0</para>
			/// </summary>
			public System.Double? MiscFeeAmt
			{
				get
				{
					System.Double v;
					if (fieldSet.TryGetValue(Tags.MiscFeeAmt, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MiscFeeAmt); else fieldSet.Set(Tags.MiscFeeAmt, value.Value);
				}
			}

			/// <summary>
			/// <para>Currency of miscellaneous fee</para>
			/// <para>Required if NoMiscFees &gt; 0</para>
			/// </summary>
			public System.String MiscFeeCurr
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.MiscFeeCurr, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MiscFeeCurr); else fieldSet.Set(Tags.MiscFeeCurr, value);
				}
			}

			/// <summary>
			/// <para>Indicates type of miscellaneous fee.</para>
			/// <para>Valid values:</para>
			/// <para>1 = Regulatory (e.g. SEC)</para>
			/// <para>2 = Tax</para>
			/// <para>3 = Local Commission</para>
			/// <para>4 = Exchange Fees</para>
			/// <para>5 = Stamp</para>
			/// <para>6 = Levy</para>
			/// <para>7 = Other</para>
			/// <para>8 = Markup</para>
			/// <para>9 = Consumption Tax</para>
			/// <para>Required if NoMiscFees &gt; 0</para>
			/// </summary>
			public MiscFeeType? MiscFeeType
			{
				get
				{
					MiscFeeType v;
					if (fieldSet.TryGetMiscFeeType(Tags.MiscFeeType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MiscFeeType); else fieldSet.Set(Tags.MiscFeeType, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of repeating groups of miscellaneous fees</para>
			/// <para>Required if any miscellaneous fees are reported. Indicates number of repeating entries. Repeating group within Alloc repeating group.</para>
			/// <para>** Nested Repeating Group follows **</para>
			/// </summary>
			internal AllocationNoAllocsNoMiscFeesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// AllocationNoAllocsNoMiscFeesInstance collection.
		/// </summary>
		#region AllocationNoAllocsNoMiscFeesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class AllocationNoAllocsNoMiscFeesCollection : IEnumerable<AllocationNoAllocsNoMiscFeesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<AllocationNoAllocsNoMiscFeesInstance> entries;

			internal AllocationNoAllocsNoMiscFeesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<AllocationNoAllocsNoMiscFeesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new AllocationNoAllocsNoMiscFeesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public AllocationNoAllocsNoMiscFeesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public AllocationNoAllocsNoMiscFeesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoMiscFees, 1);
				else
					parent.SetGroup(Tags.NoMiscFees, group.NumberOfInstances + 1);
				AllocationNoAllocsNoMiscFeesInstance text = new AllocationNoAllocsNoMiscFeesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoMiscFees, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoMiscFees, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(AllocationNoAllocsNoMiscFeesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<AllocationNoAllocsNoMiscFeesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<AllocationNoAllocsNoMiscFeesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion AllocationNoAllocsNoMiscFeesCollection
		/// <summary>
		/// <para>Number of MsgTypes in repeating group.</para>
		/// <para>Specifies the number of repeating MsgTypes specified</para>
		/// </summary>
		public class LogonNoMsgTypesInstance
		{
			/// <summary>
			/// <para>The MsgType of the FIX message being referenced.</para>
			/// <para>Specifies a specific, supported MsgType. Required if NoMsgTypes is &gt; 0. Should be specified from the point of view of the sender of the Logon message</para>
			/// </summary>
			public System.String RefMsgType
			{
				get
				{
					System.String v;
					if (fieldSet.TryGetValue(Tags.RefMsgType, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.RefMsgType); else fieldSet.Set(Tags.RefMsgType, value);
				}
			}

			/// <summary>
			/// <para>Specifies the direction of the messsage.</para>
			/// <para>Valid values:</para>
			/// <para>S = Send</para>
			/// <para>R = Receive</para>
			/// <para>Indicates direction (send vs. receive) of a supported MsgType. Required if NoMsgTypes is &gt; 0. Should be specified from the point of view of the sender of the Logon message</para>
			/// </summary>
			public MsgDirection? MsgDirection
			{
				get
				{
					MsgDirection v;
					if (fieldSet.TryGetMsgDirection(Tags.MsgDirection, out v)) return v;
					return null;
				}
				set
				{
					if (value == null) fieldSet.Remove(Tags.MsgDirection); else fieldSet.Set(Tags.MsgDirection, value.Value);
				}
			}

			private GroupInstance fieldSet;
			/// <summary>
			/// <para>Number of MsgTypes in repeating group.</para>
			/// <para>Specifies the number of repeating MsgTypes specified</para>
			/// </summary>
			internal LogonNoMsgTypesInstance(GroupInstance groupInstance)
			{
				this.fieldSet = groupInstance;
			}

		}

		/// <summary>
		/// LogonNoMsgTypesInstance collection.
		/// </summary>
		#region LogonNoMsgTypesCollection
		[Serializable]
		[System.Diagnostics.DebuggerDisplay("Count = {Count}")]
		[System.Runtime.InteropServices.ComVisible(false)]
		public class LogonNoMsgTypesCollection : IEnumerable<LogonNoMsgTypesInstance>
		{
			private FIXForge.NET.FIX.FieldSet parent;
			private FIXForge.NET.FIX.Group group;
			private List<LogonNoMsgTypesInstance> entries;

			internal LogonNoMsgTypesCollection(FIXForge.NET.FIX.FieldSet parent, FIXForge.NET.FIX.Group group)
			{
				this.parent = parent;
				this.group = group;

				entries = new List<LogonNoMsgTypesInstance>();
				if (group != null)
				{
					for (int i = 0; i < group.NumberOfInstances; i++)
					{
						entries.Add(new LogonNoMsgTypesInstance(group[i]));
					}
				}
			}

			/// <summary>
			/// Gets underlying repeating group.
			/// </summary>
			public FIXForge.NET.FIX.Group Group
			{
				get { return group; }
			}

			/// <summary>
			/// Gets repeating group entry.
			/// </summary>
			/// <param name="index">Index of repeating group entry.</param>
			/// <returns>Repeating group entry</returns>
			public LogonNoMsgTypesInstance this[int index]
			{
				get
				{
					return entries[index];
				}
			}

			/// <summary>
			/// Creates new repeating group entry and add it to group.
			/// </summary>
			/// <returns>Created repeating group entry.</returns>
			public LogonNoMsgTypesInstance CreateNew()
			{
				if (group == null)
					group = parent.SetGroup(Tags.NoMsgTypes, 1);
				else
					parent.SetGroup(Tags.NoMsgTypes, group.NumberOfInstances + 1);
				LogonNoMsgTypesInstance text = new LogonNoMsgTypesInstance(group[group.NumberOfInstances - 1]);
				entries.Add(text);
				return text;
			}

			/// <summary>
			/// Removes last entry from repeating group.
			/// </summary>
			public void RemoveLast()
			{
				if (group != null && Count > 0)
				{
					parent.SetGroup(Tags.NoMsgTypes, group.NumberOfInstances - 1);
					entries.RemoveAt(entries.Count - 1);
				}
			}

			/// <summary>
			/// Removes all entries from repeating group.
			/// </summary>
			public void Clear()
			{
				parent.SetGroup(Tags.NoMsgTypes, 0);
				entries.Clear();
				group = null;
			}

			/// <summary>
			/// Copies the entire repeating group to a compatible one-dimensional array, starting at the specified index of the target array. 
			/// </summary>
			/// <param name="array">The one-dimensional Array that is the destination of the elements copied from repeating group. The Array must have zero-based indexing.</param>
			/// <param name="arrayIndex">The zero-based index in array at which copying begins.</param>
			public void CopyTo(LogonNoMsgTypesInstance[] array, int arrayIndex)
			{
				entries.CopyTo(array, arrayIndex);
			}

			/// <summary>
			/// Get count of repeating group entries.
			/// </summary>
			public int Count
			{
				get { return group == null ? 0 : group.NumberOfInstances; }
			}

			#region IEnumerable<LogonNoMsgTypesInstance> Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			public IEnumerator<LogonNoMsgTypesInstance> GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion

			#region IEnumerable Members

			/// <summary>
			/// Returns an enumerator that iterates through the repeating group. 
			/// </summary>
			/// <returns>Enumerator for repeating group.</returns>
			System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
			{
				return entries.GetEnumerator();
			}

			#endregion
		}
		#endregion LogonNoMsgTypesCollection
	namespace Application.PreTrade.Indication
	{
			/// <summary>
			/// <para>Indication of interest messages market merchandise which the broker is buying or selling in either a proprietary or agency capacity. The indications can be time bound with a specific expiration value. Indications are distributed with the understanding that other firms may react to the message first and that the merchandise may no longer be available due to prior trade.</para>
			/// <para>Indication messages can be transmitted in various transaction types; NEW, CANCEL, and REPLACE. All message types other than NEW modify the state of the message identified in IOIRefID.</para>
			/// </summary>
			public class IndicationOfInterest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier of IOI message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// </summary>
				public System.String IOIid
				{
					get
					{
						return fieldSet.Get(Tags.IOIid);
					}
					set
					{
						fieldSet.Set(Tags.IOIid, value);
					}
				}

				/// <summary>
				/// <para>Identifies IOI message transaction type</para>
				/// <para>Valid values:</para>
				/// <para>N = New</para>
				/// <para>C = Cancel</para>
				/// <para>R = Replace</para>
				/// </summary>
				public IOITransType IOITransType
				{
					get
					{
						return fieldSet.GetIOITransType(Tags.IOITransType);
					}
					set
					{
						fieldSet.Set(Tags.IOITransType, value);
					}
				}

				/// <summary>
				/// <para>Reference identifier used with CANCEL and REPLACE, transaction types.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for Cancel and Replace IOITransType messages</para>
				/// </summary>
				public System.String IOIRefID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.IOIRefID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IOIRefID); else fieldSet.Set(Tags.IOIRefID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// <para>Side of Indication</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>7 = Undisclosed (for IOIs)</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Number of shares in numeric or relative size.</para>
				/// <para>Valid values:</para>
				/// <para>0 - 1000000000</para>
				/// <para>S = Small</para>
				/// <para>M = Medium</para>
				/// <para>L = Large</para>
				/// </summary>
				public IOIShares IOIShares
				{
					get
					{
						return fieldSet.GetIOIShares(Tags.IOIShares);
					}
					set
					{
						fieldSet.Set(Tags.IOIShares, value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// </summary>
				public System.Double? Price
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Indicates expiration time of indication message (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? ValidUntilTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ValidUntilTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ValidUntilTime); else fieldSet.Set(Tags.ValidUntilTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Relative quality of indication</para>
				/// <para>Valid values:</para>
				/// <para>L = Low</para>
				/// <para>M = Medium</para>
				/// <para>H = High</para>
				/// </summary>
				public IOIQltyInd? IOIQltyInd
				{
					get
					{
						IOIQltyInd v;
						if (fieldSet.TryGetIOIQltyInd(Tags.IOIQltyInd, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IOIQltyInd); else fieldSet.Set(Tags.IOIQltyInd, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates that IOI is the result of an existing agency order or a facilitation position resulting from an agency order, not from principal trading or order solicitation activity.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Natural</para>
				/// <para>N = Not natural</para>
				/// </summary>
				public IOINaturalFlag? IOINaturalFlag
				{
					get
					{
						IOINaturalFlag v;
						if (fieldSet.TryGetIOINaturalFlag(Tags.IOINaturalFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IOINaturalFlag); else fieldSet.Set(Tags.IOINaturalFlag, value.Value);
					}
				}

				private IndicationOfInterestNoIOIQualifiersCollection noIOIQualifiers;
				/// <summary>
				/// <para>Number of repeating groups of IOIQualifiers.</para>
				/// <para>Required if any IOIQualifiers are specified. Indicates the number of repeating IOIQualifiers.</para>
				/// </summary>
				public IndicationOfInterestNoIOIQualifiersCollection NoIOIQualifiers
				{
					get
					{
						return noIOIQualifiers;
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// </summary>
				public System.String URLLink
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.URLLink, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.URLLink); else fieldSet.Set(Tags.URLLink, value);
					}
				}

				private IndicationOfInterestNoRoutingIDsCollection noRoutingIDs;
				/// <summary>
				/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
				/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
				/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
				/// </summary>
				public IndicationOfInterestNoRoutingIDsCollection NoRoutingIDs
				{
					get
					{
						return noRoutingIDs;
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Basis points relative to a benchmark. To be expressed as "count of basis points" (vs. an absolute value). E.g. High Grade Corporate Bonds may express price as basis points relative to benchmark (the Benchmark field). Note: Basis points can be negative.</para>
				/// <para>For Fixed Income</para>
				/// </summary>
				public System.Double? SpreadToBenchmark
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.SpreadToBenchmark, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SpreadToBenchmark); else fieldSet.Set(Tags.SpreadToBenchmark, value.Value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Identifies the benchmark (e.g. used in conjunction with the SpreadToBenchmark field).</para>
				/// <para>Valid values:</para>
				/// <para>1 = CURVE</para>
				/// <para>2 = 5-YR</para>
				/// <para>3 = OLD-5</para>
				/// <para>4 = 10-YR</para>
				/// <para>5 = OLD-10</para>
				/// <para>6 = 30-YR</para>
				/// <para>7 = OLD-30</para>
				/// <para>8 = 3-MO-LIBOR</para>
				/// <para>9 = 6-MO-LIBOR</para>
				/// <para>For Fixed Income</para>
				/// </summary>
				public Benchmark? Benchmark
				{
					get
					{
						Benchmark v;
						if (fieldSet.TryGetBenchmark(Tags.Benchmark, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Benchmark); else fieldSet.Set(Tags.Benchmark, value.Value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public IndicationOfInterest(Message message)
				{
					this.fieldSet = message;
					this.noIOIQualifiers = new IndicationOfInterestNoIOIQualifiersCollection(fieldSet, fieldSet.GetGroup(Tags.NoIOIQualifiers));
					this.noRoutingIDs = new IndicationOfInterestNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public IndicationOfInterest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Indication_of_Interest, new Dialect(ProtocolVersion.FIX42));
					this.noIOIQualifiers = new IndicationOfInterestNoIOIQualifiersCollection(fieldSet, fieldSet.GetGroup(Tags.NoIOIQualifiers));
					this.noRoutingIDs = new IndicationOfInterestNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public IndicationOfInterest(System.String iOIid, IOITransType iOITransType, System.String symbol, Side side, IOIShares iOIShares)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Indication_of_Interest, new Dialect(ProtocolVersion.FIX42));
					IOIid = iOIid;
					IOITransType = iOITransType;
					Symbol = symbol;
					Side = side;
					IOIShares = iOIShares;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(IndicationOfInterest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Indication
	{
			/// <summary>
			/// <para>Advertisement messages are used to announce completed transactions. The Advertisement message can be transmitted in various transaction types; NEW, CANCEL and REPLACE. All message types other than NEW modify the state of a previously transmitted advertisement identified in AdvRefID.</para>
			/// </summary>
			public class Advertisement
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier of Advertisement message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// </summary>
				public System.String AdvId
				{
					get
					{
						return fieldSet.Get(Tags.AdvId);
					}
					set
					{
						fieldSet.Set(Tags.AdvId, value);
					}
				}

				/// <summary>
				/// <para>Identifies Advertisement message transaction type</para>
				/// <para>Valid values:</para>
				/// <para>N = New</para>
				/// <para>C = Cancel</para>
				/// <para>R = Replace</para>
				/// </summary>
				public AdvTransType AdvTransType
				{
					get
					{
						return fieldSet.GetAdvTransType(Tags.AdvTransType);
					}
					set
					{
						fieldSet.Set(Tags.AdvTransType, value);
					}
				}

				/// <summary>
				/// <para>Reference identifier used with CANCEL and REPLACE transaction types.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for Cancel and Replace AdvTransType messages</para>
				/// </summary>
				public System.String AdvRefID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.AdvRefID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AdvRefID); else fieldSet.Set(Tags.AdvRefID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Broker's side of advertised trade</para>
				/// <para>Valid values:</para>
				/// <para>B = Buy</para>
				/// <para>S = Sell</para>
				/// <para>X = Cross</para>
				/// <para>T = Trade</para>
				/// </summary>
				public AdvSide AdvSide
				{
					get
					{
						return fieldSet.GetAdvSide(Tags.AdvSide);
					}
					set
					{
						fieldSet.Set(Tags.AdvSide, value);
					}
				}

				/// <summary>
				/// <para>Number of shares</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double Shares
				{
					get
					{
						return fieldSet.GetDouble(Tags.Shares);
					}
					set
					{
						fieldSet.Set(Tags.Shares, value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// </summary>
				public System.Double? Price
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// </summary>
				public System.DateTime? TradeDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradeDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradeDate); else fieldSet.Set(Tags.TradeDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// </summary>
				public System.String URLLink
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.URLLink, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.URLLink); else fieldSet.Set(Tags.URLLink, value);
					}
				}

				/// <summary>
				/// <para>Market of execution for last fill</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String LastMkt
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.LastMkt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastMkt); else fieldSet.Set(Tags.LastMkt, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Advertisement(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Advertisement()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Advertisement, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Advertisement(System.String advId, AdvTransType advTransType, System.String symbol, AdvSide advSide, System.Double shares)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Advertisement, new Dialect(ProtocolVersion.FIX42));
					AdvId = advId;
					AdvTransType = advTransType;
					Symbol = symbol;
					AdvSide = advSide;
					Shares = shares;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Advertisement value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.EventCommunication
	{
			/// <summary>
			/// <para>The News message is a general free format message between the broker and institution. The message contains flags to identify the news item's urgency and to allow sorting by subject company (symbol). The News message can be originated at either the broker or institution side.</para>
			/// </summary>
			public class News
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Time of message origination (always expressed in UTC (Universal Time Coordinated, also known as 'GMT'))</para>
				/// </summary>
				public System.DateTime? OrigTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.OrigTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrigTime); else fieldSet.Set(Tags.OrigTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Urgency flag</para>
				/// <para>Valid values:</para>
				/// <para>0 = Normal</para>
				/// <para>1 = Flash</para>
				/// <para>2 = Background</para>
				/// </summary>
				public Urgency? Urgency
				{
					get
					{
						Urgency v;
						if (fieldSet.TryGetUrgency(Tags.Urgency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Urgency); else fieldSet.Set(Tags.Urgency, value.Value);
					}
				}

				/// <summary>
				/// <para>The headline of a News message</para>
				/// <para>Specifies the headline text</para>
				/// </summary>
				public System.String Headline
				{
					get
					{
						return fieldSet.Get(Tags.Headline);
					}
					set
					{
						fieldSet.Set(Tags.Headline, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedHeadline field.</para>
				/// <para>Must be set if EncodedHeadline field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedHeadlineLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedHeadlineLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedHeadlineLen); else fieldSet.Set(Tags.EncodedHeadlineLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Headline field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Headline field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Headline field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedHeadline
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedHeadline, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedHeadline); else fieldSet.Set(Tags.EncodedHeadline, value);
					}
				}

				private NewsNoRoutingIDsCollection noRoutingIDs;
				/// <summary>
				/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
				/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
				/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
				/// </summary>
				public NewsNoRoutingIDsCollection NoRoutingIDs
				{
					get
					{
						return noRoutingIDs;
					}
				}

				private NewsNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Specifies the number of repeating symbols specified</para>
				/// </summary>
				public NewsNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				private NewsLinesOfTextCollection linesOfText;
				/// <summary>
				/// <para>Identifies number of lines of text body</para>
				/// <para>Specifies the number of repeating lines of text specified</para>
				/// </summary>
				public NewsLinesOfTextCollection LinesOfText
				{
					get
					{
						return linesOfText;
					}
				}

				/// <summary>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// <para>A URL (Uniform Resource Locator) link to additional information (i.e. http://www.XYZ.com/research.html)</para>
				/// </summary>
				public System.String URLLink
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.URLLink, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.URLLink); else fieldSet.Set(Tags.URLLink, value);
					}
				}

				/// <summary>
				/// <para>Number of bytes in raw data field.</para>
				/// </summary>
				public System.Int32? RawDataLength
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.RawDataLength, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawDataLength); else fieldSet.Set(Tags.RawDataLength, value.Value);
					}
				}

				/// <summary>
				/// <para>Unformatted raw data, can include bitmaps, word processor documents, etc.</para>
				/// </summary>
				public System.String RawData
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RawData, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawData); else fieldSet.Set(Tags.RawData, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public News(Message message)
				{
					this.fieldSet = message;
					this.noRoutingIDs = new NewsNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
					this.noRelatedSym = new NewsNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
					this.linesOfText = new NewsLinesOfTextCollection(fieldSet, fieldSet.GetGroup(Tags.LinesOfText));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public News()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.News, new Dialect(ProtocolVersion.FIX42));
					this.noRoutingIDs = new NewsNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
					this.noRelatedSym = new NewsNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
					this.linesOfText = new NewsLinesOfTextCollection(fieldSet, fieldSet.GetGroup(Tags.LinesOfText));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public News(System.String headline)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.News, new Dialect(ProtocolVersion.FIX42));
					Headline = headline;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(News value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.EventCommunication
	{
			/// <summary>
			/// <para>The Email message is similar to the format and purpose of to the News message, however, it is intended for private use between two parties.</para>
			/// </summary>
			public class Email
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for an email thread (new and chain of replies)</para>
				/// <para>Unique identifier for the Email message thread</para>
				/// </summary>
				public System.String EmailThreadID
				{
					get
					{
						return fieldSet.Get(Tags.EmailThreadID);
					}
					set
					{
						fieldSet.Set(Tags.EmailThreadID, value);
					}
				}

				/// <summary>
				/// <para>Email message type.</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Reply</para>
				/// <para>2 = Admin Reply</para>
				/// </summary>
				public EmailType EmailType
				{
					get
					{
						return fieldSet.GetEmailType(Tags.EmailType);
					}
					set
					{
						fieldSet.Set(Tags.EmailType, value);
					}
				}

				/// <summary>
				/// <para>Time of message origination (always expressed in UTC (Universal Time Coordinated, also known as 'GMT'))</para>
				/// </summary>
				public System.DateTime? OrigTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.OrigTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrigTime); else fieldSet.Set(Tags.OrigTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>The subject of an Email message</para>
				/// <para>Specifies the Subject text</para>
				/// </summary>
				public System.String Subject
				{
					get
					{
						return fieldSet.Get(Tags.Subject);
					}
					set
					{
						fieldSet.Set(Tags.Subject, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSubject field.</para>
				/// <para>Must be set if EncodedSubject field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSubjectLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSubjectLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSubjectLen); else fieldSet.Set(Tags.EncodedSubjectLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Subject field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Subject field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Subject field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSubject
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSubject, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSubject); else fieldSet.Set(Tags.EncodedSubject, value);
					}
				}

				private EmailNoRoutingIDsCollection noRoutingIDs;
				/// <summary>
				/// <para>Number of repeating groups of RoutingID and RoutingType values.</para>
				/// <para>See Appendix L - Pre-Trade Message Targeting/Routing</para>
				/// <para>Required if any RoutingType and RoutingIDs are specified. Indicates the number within repeating group.</para>
				/// </summary>
				public EmailNoRoutingIDsCollection NoRoutingIDs
				{
					get
					{
						return noRoutingIDs;
					}
				}

				private EmailNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Specifies the number of repeating symbols specified</para>
				/// </summary>
				public EmailNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClOrdID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClOrdID); else fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				private EmailLinesOfTextCollection linesOfText;
				/// <summary>
				/// <para>Identifies number of lines of text body</para>
				/// <para>Specifies the number of repeating lines of text specified</para>
				/// </summary>
				public EmailLinesOfTextCollection LinesOfText
				{
					get
					{
						return linesOfText;
					}
				}

				/// <summary>
				/// <para>Number of bytes in raw data field.</para>
				/// </summary>
				public System.Int32? RawDataLength
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.RawDataLength, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawDataLength); else fieldSet.Set(Tags.RawDataLength, value.Value);
					}
				}

				/// <summary>
				/// <para>Unformatted raw data, can include bitmaps, word processor documents, etc.</para>
				/// </summary>
				public System.String RawData
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RawData, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawData); else fieldSet.Set(Tags.RawData, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Email(Message message)
				{
					this.fieldSet = message;
					this.noRoutingIDs = new EmailNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
					this.noRelatedSym = new EmailNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
					this.linesOfText = new EmailLinesOfTextCollection(fieldSet, fieldSet.GetGroup(Tags.LinesOfText));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Email()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Email, new Dialect(ProtocolVersion.FIX42));
					this.noRoutingIDs = new EmailNoRoutingIDsCollection(fieldSet, fieldSet.GetGroup(Tags.NoRoutingIDs));
					this.noRelatedSym = new EmailNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
					this.linesOfText = new EmailLinesOfTextCollection(fieldSet, fieldSet.GetGroup(Tags.LinesOfText));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Email(System.String emailThreadID, EmailType emailType, System.String subject)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Email, new Dialect(ProtocolVersion.FIX42));
					EmailThreadID = emailThreadID;
					EmailType = emailType;
					Subject = subject;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Email value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>In some markets it is the practice to request quotes from brokers prior to placement of an order. The Quote Request message is used for this purpose.</para>
			/// <para>Quotes can be requested on specific securities or forex rates.</para>
			/// <para>Securities quotes can be requested as either market quotes or for a specific quantity and side. If OrderQty and Side are absent, a market-style quote (bid x offer, size x size) will be returned.</para>
			/// <para>If the message is used for foreign exchange, conventions for identifying the forex transaction are as follows:</para>
			/// <list type="bullet"><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange TradingForex quotes can be requested as indicative or at a specific quantity level. If an indicative quote is requested (OrderQty and Side are absent), the broker has discretion to quote at either a specific trade level and side or to provide an indicative quote at the mid-point of the spread. The broker can also choose to respond to an indicative quote by sending multiple Quote messages specifying various levels and sides.</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange TradingForex quotes can be requested as indicative or at a specific quantity level. If an indicative quote is requested (OrderQty and Side are absent), the broker has discretion to quote at either a specific trade level and side or to provide an indicative quote at the mid-point of the spread. The broker can also choose to respond to an indicative quote by sending multiple Quote messages specifying various levels and sides.</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange TradingForex quotes can be requested as indicative or at a specific quantity level. If an indicative quote is requested (OrderQty and Side are absent), the broker has discretion to quote at either a specific trade level and side or to provide an indicative quote at the mid-point of the spread. The broker can also choose to respond to an indicative quote by sending multiple Quote messages specifying various levels and sides.</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange TradingForex quotes can be requested as indicative or at a specific quantity level. If an indicative quote is requested (OrderQty and Side are absent), the broker has discretion to quote at either a specific trade level and side or to provide an indicative quote at the mid-point of the spread. The broker can also choose to respond to an indicative quote by sending multiple Quote messages specifying various levels and sides.</item></list>
			/// </summary>
			public class QuoteRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote request</para>
				/// </summary>
				public System.String QuoteReqID
				{
					get
					{
						return fieldSet.Get(Tags.QuoteReqID);
					}
					set
					{
						fieldSet.Set(Tags.QuoteReqID, value);
					}
				}

				private QuoteRequestNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Number of related symbols in Request</para>
				/// </summary>
				public QuoteRequestNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteRequest(Message message)
				{
					this.fieldSet = message;
					this.noRelatedSym = new QuoteRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Request, new Dialect(ProtocolVersion.FIX42));
					this.noRelatedSym = new QuoteRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteRequest(System.String quoteReqID)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Request, new Dialect(ProtocolVersion.FIX42));
					QuoteReqID = quoteReqID;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(QuoteRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>The Quote message is used as the response to a Quote Request message and can be used to publish unsolicited quotes.</para>
			/// <para>Quotes supplied as the result of a Quote Request message are tagged with the appropriate QuoteReqID, unsolicited quotes can be identified by the absence of a QuoteReqID.</para>
			/// <para>If the message is used for foreign exchange, conventions for identifying the forex transaction are as follows:</para>
			/// <list type="bullet"><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item></list><para>Orders can be generated based on Quotes. Quoted orders include the QuoteID and are OrdType=Previously Quoted or Forex - Previously Quoted.</para>
			/// <para>Example: Quote for Single Security</para>
			/// <para>QuoteID=XXX
			/// QuoteReqID=YYY
			/// Symbol=AA
			/// MaturyMonthYear=199901
			/// StrikePrice=25.00
			/// PutOrCall=1
			/// BixPx=5.00
			/// OfferPx=5.25
			/// BidSize=10
			/// OfferSize=10</para>
			/// </summary>
			public class Quote
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote request</para>
				/// <para>Required when quote is in response to a Quote Request message</para>
				/// </summary>
				public System.String QuoteReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteReqID); else fieldSet.Set(Tags.QuoteReqID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						return fieldSet.Get(Tags.QuoteID);
					}
					set
					{
						fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// <para>Valid Values:</para>
				/// <para>0 - No Acknowledgement (Default)</para>
				/// <para>1 - Acknowledge only negative or erroneous quotes</para>
				/// <para>2 - Acknowledge each Quote messages</para>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// </summary>
				public QuoteResponseLevel? QuoteResponseLevel
				{
					get
					{
						QuoteResponseLevel v;
						if (fieldSet.TryGetQuoteResponseLevel(Tags.QuoteResponseLevel, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteResponseLevel); else fieldSet.Set(Tags.QuoteResponseLevel, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Bid price/rate</para>
				/// <para>If F/X quote, should be the 'all-in' rate (spot rate adjusted for forward points). Note that either BidPx, OfferPx or both must be specified.</para>
				/// </summary>
				public System.Double? BidPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.BidPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidPx); else fieldSet.Set(Tags.BidPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Offer price/rate</para>
				/// <para>If F/X quote, should be the 'all-in' rate (spot rate adjusted for forward points). Note that either BidPx, OfferPx or both must be specified.</para>
				/// </summary>
				public System.Double? OfferPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OfferPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OfferPx); else fieldSet.Set(Tags.OfferPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Quantity of bid</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? BidSize
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.BidSize, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidSize); else fieldSet.Set(Tags.BidSize, value.Value);
					}
				}

				/// <summary>
				/// <para>Quantity of offer</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? OfferSize
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OfferSize, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OfferSize); else fieldSet.Set(Tags.OfferSize, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates expiration time of indication message (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? ValidUntilTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ValidUntilTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ValidUntilTime); else fieldSet.Set(Tags.ValidUntilTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Bid F/X spot rate.y vary and not limited to four)</para>
				/// <para>May be applicable for F/X quotes</para>
				/// </summary>
				public System.Double? BidSpotRate
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.BidSpotRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidSpotRate); else fieldSet.Set(Tags.BidSpotRate, value.Value);
					}
				}

				/// <summary>
				/// <para>Offer F/X spot rate.</para>
				/// <para>May be applicable for F/X quotes</para>
				/// </summary>
				public System.Double? OfferSpotRate
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OfferSpotRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OfferSpotRate); else fieldSet.Set(Tags.OfferSpotRate, value.Value);
					}
				}

				/// <summary>
				/// <para>Bid F/X forward points added to spot rate. May be a negative value.</para>
				/// <para>May be applicable for F/X quotes</para>
				/// </summary>
				public System.Double? BidForwardPoints
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.BidForwardPoints, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidForwardPoints); else fieldSet.Set(Tags.BidForwardPoints, value.Value);
					}
				}

				/// <summary>
				/// <para>Offer F/X forward points added to spot rate. May be a negative value.</para>
				/// <para>May be applicable for F/X quotes</para>
				/// </summary>
				public System.Double? OfferForwardPoints
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OfferForwardPoints, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OfferForwardPoints); else fieldSet.Set(Tags.OfferForwardPoints, value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
				/// <para>Can be used with forex quotes to specify a specific 'value date'</para>
				/// </summary>
				public System.DateTime? FutSettDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Order type.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Market</para>
				/// <para>2 = Limit</para>
				/// <para>3 = Stop</para>
				/// <para>4 = Stop limit</para>
				/// <para>5 = Market on close</para>
				/// <para>6 = With or without</para>
				/// <para>7 = Limit or better</para>
				/// <para>8 = Limit with or without</para>
				/// <para>9 = On basis</para>
				/// <para>A = On close</para>
				/// <para>B = Limit on close</para>
				/// <para>C =Forex - Market</para>
				/// <para>D = Previously quoted</para>
				/// <para>E = Previously indicated</para>
				/// <para>F = Forex - Limit</para>
				/// <para>G = Forex - Swap</para>
				/// <para>H = Forex - Previously Quoted</para>
				/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
				/// <para>P = Pegged</para>
				/// <para>Can be used to specify the type of order the quote is for</para>
				/// </summary>
				public OrdType? OrdType
				{
					get
					{
						OrdType v;
						if (fieldSet.TryGetOrdType(Tags.OrdType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrdType); else fieldSet.Set(Tags.OrdType, value.Value);
					}
				}

				/// <summary>
				/// <para>FutSettDate of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
				/// </summary>
				public System.DateTime? FutSettDate2
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>OrderQty of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
				/// </summary>
				public System.Double? OrderQty2
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// <para>Can be used to specify the currency of the quoted price.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Quote(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Quote()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Quote(System.String quoteID, System.String symbol)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote, new Dialect(ProtocolVersion.FIX42));
					QuoteID = quoteID;
					Symbol = symbol;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Quote value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>The Quote Cancel message is used by an originator of quotes to cancel quotes.</para>
			/// <para>The Quote Cancel message supports cancelation of:</para>
			/// <list type="bullet"><item>All quotesQuotes for a specific symbol or security IDAll quotes for a security typeAll quotes for an underlying</item><item>All quotesQuotes for a specific symbol or security IDAll quotes for a security typeAll quotes for an underlying</item><item>All quotesQuotes for a specific symbol or security IDAll quotes for a security typeAll quotes for an underlying</item><item>All quotesQuotes for a specific symbol or security IDAll quotes for a security typeAll quotes for an underlying</item></list><para>Canceling a Quote is acccomplished by indicating the type of cancelation in the QuoteCancelType field.</para>
			/// <para>The Quote Cancelation only applies to quotes made by the current FIX user.</para>
			/// <para>Options usage notes:</para>
			/// <para>Normal usage would be to cancel the quotes for a symbol. This is the reason that the use of further nesting similar to the quote is not used in this message. You are able to cancel quotes for specific series by specifying each option series in the repeating group.</para>
			/// <para>It is recommended that all Cancel messages be acknowledged using the Quote Acknowledgement message</para>
			/// </summary>
			public class QuoteCancel
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote request</para>
				/// <para>Required when quote is in response to a Quote Request message</para>
				/// </summary>
				public System.String QuoteReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteReqID); else fieldSet.Set(Tags.QuoteReqID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						return fieldSet.Get(Tags.QuoteID);
					}
					set
					{
						fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of quote cancel.</para>
				/// <para>Valid Values:</para>
				/// <para>1 - Cancel for Symbol(s)</para>
				/// <para>2 - Cancel for Security Type(s)</para>
				/// <para>3 - Cancel for Underlying Symbol</para>
				/// <para>4 - Cancel All Quotes</para>
				/// <para>Identifies the type of Quote Cancel request.</para>
				/// </summary>
				public QuoteCancelType QuoteCancelType
				{
					get
					{
						return fieldSet.GetQuoteCancelType(Tags.QuoteCancelType);
					}
					set
					{
						fieldSet.Set(Tags.QuoteCancelType, value);
					}
				}

				/// <summary>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// <para>Valid Values:</para>
				/// <para>0 - No Acknowledgement (Default)</para>
				/// <para>1 - Acknowledge only negative or erroneous quotes</para>
				/// <para>2 - Acknowledge each Quote messages</para>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// </summary>
				public QuoteResponseLevel? QuoteResponseLevel
				{
					get
					{
						QuoteResponseLevel v;
						if (fieldSet.TryGetQuoteResponseLevel(Tags.QuoteResponseLevel, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteResponseLevel); else fieldSet.Set(Tags.QuoteResponseLevel, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				private QuoteCancelNoQuoteEntriesCollection noQuoteEntries;
				/// <summary>
				/// <para>The number of quote entries for a QuoteSet.</para>
				/// <para>The number of securities whose quotes are to be canceled</para>
				/// </summary>
				public QuoteCancelNoQuoteEntriesCollection NoQuoteEntries
				{
					get
					{
						return noQuoteEntries;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteCancel(Message message)
				{
					this.fieldSet = message;
					this.noQuoteEntries = new QuoteCancelNoQuoteEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteEntries));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteCancel()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Cancel, new Dialect(ProtocolVersion.FIX42));
					this.noQuoteEntries = new QuoteCancelNoQuoteEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteEntries));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteCancel(System.String quoteID, QuoteCancelType quoteCancelType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Cancel, new Dialect(ProtocolVersion.FIX42));
					QuoteID = quoteID;
					QuoteCancelType = quoteCancelType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(QuoteCancel value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>The Quote Status Request message is used by the institution to generate an execution report that contains the quote status message back from the counterparty. It is used to retrieve the status of the originating party's quotes and not to obtain market data information.</para>
			/// <para>Option Usage:</para>
			/// <para>To retrieve all quotes for a given underlying symbol, use part of the symbology fields.</para>
			/// </summary>
			public class QuoteStatusRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteID); else fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side? Side
				{
					get
					{
						Side v;
						if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteStatusRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteStatusRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Status_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteStatusRequest(System.String symbol)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Status_Request, new Dialect(ProtocolVersion.FIX42));
					Symbol = symbol;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(QuoteStatusRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>An optional response to Quote, Mass Quote, Quote Cancel, and Quote Request message is the Quote Acknowledgement message. The use of the Quote Acknowledgement message is optional per Quote, Mass Quote, or Quote Request message. It is intended to provide application level acknowledgement of quotes. The level of response requested from a receiver of the Quote Acknowledgement message is specified in the QuoteResponseLevel tag.</para>
			/// </summary>
			public class QuoteAcknowledgement
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote request</para>
				/// <para>Required when acknowledgment is in response to a Quote Request message</para>
				/// </summary>
				public System.String QuoteReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteReqID); else fieldSet.Set(Tags.QuoteReqID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// <para>Required when acknowledgment is in response to a Quote message</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteID); else fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Identifies the status of the quote acknowledgement.</para>
				/// <para>Valid values:</para>
				/// <para>0-Accepted</para>
				/// <para>1-Canceled for Symbol(s)</para>
				/// <para>2-Canceled for Security Type(s)</para>
				/// <para>3-Canceled for Underlying</para>
				/// <para>4-Canceled All</para>
				/// <para>5-Rejected</para>
				/// <para>Status of the quote acknowledgement.</para>
				/// </summary>
				public QuoteAckStatus QuoteAckStatus
				{
					get
					{
						return fieldSet.GetQuoteAckStatus(Tags.QuoteAckStatus);
					}
					set
					{
						fieldSet.Set(Tags.QuoteAckStatus, value);
					}
				}

				/// <summary>
				/// <para>Reason Quote was rejected:</para>
				/// <para>Valid Values:</para>
				/// <para>1 = Unknown symbol (Security)</para>
				/// <para>2 = Exchange(Security) closed</para>
				/// <para>3 = Quote Request exceeds limit</para>
				/// <para>4 = Too late to enter</para>
				/// <para>5 = Unknown Quote</para>
				/// <para>6 = Duplicate Quote 7 = Invalid bid/ask spread</para>
				/// <para>8 = Invalid price</para>
				/// <para>9 = Not authorized to quote security</para>
				/// <para>Reason Quote was rejected.</para>
				/// </summary>
				public QuoteRejectReason? QuoteRejectReason
				{
					get
					{
						QuoteRejectReason v;
						if (fieldSet.TryGetQuoteRejectReason(Tags.QuoteRejectReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteRejectReason); else fieldSet.Set(Tags.QuoteRejectReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// <para>Valid Values:</para>
				/// <para>0 - No Acknowledgement (Default)</para>
				/// <para>1 - Acknowledge only negative or erroneous quotes</para>
				/// <para>2 - Acknowledge each Quote messages</para>
				/// <para>Level of Response requested from receiver of Quote messages. Is echoed back to the counterparty.</para>
				/// </summary>
				public QuoteResponseLevel? QuoteResponseLevel
				{
					get
					{
						QuoteResponseLevel v;
						if (fieldSet.TryGetQuoteResponseLevel(Tags.QuoteResponseLevel, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteResponseLevel); else fieldSet.Set(Tags.QuoteResponseLevel, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				private QuoteAcknowledgementNoQuoteSetsCollection noQuoteSets;
				/// <summary>
				/// <para>The number of sets of quotes in the message.</para>
				/// <para>The number of sets of quotes in the message</para>
				/// </summary>
				public QuoteAcknowledgementNoQuoteSetsCollection NoQuoteSets
				{
					get
					{
						return noQuoteSets;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteAcknowledgement(Message message)
				{
					this.fieldSet = message;
					this.noQuoteSets = new QuoteAcknowledgementNoQuoteSetsCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteSets));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteAcknowledgement()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Acknowledgement, new Dialect(ProtocolVersion.FIX42));
					this.noQuoteSets = new QuoteAcknowledgementNoQuoteSetsCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteSets));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public QuoteAcknowledgement(QuoteAckStatus quoteAckStatus)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Quote_Acknowledgement, new Dialect(ProtocolVersion.FIX42));
					QuoteAckStatus = quoteAckStatus;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(QuoteAcknowledgement value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.Quotation
	{
			/// <summary>
			/// <para>The Mass Quote message can contain quotes for multiple securities to support applications that allow for the mass quoting of an option series. Two levels of repeating groups have been provided to minimize the amount of data required to submit a set of quotes for a class of options (e.g. all option series for IBM).</para>
			/// <para>A QuoteSet specifies the first level of repeating tags for the Mass Quote message. It represents a group of related quotes and can, for example, represent an option class.</para>
			/// <para>Each QuoteSet contains an optional repeating group of QuoteEntries which can represent an option series.</para>
			/// <para>It is possible the number of Quote Entries for a Quote Set (option class) could exceed one's physical or practical message size. It may be necessary to fragment a message across multiple Quote messages. Message size limits must be mutually agreed to with one's counterparties.</para>
			/// <para>The grouping of quotes is as follows:</para>
			/// <para>NoQuoteSets - specifies the number of sets of quotes contained in the message
			///     QuoteSetID - Is a unique ID given to the quote set
			///     Information regarding the security to which all of the quotes belong
			///     TotQuoteEntries - defines the number of quotes for the quote set across all messages
			///     NoQuoteEntries - defines the number of quotes contained within this message for this quote set
			///         QuoteEntryID - Is a unique ID given to a specific quote entry
			///         Information regarding the specific quote (bid/ask size and price)</para>
			/// <para>If there are too many Quote Entries for a Quote Set to fit into one physical message, then the quotes can be continued in another Mass Quote message by repeating all of the QuoteSet information and then specifying the number of Quote Entries (related symbols) in the continued message. The TotQuoteEntries is provided to optionally indicate to the counterparty the total number of Quote Entries for a Quote Set in multiple Quote messages. This permits, but does not require, a receiving application to react in a stateful manner where it can determine if it has received all quotes for a Quote Set before carrying out some action. However, the overall approach to fragmentation is to permit each Mass Quote message to be processed in a stateless manner as it is received. Each Mass Quote message should contain enough information to have the Quote Entries applied to a market without requiring the next message if fragmentation has occurred. Also, a continued message should not require any information from the previous message.</para>
			/// <para>Maximum message size for fragmentation purposes can be determined by using the optional MaxMessageSize field in the Logon message or by mutual agreement between counterparties.</para>
			/// <para>Requesting Acknowledgement for Mass Quotes</para>
			/// <para>Applications can optionally support acknowledgement of quotes using the QuoteResponseLevel tag. The QuoteResponseLevel is used to specify the level of acknowledgement requested from the counterparty. A QuoteResponseLevel of 0 indicates that no acknowledgement is requested. A ResponseLevel of 1 requests acknowledgement of invalid or erroneous quotes. A QuoteResponseLevel of 2 requests acknowledgement of each Mass Quote message.</para>
			/// <para>See Appendix H: Mass Quote Message Scenarios</para>
			/// <para>Notes on usage for Options Markets:</para>
			/// <para>It is assumed that for many options markets, the Mass Quote message will be used to generate quotes in high volumes in an unsolicited manner. This means that multiple quotes will be sent to the counterparty (an exchange) without acknowledgement. The Mass Quote message can be used to send quotes for multiple classes, each with multiple series.</para>
			/// <para>Example: Multiple Option Series for a single Option Class (No Fragmentation)</para>
			/// <para>QuoteID=XXX
			/// QuoteReqID=YYY
			/// NoQuoteSets=1
			///     QuoteSetID=1
			///     Symbol=AA
			///     TotQuoteEntries=2
			///     NoQuoteEntries=2
			///     Other quote set fields
			///     QuoteEntryID=1
			///         MaturyMonthYear=199901
			///         StrikePrice=25.00
			///         PutOrCall=1
			///         BixPx=5.00
			///         OfferPx=5.25
			///         BidSize=10
			///         OfferSize=10
			///     QuoteEntryID=2
			///         MaturyMonthYear=199901
			///         StrikePrice=30.00
			///         PutOrCall=1
			///         BixPx=3.00
			///         OfferPx=3.25
			///         BidSize=10
			///         OfferSize=10</para>
			/// <para>Example: Multiple Option Series for a single Option Class (Fragmentation)</para>
			/// <para>First Message:</para>
			/// <para>QuoteID=XXX
			/// QuoteReqID=YYY
			/// NoQuoteSets=1
			///     QuoteSetID=1
			///     Symbol=AA
			///     TotQuoteEntries=3
			///     NoQuoteEntries=2
			///     Other quote set fields
			///     QuoteEntryID=1
			///         MaturyMonthYear=199901
			///         StrikePrice=25.00
			///         PutOrCall=1
			///         BixPx=5.00
			///         OfferPx=5.25
			///         BidSize=10
			///         OfferSize=10
			///     QuoteEntryID=2
			///         MaturyMonthYear=199901
			///         StrikePrice=30.00
			///         PutOrCall=1
			///         BixPx=3.00
			///         OfferPx=3.25
			///         BidSize=10
			///         OfferSize=10</para>
			/// <para>Second Message:</para>
			/// <para>QuoteID=XXX
			/// QuoteReqID=YYY
			/// NoQuoteSets=1
			///     QuoteSetID=1
			///     Symbol=AA
			///     Other quote set fields
			///     TotQuoteEntries=3
			///     NoQuoteEntries=1
			///     QuoteEntryID=3
			///         MaturyMonthYear=199901
			///         StrikePrice=35.00
			///         PutOrCall=1
			///         BixPx=2.00
			///         OfferPx=2.25
			///         BidSize=10
			///         OfferSize=10</para>
			/// </summary>
			public class MassQuote
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for quote request</para>
				/// <para>Required when quote is in response to a Quote Request message</para>
				/// </summary>
				public System.String QuoteReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteReqID); else fieldSet.Set(Tags.QuoteReqID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						return fieldSet.Get(Tags.QuoteID);
					}
					set
					{
						fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// <para>Valid Values:</para>
				/// <para>0 - No Acknowledgement (Default)</para>
				/// <para>1 - Acknowledge only negative or erroneous quotes</para>
				/// <para>2 - Acknowledge each Quote messages</para>
				/// <para>Level of Response requested from receiver of Quote messages.</para>
				/// </summary>
				public QuoteResponseLevel? QuoteResponseLevel
				{
					get
					{
						QuoteResponseLevel v;
						if (fieldSet.TryGetQuoteResponseLevel(Tags.QuoteResponseLevel, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteResponseLevel); else fieldSet.Set(Tags.QuoteResponseLevel, value.Value);
					}
				}

				/// <summary>
				/// <para>Default Bid Size.</para>
				/// <para>Default Bid Size for quote contained within this Quote message - if not explicitly provided.</para>
				/// </summary>
				public System.Double? DefBidSize
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DefBidSize, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DefBidSize); else fieldSet.Set(Tags.DefBidSize, value.Value);
					}
				}

				/// <summary>
				/// <para>Default Offer Size.</para>
				/// <para>Default Offer Size for quotes contained within this Quote message - if not explicitly provided.</para>
				/// </summary>
				public System.Double? DefOfferSize
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DefOfferSize, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DefOfferSize); else fieldSet.Set(Tags.DefOfferSize, value.Value);
					}
				}

				private MassQuoteNoQuoteSetsCollection noQuoteSets;
				/// <summary>
				/// <para>The number of sets of quotes in the message.</para>
				/// <para>The number of sets of quotes in the message</para>
				/// </summary>
				public MassQuoteNoQuoteSetsCollection NoQuoteSets
				{
					get
					{
						return noQuoteSets;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MassQuote(Message message)
				{
					this.fieldSet = message;
					this.noQuoteSets = new MassQuoteNoQuoteSetsCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteSets));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MassQuote()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Mass_Quote, new Dialect(ProtocolVersion.FIX42));
					this.noQuoteSets = new MassQuoteNoQuoteSetsCollection(fieldSet, fieldSet.GetGroup(Tags.NoQuoteSets));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MassQuote(System.String quoteID)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Mass_Quote, new Dialect(ProtocolVersion.FIX42));
					QuoteID = quoteID;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(MassQuote value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.MarketData
	{
			/// <summary>
			/// <para>Some systems allow the transmission of real-time quote, order, trade and/or other price information on a subscription basis. A Market Data Request is a general request for market data on specific securities or forex quotes.</para>
			/// <para>A successful Market Data Request returns one or more Market Data messages containing one or more Market Data Entries. Each Market Data Entry is a Bid, an Offer, a Trade associated with a security, the opening, closing, or settlement price of a security, the value of an index, or the trading session high price, low price, or VWAP. Market Data Entries have a price and usually a quantity associated with them. For example, in an order book environment, requesting just the top of book will result in only two active Market Data Entries at a time - one for the best Bid and one for the best Offer. For a full book, the Bid and Offer side may each have several Market Data Entries. Each Market Data Entry might represent an aggregate for each price tier, and only one Market Data Entry per side per price would be active at a time. This is referred to as an Aggregated book. Or several Market Data Entries at one price tier could each represent a broker, Market Maker, ECN or Exchange's quote in a security, or individual orders in a book. This is a Non-Aggregated book. Alternately, a Market Data Entry could represent a completed trade in a security, the value of an index, the opening, closing, or settlement price of an instrument, or the trading session high price, low price, or VWAP.</para>
			/// <para>If the message is used for foreign exchange, conventions for identifying the forex transaction are as follows:</para>
			/// <list type="bullet"><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item></list><para>A Snapshot causes the current state of the market to be sent. A Snapshot + Updates causes the current state of the market to be sent, and any updates as they occur, until the client requests that the Snapshot + Updates be disabled.</para>
			/// <para>When just a Snapshot is requested, the complete data for only one security or forex quote will be returned per FIX Market Data message.</para>
			/// <para>When Snapshot + Updates is requested, updates may be full or incremental:</para>
			/// <list type="bullet"><item>Full Refresh. This mode is optimized to trade off increased bandwidth for simplicity in processing and is intended for requests on only a few instruments. Each FIX Market Data message in response to the request will contain the complete data requested for one instrument. If more than just the top of book is requested, this means that both sides, and all price tiers, must be reported in that Market Data message.Incremental Refresh. This mode is optimized for handling requests for many instruments while conserving bandwidth. Each Market Data Entry is assigned an MDEntryID unique among all other active entries, and several incremental updates of entries for different instruments can be included in one FIX Market Data message.</item><item>Full Refresh. This mode is optimized to trade off increased bandwidth for simplicity in processing and is intended for requests on only a few instruments. Each FIX Market Data message in response to the request will contain the complete data requested for one instrument. If more than just the top of book is requested, this means that both sides, and all price tiers, must be reported in that Market Data message.Incremental Refresh. This mode is optimized for handling requests for many instruments while conserving bandwidth. Each Market Data Entry is assigned an MDEntryID unique among all other active entries, and several incremental updates of entries for different instruments can be included in one FIX Market Data message.</item></list><para>One specifies whether a list of trades, a 1-sided or 2-sided book, index, opening, closing, settlement, high, low and VWAP prices should be returned by using the NoMDEntryTypes field and MDEntryType repeating group to list all MDEntryType values that should be returned.</para>
			/// <para>While this document specifies many parameters and modes in a request, the recipient of the request is not required to support all of them. A Market Data Request Reject may be sent in response to a request indicating that it cannot be honored.</para>
			/// </summary>
			public class MarketDataRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Market Data Request</para>
				/// <para>Must be unique, or the ID of previous Market Data Request to disable if SubscriptionRequestType = Disable previous Snapshot + Updates Request (2).</para>
				/// </summary>
				public System.String MDReqID
				{
					get
					{
						return fieldSet.Get(Tags.MDReqID);
					}
					set
					{
						fieldSet.Set(Tags.MDReqID, value);
					}
				}

				/// <summary>
				/// <para>Subscription Request Type</para>
				/// <para>Valid values:</para>
				/// <para>0 = Snapshot</para>
				/// <para>1 = Snapshot + Updates (Subscribe)</para>
				/// <para>2 = Disable previous Snapshot + Update Request (Unsubscribe)</para>
				/// <para>SubcriptionRequestType indicates to the other party what type of response is expected. A snapshot request only asks for current information. A subscribe request asks for updates as the status changes. Unsubscribe will cancel any future update messages from the counter party.</para>
				/// </summary>
				public SubscriptionRequestType SubscriptionRequestType
				{
					get
					{
						return fieldSet.GetSubscriptionRequestType(Tags.SubscriptionRequestType);
					}
					set
					{
						fieldSet.Set(Tags.SubscriptionRequestType, value);
					}
				}

				/// <summary>
				/// <para>Depth of market for Book Snapshot</para>
				/// <para>Valid values:</para>
				/// <para>0 = Full Book</para>
				/// <para>1 = Top of Book</para>
				/// <para>N&gt;1 = Report best N price tiers of data</para>
				/// </summary>
				public System.String MarketDepth
				{
					get
					{
						return fieldSet.Get(Tags.MarketDepth);
					}
					set
					{
						fieldSet.Set(Tags.MarketDepth, value);
					}
				}

				/// <summary>
				/// <para>Specifies the type of Market Data update.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Full Refresh</para>
				/// <para>1 = Incremental Refresh</para>
				/// <para>Required if SubscriptionRequestType = Snapshot + Updates (1).</para>
				/// </summary>
				public MDUpdateType? MDUpdateType
				{
					get
					{
						MDUpdateType v;
						if (fieldSet.TryGetMDUpdateType(Tags.MDUpdateType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MDUpdateType); else fieldSet.Set(Tags.MDUpdateType, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies whether or not book entries should be aggregated.</para>
				/// <para>Valid values:</para>
				/// <para>Y = one book entry per side per price</para>
				/// <para>N = Multiple entries per side per price allowed</para>
				/// <para>(Not specified) = broker option</para>
				/// </summary>
				public AggregatedBook? AggregatedBook
				{
					get
					{
						AggregatedBook v;
						if (fieldSet.TryGetAggregatedBook(Tags.AggregatedBook, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AggregatedBook); else fieldSet.Set(Tags.AggregatedBook, value.Value);
					}
				}

				private MarketDataRequestNoMDEntryTypesCollection noMDEntryTypes;
				/// <summary>
				/// <para>Number of MDEntryType fields requested.</para>
				/// <para>Number of MDEntryType fields requested.</para>
				/// </summary>
				public MarketDataRequestNoMDEntryTypesCollection NoMDEntryTypes
				{
					get
					{
						return noMDEntryTypes;
					}
				}

				private MarketDataRequestNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Number of symbols requested.</para>
				/// </summary>
				public MarketDataRequestNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequest(Message message)
				{
					this.fieldSet = message;
					this.noMDEntryTypes = new MarketDataRequestNoMDEntryTypesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntryTypes));
					this.noRelatedSym = new MarketDataRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Request, new Dialect(ProtocolVersion.FIX42));
					this.noMDEntryTypes = new MarketDataRequestNoMDEntryTypesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntryTypes));
					this.noRelatedSym = new MarketDataRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequest(System.String mDReqID, SubscriptionRequestType subscriptionRequestType, System.String marketDepth)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Request, new Dialect(ProtocolVersion.FIX42));
					MDReqID = mDReqID;
					SubscriptionRequestType = subscriptionRequestType;
					MarketDepth = marketDepth;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(MarketDataRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.MarketData
	{
			/// <summary>
			/// <para>The Market Data messages are used as the response to a Market Data Request message. In all cases, one Market Data message refers only to one Market Data Request. It can be used to transmit a 2-sided book of orders or list of quotes, a list of trades, index values, opening, closing, settlement, high, low, or VWAP prices, or any combination of these.</para>
			/// <para>Market Data messages sent as the result of a Market Data Request message are tagged with the appropriate MDReqID. Unsolicited Market Data messages can be sent; in such cases, MDReqID will not be present.</para>
			/// <para>If the message is used for foreign exchange, conventions for identifying the forex transaction are as follows:</para>
			/// <list type="bullet"><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).See Appendix O - Foreign Exchange Trading</item></list><para>Market Data messages include many fields, and not all are required to be used. A firm may, at its option, choose to send the minimum fields required, or may choose to send more information, such as tick direction, tagging of best quotes, etc.</para>
			/// <para>Market Data messages can take two forms. The first Market Data message format used for a Snapshot, or a Snapshot + Updates where MDUpdateType = Full Refresh (0) is as follows:</para>
			/// <list type="bullet"><item>For Market Data Requests where a Bid or Offer is added, changed, or deleted, every update to a Market Data Entry results in a new Market Data message that contains the entirety of the data requested for that instrument, not just the changed Market Data Entry. In other words, both sides of the market, or just one side in the case of a request of only bids or offers, for the depth requested, must be sent in one FIX Market Data message.A Market Data message may contain several trades, an index value, opening, closing, settlement, high, low, and/or VWAP price for one instrument, but only one instrument per message.Messages containing bids and/or offers cannot contain trades, index value, opening, closing, settlement, high, low, and/or VWAP prices.</item><item>For Market Data Requests where a Bid or Offer is added, changed, or deleted, every update to a Market Data Entry results in a new Market Data message that contains the entirety of the data requested for that instrument, not just the changed Market Data Entry. In other words, both sides of the market, or just one side in the case of a request of only bids or offers, for the depth requested, must be sent in one FIX Market Data message.A Market Data message may contain several trades, an index value, opening, closing, settlement, high, low, and/or VWAP price for one instrument, but only one instrument per message.Messages containing bids and/or offers cannot contain trades, index value, opening, closing, settlement, high, low, and/or VWAP prices.</item><item>For Market Data Requests where a Bid or Offer is added, changed, or deleted, every update to a Market Data Entry results in a new Market Data message that contains the entirety of the data requested for that instrument, not just the changed Market Data Entry. In other words, both sides of the market, or just one side in the case of a request of only bids or offers, for the depth requested, must be sent in one FIX Market Data message.A Market Data message may contain several trades, an index value, opening, closing, settlement, high, low, and/or VWAP price for one instrument, but only one instrument per message.Messages containing bids and/or offers cannot contain trades, index value, opening, closing, settlement, high, low, and/or VWAP prices.</item></list><para>Market Data - Snapshot / Full Refresh</para>
			/// </summary>
			public class MarketDataSnapshotFullRefresh
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Market Data Request</para>
				/// <para>Conditionally required if this message is in response to a Market Data Request.</para>
				/// </summary>
				public System.String MDReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MDReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MDReqID); else fieldSet.Set(Tags.MDReqID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Identifies a firm's financial status.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Bankrupt</para>
				/// </summary>
				public FinancialStatus? FinancialStatus
				{
					get
					{
						FinancialStatus v;
						if (fieldSet.TryGetFinancialStatus(Tags.FinancialStatus, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FinancialStatus); else fieldSet.Set(Tags.FinancialStatus, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of Corporate Action.</para>
				/// <para>Valid values:</para>
				/// <para>A = Ex-Dividend</para>
				/// <para>B = Ex-Distribution</para>
				/// <para>C = Ex-Rights</para>
				/// <para>D = New</para>
				/// <para>E = Ex-Interest</para>
				/// </summary>
				public CorporateAction? CorporateAction
				{
					get
					{
						CorporateAction v;
						if (fieldSet.TryGetCorporateAction(Tags.CorporateAction, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CorporateAction); else fieldSet.Set(Tags.CorporateAction, value.Value);
					}
				}

				/// <summary>
				/// <para>Total volume (quantity) traded.</para>
				/// <para>Total volume traded in this trading session for this security.</para>
				/// </summary>
				public System.Double? TotalVolumeTraded
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.TotalVolumeTraded, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TotalVolumeTraded); else fieldSet.Set(Tags.TotalVolumeTraded, value.Value);
					}
				}

				private MarketDataSnapshotFullRefreshNoMDEntriesCollection noMDEntries;
				/// <summary>
				/// <para>Number of entries in Market Data message.</para>
				/// <para>Number of entries following.</para>
				/// </summary>
				public MarketDataSnapshotFullRefreshNoMDEntriesCollection NoMDEntries
				{
					get
					{
						return noMDEntries;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataSnapshotFullRefresh(Message message)
				{
					this.fieldSet = message;
					this.noMDEntries = new MarketDataSnapshotFullRefreshNoMDEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntries));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataSnapshotFullRefresh()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Snapshot_Full_Refresh, new Dialect(ProtocolVersion.FIX42));
					this.noMDEntries = new MarketDataSnapshotFullRefreshNoMDEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntries));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataSnapshotFullRefresh(System.String symbol)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Snapshot_Full_Refresh, new Dialect(ProtocolVersion.FIX42));
					Symbol = symbol;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(MarketDataSnapshotFullRefresh value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.MarketData
	{
			/// <summary>
			/// <para>The second Market Data message format is used for incremental updates. Market Data Entries may have an MDEntryID unique among all currently active Market Data Entries so they can be referenced for the purposes of deleting and changing them later. When changing a Market Data Entry, it may keep the same MDEntryID, in which case only MDEntryID would be populated, or the MDEntryID may change, in which case MDEntryID will contain the new ID, and MDEntryRefID will contain the ID of the Market Data Entry being changed. An MDEntryID can be reused within a day only if it has first been deleted.</para>
			/// <para>Alternately, in the case of displaying the best quotes of Market Makers or Exchanges, and not orders in an order book, MDEntryID can be omitted for simplification. In this case, a New Market Data Entry will replace the previous best quote for that side and symbol for the specified Market Maker or Exchange. Deletion of a Market Data Entry would not specify an MDEntryID or MDRefID, and would remove the most recent Market Data Entry for the specified symbol, side, and Market Maker or Exchange. A Change of a Market Data Entry would not specify an MDEntryID or MDRefID, and would replace the most recent Market Data Entry for the specified symbol, side, and Market Maker or Exchange.</para>
			/// <para>The Market Data message for incremental updates may contain any combination of new, changed, or deleted Market Data Entries, for any combination of instruments, with any combination of trades, quotes, index values, open, close, settlement, high, low, and VWAP prices, so long as the maximum FIX message size is not exceeded. All of these types of Market Data Entries can be changed and deleted.</para>
			/// <para>Adding, Changing, or Deleting Market Data Entries requires special consideration of the MDEntryPositionNo field, if the sender wishes to specify it and the receiver wishes to process it. For example, assume ten bids for a security. Adding a bid with MDEntryPositionNo = 4 requires the receiver to shift down other Market Data Entries, i.e. the Market Data Entry in the 4th display position will shift to the 5th, the 5th shifts to the 6th, etc. until the 10th shifts to the 11th. The sender must NOT send a modification of all MDEntries in the 4th through 10th positions just to update the MDEntryPositionNo field; the recipient must infer the change. Similarly, deleting a Market Data Entry in the 7th position causes the 8th Market Data Entry to move into the 7th position, the 9th to shift into the 8th position, etc. A Change of the MDEntryPositionNo field of a Market Data Entry causes the Market Data Entries lying between the old and new positions to shift. For instance, a Market Data Entry that occupied the 5th position is changed to the 8th position. This means that the Market Data Entry in the 6th position shifts up to the 5th position, the 7th position shifts to the 6th, and what was in the 8th position shifts into the 7th to make room for the changed Market Data Entry that is being moved into the 8th position.</para>
			/// <para>Several techniques are employed to conserve bandwidth:</para>
			/// <list type="bullet"><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item><item>An instrument only needs to be identified when a Market Data Entry is first created.In cases where the identification of an instrument is long, the sender has the option of referring to a previous active Market Data Entry of the same instrument instead of duplicating the information.A new Market Data Entry will default to the same instrument of the previous Market Data Entry in the same Market Data message if neither Symbol nor MDEntryRefID are specified.In the case of a change in a Market Data Entry, only the fields changing need to be sent as part of the change to the Market Data Entry; for example, a change of the MDEntrySize but not the MDEntryPx or other attributes of the Market Data Entry only requires listing the MDEntrySize field, in addition to MDUpdateAction and MDEntryID if used in the original Market Data EntryWhen creating a new Market Data Entry with a future or option instrument similar to the instrument in the previous Market Data Entry in the same FIX message, one may send just symbol identification fields that have changed, such as MaturityMonthYear, MaturityDay, PutOrCall, StrikePrice, OptAttribute, and SecurityExchange.MDEntryID can be reused within the same day after it is deleted. This is helpful for distributing order books because an order that is suspended and then reinstated can have its MDEntryID deleted upon suspension and later reused, with MDUpdateAction = New(0) upon reinstatement, thus avoiding having to re-map the MDEntryID.</item></list>
			/// </summary>
			public class MarketDataIncrementalRefresh
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Market Data Request</para>
				/// <para>Conditionally required if this message is in response to a Market Data Request.</para>
				/// </summary>
				public System.String MDReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MDReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MDReqID); else fieldSet.Set(Tags.MDReqID, value);
					}
				}

				private MarketDataIncrementalRefreshNoMDEntriesCollection noMDEntries;
				/// <summary>
				/// <para>Number of entries in Market Data message.</para>
				/// <para>Number of entries following.</para>
				/// </summary>
				public MarketDataIncrementalRefreshNoMDEntriesCollection NoMDEntries
				{
					get
					{
						return noMDEntries;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataIncrementalRefresh(Message message)
				{
					this.fieldSet = message;
					this.noMDEntries = new MarketDataIncrementalRefreshNoMDEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntries));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataIncrementalRefresh()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Incremental_Refresh, new Dialect(ProtocolVersion.FIX42));
					this.noMDEntries = new MarketDataIncrementalRefreshNoMDEntriesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMDEntries));
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(MarketDataIncrementalRefresh value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.MarketData
	{
			/// <summary>
			/// <para>The Market Data Request Reject is used when the broker cannot honor the Market Data Request, due to business or technical reasons. Brokers may choose to limit various parameters, such as the size of requests, whether just the top of book or the entire book may be displayed, and whether Full or Incremental updates must be used.</para>
			/// </summary>
			public class MarketDataRequestReject
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Market Data Request</para>
				/// <para>Must refer to the MDReqID of the request.</para>
				/// </summary>
				public System.String MDReqID
				{
					get
					{
						return fieldSet.Get(Tags.MDReqID);
					}
					set
					{
						fieldSet.Set(Tags.MDReqID, value);
					}
				}

				/// <summary>
				/// <para>Reason for the rejection of a Market Data request.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Unknown symbol</para>
				/// <para>1 = Duplicate MDReqID</para>
				/// <para>2 = Insufficient Bandwidth</para>
				/// <para>3 = Insufficient Permissions</para>
				/// <para>4 = Unsupported SubscriptionRequestType</para>
				/// <para>5 = Unsupported MarketDepth</para>
				/// <para>6 = Unsupported MDUpdateType</para>
				/// <para>7 = Unsupported AggregatedBook</para>
				/// <para>8 = Unsupported MDEntryType</para>
				/// </summary>
				public MDReqRejReason? MDReqRejReason
				{
					get
					{
						MDReqRejReason v;
						if (fieldSet.TryGetMDReqRejReason(Tags.MDReqRejReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MDReqRejReason); else fieldSet.Set(Tags.MDReqRejReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequestReject(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequestReject()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Request_Reject, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public MarketDataRequestReject(System.String mDReqID)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Market_Data_Request_Reject, new Dialect(ProtocolVersion.FIX42));
					MDReqID = mDReqID;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(MarketDataRequestReject value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Security Definition Request message is used for the following:</para>
			/// <list type="number"><item>Request a specific Security to be traded with the second party. The request security can be defined as a complex security made up of one or more underlying securities.Request a list of the Security Types that can be traded with the second party.Request a list of Securities that can be traded with the second party. This request can optionally be qualified with Symbol, TradingSessionID, SecurityExchange, and Security Type.</item><item>Request a specific Security to be traded with the second party. The request security can be defined as a complex security made up of one or more underlying securities.Request a list of the Security Types that can be traded with the second party.Request a list of Securities that can be traded with the second party. This request can optionally be qualified with Symbol, TradingSessionID, SecurityExchange, and Security Type.</item><item>Request a specific Security to be traded with the second party. The request security can be defined as a complex security made up of one or more underlying securities.Request a list of the Security Types that can be traded with the second party.Request a list of Securities that can be traded with the second party. This request can optionally be qualified with Symbol, TradingSessionID, SecurityExchange, and Security Type.</item></list><para>See Appendix I: Security Definition, Security Status, and Trading Session Message Scenarios</para>
			/// </summary>
			public class SecurityDefinitionRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Security Definition Request.</para>
				/// </summary>
				public System.String SecurityReqID
				{
					get
					{
						return fieldSet.Get(Tags.SecurityReqID);
					}
					set
					{
						fieldSet.Set(Tags.SecurityReqID, value);
					}
				}

				/// <summary>
				/// <para>Type of Security Definition Request.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Request Security identity and specifications</para>
				/// <para>1 = Request Security identity for the specifications provided (Name of the security is not supplied)</para>
				/// <para>2 = Request List Security Types</para>
				/// <para>3 = Request List Securities (Can be qualified with Symbol, SecurityType, TradingSessionID, SecurityExchange is provided then only list Securities for the specific type)</para>
				/// </summary>
				public SecurityRequestType SecurityRequestType
				{
					get
					{
						return fieldSet.GetSecurityRequestType(Tags.SecurityRequestType);
					}
					set
					{
						fieldSet.Set(Tags.SecurityRequestType, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// <para>Symbol of the requested Security</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Symbol, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Symbol); else fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// <para>Suffix of the Requested Security</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// <para>Security ID of the requested Security</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// <para>Source of the Security ID</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// <para>Comment, instructions, or other identifying information.</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// <para>Optional Trading Session Identifier to specify a particular trading session for which you want to obtain a list of securities that are tradeable.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				private SecurityDefinitionRequestNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Number of legs that make up the Security</para>
				/// </summary>
				public SecurityDefinitionRequestNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinitionRequest(Message message)
				{
					this.fieldSet = message;
					this.noRelatedSym = new SecurityDefinitionRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinitionRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Definition_Request, new Dialect(ProtocolVersion.FIX42));
					this.noRelatedSym = new SecurityDefinitionRequestNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinitionRequest(System.String securityReqID, SecurityRequestType securityRequestType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Definition_Request, new Dialect(ProtocolVersion.FIX42));
					SecurityReqID = securityReqID;
					SecurityRequestType = securityRequestType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SecurityDefinitionRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Security Definition message is used for the following:</para>
			/// <list type="number"><item>Accept the security defined in a Security Definition message.Accept the security defined in a Security Definition message with changes to the definition and/or identity of the security.Reject the security requested in a Security Definition messageReturn a list of Security TypesReturn a list of Securities</item><item>Accept the security defined in a Security Definition message.Accept the security defined in a Security Definition message with changes to the definition and/or identity of the security.Reject the security requested in a Security Definition messageReturn a list of Security TypesReturn a list of Securities</item><item>Accept the security defined in a Security Definition message.Accept the security defined in a Security Definition message with changes to the definition and/or identity of the security.Reject the security requested in a Security Definition messageReturn a list of Security TypesReturn a list of Securities</item><item>Accept the security defined in a Security Definition message.Accept the security defined in a Security Definition message with changes to the definition and/or identity of the security.Reject the security requested in a Security Definition messageReturn a list of Security TypesReturn a list of Securities</item><item>Accept the security defined in a Security Definition message.Accept the security defined in a Security Definition message with changes to the definition and/or identity of the security.Reject the security requested in a Security Definition messageReturn a list of Security TypesReturn a list of Securities</item></list>
			/// </summary>
			public class SecurityDefinition
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Security Definition Request.</para>
				/// </summary>
				public System.String SecurityReqID
				{
					get
					{
						return fieldSet.Get(Tags.SecurityReqID);
					}
					set
					{
						fieldSet.Set(Tags.SecurityReqID, value);
					}
				}

				/// <summary>
				/// <para>Unique ID of a Security Definition message.</para>
				/// <para>Identifier for the Security Definition message</para>
				/// </summary>
				public System.String SecurityResponseID
				{
					get
					{
						return fieldSet.Get(Tags.SecurityResponseID);
					}
					set
					{
						fieldSet.Set(Tags.SecurityResponseID, value);
					}
				}

				/// <summary>
				/// <para>Type of Security Definition message response.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Accept security proposal as is</para>
				/// <para>2 = Accept security proposal with revisions as indicated in the message</para>
				/// <para>3 = List of security types returned per request</para>
				/// <para>4 = List of securities returned per request</para>
				/// <para>5 = Reject security proposal</para>
				/// <para>6 = Can not match selection criteria</para>
				/// </summary>
				public SecurityResponseType? SecurityResponseType
				{
					get
					{
						SecurityResponseType v;
						if (fieldSet.TryGetSecurityResponseType(Tags.SecurityResponseType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityResponseType); else fieldSet.Set(Tags.SecurityResponseType, value.Value);
					}
				}

				/// <summary>
				/// <para>Total number of securities.</para>
				/// </summary>
				public System.String TotalNumSecurities
				{
					get
					{
						return fieldSet.Get(Tags.TotalNumSecurities);
					}
					set
					{
						fieldSet.Set(Tags.TotalNumSecurities, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// <para>Symbol of the requested Security</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Symbol, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Symbol); else fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// <para>Suffix of the Requested Security</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// <para>Security ID of the requested Security</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// <para>Source of the Security ID</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// <para>Set to '?' if Security Definition Request is looking for the Security Types</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// <para>Comment, instructions, or other identifying information.</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				private SecurityDefinitionNoRelatedSymCollection noRelatedSym;
				/// <summary>
				/// <para>Specifies the number of repeating symbols specified.</para>
				/// <para>Number of legs that make up the Security</para>
				/// </summary>
				public SecurityDefinitionNoRelatedSymCollection NoRelatedSym
				{
					get
					{
						return noRelatedSym;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinition(Message message)
				{
					this.fieldSet = message;
					this.noRelatedSym = new SecurityDefinitionNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinition()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Definition, new Dialect(ProtocolVersion.FIX42));
					this.noRelatedSym = new SecurityDefinitionNoRelatedSymCollection(fieldSet, fieldSet.GetGroup(Tags.NoRelatedSym));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityDefinition(System.String securityReqID, System.String securityResponseID, System.String totalNumSecurities)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Definition, new Dialect(ProtocolVersion.FIX42));
					SecurityReqID = securityReqID;
					SecurityResponseID = securityResponseID;
					TotalNumSecurities = totalNumSecurities;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SecurityDefinition value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Security Status Request message provides for the ability to request the status of a security. One or more Security Status messages are returned as a result of a Security Status Request message.</para>
			/// <para>The Security Status Request message contains a SubscriptionRequestType field. This tells the counter party what type of request is being made:</para>
			/// <list type="table"><item><term>0</term><description>indicates that the requestor only wants a snapshot or the current status.</description></item><item><term>1</term><description>indicates that the requestor wants a snapshot (the current status) plus updates as the status changes. This is similar to subscribing for information and can be implemented in applications as a subscription mechanism.</description></item><item><term>2</term><description>indicates that the requestor wishes to cancel any pending snapshots or updates - in essence making this an unsubscribe operation.</description></item></list>
			/// </summary>
			public class SecurityStatusRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Security Status Request message.</para>
				/// <para>Must be unique, or the ID of previous Security Status Request to disable if SubscriptionRequestType = Disable previous Snapshot + Updates Request (2).</para>
				/// </summary>
				public System.String SecurityStatusReqID
				{
					get
					{
						return fieldSet.Get(Tags.SecurityStatusReqID);
					}
					set
					{
						fieldSet.Set(Tags.SecurityStatusReqID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Subscription Request Type</para>
				/// <para>Valid values:</para>
				/// <para>0 = Snapshot</para>
				/// <para>1 = Snapshot + Updates (Subscribe)</para>
				/// <para>2 = Disable previous Snapshot + Update Request (Unsubscribe)</para>
				/// <para>SubcriptionRequestType indicates to the other party what type of response is expected. A snapshot request only asks for current information. A subscribe request asks for updates as the status changes. Unsubscribe will cancel any future update messages from the counter party.)</para>
				/// </summary>
				public SubscriptionRequestType SubscriptionRequestType
				{
					get
					{
						return fieldSet.GetSubscriptionRequestType(Tags.SubscriptionRequestType);
					}
					set
					{
						fieldSet.Set(Tags.SubscriptionRequestType, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatusRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatusRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Status_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatusRequest(System.String securityStatusReqID, System.String symbol, SubscriptionRequestType subscriptionRequestType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Status_Request, new Dialect(ProtocolVersion.FIX42));
					SecurityStatusReqID = securityStatusReqID;
					Symbol = symbol;
					SubscriptionRequestType = subscriptionRequestType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SecurityStatusRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Security Status message provides for the ability to report changes in status to a security. The Security Status message contains fields to indicate trading status, corporate actions, financial status of the company. The Security Status message is used by one trading entity (for instance an exchange) to report changes in the state of a security.</para>
			/// <para>It is expected that the Security Status message that is sent as a response should indicate what type of request is being provided. If the message is being generated as a result of a RequestType =1, then the response should have a RequestType=1 to permit the requestor to determine why the message was sent.</para>
			/// </summary>
			public class SecurityStatus
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Security Status Request message.</para>
				/// </summary>
				public System.String SecurityStatusReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityStatusReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityStatusReqID); else fieldSet.Set(Tags.SecurityStatusReqID, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not message is being sent as a result of a subscription request or not.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Message is being sent unsolicited</para>
				/// <para>N = Message is being sent as a result of a prior request</para>
				/// <para>Set to 'Y' if message is sent as a result of a subscription request not a snapshot request</para>
				/// </summary>
				public UnsolicitedIndicator? UnsolicitedIndicator
				{
					get
					{
						UnsolicitedIndicator v;
						if (fieldSet.TryGetUnsolicitedIndicator(Tags.UnsolicitedIndicator, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.UnsolicitedIndicator); else fieldSet.Set(Tags.UnsolicitedIndicator, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies the trading status applicable to the transaction.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Opening Delay</para>
				/// <para>2 = Trading Halt</para>
				/// <para>3 = Resume</para>
				/// <para>4 = No Open/No Resume</para>
				/// <para>5 = Price Indication</para>
				/// <para>6 = Trading Range Indication</para>
				/// <para>7 = Market Imbalance Buy</para>
				/// <para>8 = Market Imbalance Sell</para>
				/// <para>9 = Market On Close Imbalance Buy</para>
				/// <para>10 = Market On Close Imbalance Sell</para>
				/// <para>12 = No Market Imbalance</para>
				/// <para>13 = No Market On Close Imbalance</para>
				/// <para>14 = ITS Pre-Opening</para>
				/// <para>15 = New Price Indication</para>
				/// <para>16 = Trade Dissemination Time</para>
				/// <para>17 = Ready to trade (start of session)</para>
				/// <para>18 = Not Available for trading (end of session)</para>
				/// <para>19 = Not Traded on this Market</para>
				/// <para>20 = Unknown or Invalid</para>
				/// <para>Identifies the trading status applicable to the transaction.</para>
				/// </summary>
				public SecurityTradingStatus? SecurityTradingStatus
				{
					get
					{
						SecurityTradingStatus v;
						if (fieldSet.TryGetSecurityTradingStatus(Tags.SecurityTradingStatus, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityTradingStatus); else fieldSet.Set(Tags.SecurityTradingStatus, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies a firm's financial status.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Bankrupt</para>
				/// </summary>
				public FinancialStatus? FinancialStatus
				{
					get
					{
						FinancialStatus v;
						if (fieldSet.TryGetFinancialStatus(Tags.FinancialStatus, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FinancialStatus); else fieldSet.Set(Tags.FinancialStatus, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of Corporate Action.</para>
				/// <para>Valid values:</para>
				/// <para>A = Ex-Dividend</para>
				/// <para>B = Ex-Distribution</para>
				/// <para>C = Ex-Rights</para>
				/// <para>D = New</para>
				/// <para>E = Ex-Interest</para>
				/// </summary>
				public CorporateAction? CorporateAction
				{
					get
					{
						CorporateAction v;
						if (fieldSet.TryGetCorporateAction(Tags.CorporateAction, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CorporateAction); else fieldSet.Set(Tags.CorporateAction, value.Value);
					}
				}

				/// <summary>
				/// <para>Denotes the reason for the Opening Delay or Trading Halt.</para>
				/// <para>Valid values:</para>
				/// <para>I = Order Imbalance</para>
				/// <para>X = Equipment Changeover</para>
				/// <para>P = News Pending</para>
				/// <para>D = News Dissemination</para>
				/// <para>E = Order Influx</para>
				/// <para>M = Additional Information</para>
				/// <para>Denotes the reason for the Opening Delay or Trading Halt.</para>
				/// </summary>
				public HaltReason? HaltReason
				{
					get
					{
						HaltReason v;
						if (fieldSet.TryGetHaltReason(Tags.HaltReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.HaltReason); else fieldSet.Set(Tags.HaltReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the halt was due to Common Stock trading being halted.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Halt was due to common stock being halted</para>
				/// <para>N = Halt was not related to a halt of the common stock</para>
				/// </summary>
				public InViewOfCommon? InViewOfCommon
				{
					get
					{
						InViewOfCommon v;
						if (fieldSet.TryGetInViewOfCommon(Tags.InViewOfCommon, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.InViewOfCommon); else fieldSet.Set(Tags.InViewOfCommon, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the halt was due to the Related Security being halted.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Halt was due to related security being halted</para>
				/// <para>N = Halt was not related to a halt of the related security</para>
				/// </summary>
				public DueToRelated? DueToRelated
				{
					get
					{
						DueToRelated v;
						if (fieldSet.TryGetDueToRelated(Tags.DueToRelated, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DueToRelated); else fieldSet.Set(Tags.DueToRelated, value.Value);
					}
				}

				/// <summary>
				/// <para>Number of shares bought.</para>
				/// </summary>
				public System.Double? BuyVolume
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.BuyVolume, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BuyVolume); else fieldSet.Set(Tags.BuyVolume, value.Value);
					}
				}

				/// <summary>
				/// <para>Number of shares sold.</para>
				/// </summary>
				public System.Double? SellVolume
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.SellVolume, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SellVolume); else fieldSet.Set(Tags.SellVolume, value.Value);
					}
				}

				/// <summary>
				/// <para>Represents an indication of the high end of the price range for a security prior to the open or reopen</para>
				/// </summary>
				public System.Double? HighPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.HighPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.HighPx); else fieldSet.Set(Tags.HighPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Represents an indication of the low end of the price range for a security prior to the open or reopen</para>
				/// </summary>
				public System.Double? LowPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LowPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LowPx); else fieldSet.Set(Tags.LowPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Price of this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
				/// <para>Represents the last price for that security either on a Consolidated or an individual participant basis at the time it is disseminated.</para>
				/// </summary>
				public System.Double? LastPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastPx); else fieldSet.Set(Tags.LastPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Trade Dissemination Time</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of adjustment.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Cancel</para>
				/// <para>2 = Error</para>
				/// <para>3 = Correction</para>
				/// </summary>
				public Adjustment? Adjustment
				{
					get
					{
						Adjustment v;
						if (fieldSet.TryGetAdjustment(Tags.Adjustment, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Adjustment); else fieldSet.Set(Tags.Adjustment, value.Value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatus(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatus()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Status, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SecurityStatus(System.String symbol)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Security_Status, new Dialect(ProtocolVersion.FIX42));
					Symbol = symbol;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SecurityStatus value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Trading Session Status Request is used to request information on the status of a market. With the move to multiple sessions occurring for a given trading party (morning and evening sessions for instance) there is a need to be able to provide information on what product is trading on what market.</para>
			/// <para>The Trading Session Status Request message can be used to inquire the trading status of a trading party. The Trading Session Status message can be used to subscribe to updates to the status of a trading session by setting the RequestType field to 1.</para>
			/// <para>To list the securities available during a particular trading session, see the SecurityDefinitionRequest message.</para>
			/// </summary>
			public class TradingSessionStatusRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Trading Session Status message.</para>
				/// <para>Must be unique, or the ID of previous Market Data Request to disable if SubscriptionRequestType = Disable previous Snapshot + Updates Request (2).</para>
				/// </summary>
				public System.String TradSesReqID
				{
					get
					{
						return fieldSet.Get(Tags.TradSesReqID);
					}
					set
					{
						fieldSet.Set(Tags.TradSesReqID, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// <para>Trading Session for which status is being requested</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Method of trading</para>
				/// <para>Valid values:</para>
				/// <para>1 = Electronic</para>
				/// <para>2 = Open Outcry</para>
				/// <para>3 = Two Party</para>
				/// <para>Method of trading</para>
				/// </summary>
				public TradSesMethod? TradSesMethod
				{
					get
					{
						TradSesMethod v;
						if (fieldSet.TryGetTradSesMethod(Tags.TradSesMethod, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesMethod); else fieldSet.Set(Tags.TradSesMethod, value.Value);
					}
				}

				/// <summary>
				/// <para>Trading Session Mode</para>
				/// <para>Valid values:</para>
				/// <para>1 = Testing</para>
				/// <para>2 = Simulated</para>
				/// <para>3 = Production</para>
				/// <para>Trading Session Mode</para>
				/// </summary>
				public TradSesMode? TradSesMode
				{
					get
					{
						TradSesMode v;
						if (fieldSet.TryGetTradSesMode(Tags.TradSesMode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesMode); else fieldSet.Set(Tags.TradSesMode, value.Value);
					}
				}

				/// <summary>
				/// <para>Subscription Request Type</para>
				/// <para>Valid values:</para>
				/// <para>0 = Snapshot</para>
				/// <para>1 = Snapshot + Updates (Subscribe)</para>
				/// <para>2 = Disable previous Snapshot + Update Request (Unsubscribe)</para>
				/// </summary>
				public SubscriptionRequestType SubscriptionRequestType
				{
					get
					{
						return fieldSet.GetSubscriptionRequestType(Tags.SubscriptionRequestType);
					}
					set
					{
						fieldSet.Set(Tags.SubscriptionRequestType, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatusRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatusRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Trading_Session_Status_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatusRequest(System.String tradSesReqID, SubscriptionRequestType subscriptionRequestType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Trading_Session_Status_Request, new Dialect(ProtocolVersion.FIX42));
					TradSesReqID = tradSesReqID;
					SubscriptionRequestType = subscriptionRequestType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(TradingSessionStatusRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.SecurityAndTradingSessionDefinitionStatus
	{
			/// <summary>
			/// <para>The Trading Session Status provides information on the status of a market. With the move to multiple sessions occurring for a given trading party (morning and evening sessions for instance) there is a need to be able to provide information on what product is trading on what market.</para>
			/// <para>The Trading Session Status can provide an optional repeating group of securities that are available for trading during that session.</para>
			/// </summary>
			public class TradingSessionStatus
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique ID of a Trading Session Status message.</para>
				/// <para>Provided for a response to a specific Trading Session Status Request message (snapshot).</para>
				/// </summary>
				public System.String TradSesReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradSesReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesReqID); else fieldSet.Set(Tags.TradSesReqID, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// <para>Identifier for Trading Session</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						return fieldSet.Get(Tags.TradingSessionID);
					}
					set
					{
						fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Method of trading</para>
				/// <para>Valid values:</para>
				/// <para>1 = Electronic</para>
				/// <para>2 = Open Outcry</para>
				/// <para>3 = Two Party</para>
				/// <para>Method of trading:</para>
				/// </summary>
				public TradSesMethod? TradSesMethod
				{
					get
					{
						TradSesMethod v;
						if (fieldSet.TryGetTradSesMethod(Tags.TradSesMethod, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesMethod); else fieldSet.Set(Tags.TradSesMethod, value.Value);
					}
				}

				/// <summary>
				/// <para>Trading Session Mode</para>
				/// <para>Valid values:</para>
				/// <para>1 = Testing</para>
				/// <para>2 = Simulated</para>
				/// <para>3 = Production</para>
				/// <para>Trading Session Mode</para>
				/// </summary>
				public TradSesMode? TradSesMode
				{
					get
					{
						TradSesMode v;
						if (fieldSet.TryGetTradSesMode(Tags.TradSesMode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesMode); else fieldSet.Set(Tags.TradSesMode, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not message is being sent as a result of a subscription request or not.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Message is being sent unsolicited</para>
				/// <para>N = Message is being sent as a result of a prior request</para>
				/// <para>'Y' if message is sent unsolicited as a result of a previous subscription request.</para>
				/// </summary>
				public UnsolicitedIndicator? UnsolicitedIndicator
				{
					get
					{
						UnsolicitedIndicator v;
						if (fieldSet.TryGetUnsolicitedIndicator(Tags.UnsolicitedIndicator, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.UnsolicitedIndicator); else fieldSet.Set(Tags.UnsolicitedIndicator, value.Value);
					}
				}

				/// <summary>
				/// <para>State of the trading session.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Halted</para>
				/// <para>2 = Open</para>
				/// <para>3 = Closed</para>
				/// <para>4 = Pre-Open</para>
				/// <para>5 = Pre-Close</para>
				/// <para>State of the trading session</para>
				/// </summary>
				public TradSesStatus TradSesStatus
				{
					get
					{
						return fieldSet.GetTradSesStatus(Tags.TradSesStatus);
					}
					set
					{
						fieldSet.Set(Tags.TradSesStatus, value);
					}
				}

				/// <summary>
				/// <para>Starting time of the trading session</para>
				/// <para>Starting time of the trading session</para>
				/// </summary>
				public System.DateTime? TradSesStartTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradSesStartTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesStartTime); else fieldSet.Set(Tags.TradSesStartTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Time of the opening of the trading session</para>
				/// <para>Time of the opening of the trading session</para>
				/// </summary>
				public System.DateTime? TradSesOpenTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradSesOpenTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesOpenTime); else fieldSet.Set(Tags.TradSesOpenTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Time of the pre-closed of the trading session</para>
				/// <para>Time of the pre-close of the trading session</para>
				/// </summary>
				public System.DateTime? TradSesPreCloseTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradSesPreCloseTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesPreCloseTime); else fieldSet.Set(Tags.TradSesPreCloseTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Closing time of the trading session</para>
				/// <para>Closing time of the trading session</para>
				/// </summary>
				public System.DateTime? TradSesCloseTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradSesCloseTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesCloseTime); else fieldSet.Set(Tags.TradSesCloseTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>End time of the trading session</para>
				/// <para>End time of the trading session</para>
				/// </summary>
				public System.DateTime? TradSesEndTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradSesEndTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradSesEndTime); else fieldSet.Set(Tags.TradSesEndTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Total volume (quantity) traded.</para>
				/// </summary>
				public System.Double? TotalVolumeTraded
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.TotalVolumeTraded, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TotalVolumeTraded); else fieldSet.Set(Tags.TotalVolumeTraded, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatus(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatus()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Trading_Session_Status, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TradingSessionStatus(System.String tradingSessionID, TradSesStatus tradSesStatus)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Trading_Session_Status, new Dialect(ProtocolVersion.FIX42));
					TradingSessionID = tradingSessionID;
					TradSesStatus = tradSesStatus;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(TradingSessionStatus value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The BidRequest Message can be used in one of two ways depending on which market conventions are being followed.</para>
			/// <para>In the "Non disclosed" convention (e.g. US/European model) the BidRequest message can be used to request a bid based on the sector, country, index and liquidity information contained within the message itself. In the "Non disclosed" convention the entry repeating group is used to define liquidity of the program. See Appendix N - Program/Basket/List Trading for an example.</para>
			/// <para>In the "Disclosed" convention (e.g. Japanese model) the BidRequest message can be used to request bids based on the ListOrderDetail messages sent in advance of BidRequest message. In the "Disclosed" convention the list repeating group is used to define which ListOrderDetail messages a bid is being sort for and the directions of the required bids.</para>
			/// <para>The pair of fields SideValue1 and SideValue2 are used to show the monetary total value in either direction (buy or sell) of the transaction without revealing whether it is the buy-side institution intention to buy or sell.</para>
			/// <para>The two repeating groups, NoEntries and NoBidComponents are mutually exclusive and a function of which bidding model is being used. If the "Non Disclosure" method is being used the portfolio of stocks being traded is described by a number of "bid desciptors" entries. If the "Disclosure" Method is being used the portfolio is fully disclosed, except for side, by a number of "list" entries enumerating the lists that list the stocks to be traded.</para>
			/// <para>A BidRequest message with BidRequestTransType cancel may be used to indicate to sell side firms that they no longer need to store details of the BidRequest as they have either lost the bid or the List has been canceled.</para>
			/// </summary>
			public class BidRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Bid Response as assigned by broker. Uniqueness must be guaranteed within a single trading day.</para>
				/// <para>Required to relate the bid response</para>
				/// </summary>
				public System.String BidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.BidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidID); else fieldSet.Set(Tags.BidID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for a Bid Request as assigned by institution. Uniqueness must be guaranteed within a single trading day.</para>
				/// </summary>
				public System.String ClientBidID
				{
					get
					{
						return fieldSet.Get(Tags.ClientBidID);
					}
					set
					{
						fieldSet.Set(Tags.ClientBidID, value);
					}
				}

				/// <summary>
				/// <para>Identifies the Bid Request message type.</para>
				/// <para>Valid values:</para>
				/// <para>N = New</para>
				/// <para>C = Cancel</para>
				/// <para>Identifies the Bid Request message transaction type</para>
				/// </summary>
				public BidRequestTransType BidRequestTransType
				{
					get
					{
						return fieldSet.GetBidRequestTransType(Tags.BidRequestTransType);
					}
					set
					{
						fieldSet.Set(Tags.BidRequestTransType, value);
					}
				}

				/// <summary>
				/// <para>Descriptive name for list order.</para>
				/// </summary>
				public System.String ListName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListName); else fieldSet.Set(Tags.ListName, value);
					}
				}

				/// <summary>
				/// <para>Total number of securities.</para>
				/// </summary>
				public System.String TotalNumSecurities
				{
					get
					{
						return fieldSet.Get(Tags.TotalNumSecurities);
					}
					set
					{
						fieldSet.Set(Tags.TotalNumSecurities, value);
					}
				}

				/// <summary>
				/// <para>Code to identify the type of Bid Request.</para>
				/// <para>Valid values:</para>
				/// <para>1 - 'Non Disclosed' Style (e.g. US/European)</para>
				/// <para>2 - 'Disclosed' Style (e.g. Japanese)</para>
				/// <para>3 - No Bidding Process</para>
				/// <para>e.g. 'Non Disclosed', 'Disclosed', No Bidding Process</para>
				/// </summary>
				public System.String BidType
				{
					get
					{
						return fieldSet.Get(Tags.BidType);
					}
					set
					{
						fieldSet.Set(Tags.BidType, value);
					}
				}

				/// <summary>
				/// <para>Total number of tickets.</para>
				/// <para>Total number of tickets/allocations assuming fully executed</para>
				/// </summary>
				public System.String NumTickets
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.NumTickets, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.NumTickets); else fieldSet.Set(Tags.NumTickets, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// <para>Used to represent the currency of monetary amounts.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Amounts in currency</para>
				/// <para>Expressed in Currency</para>
				/// </summary>
				public System.Double? SideValue1
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.SideValue1, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SideValue1); else fieldSet.Set(Tags.SideValue1, value.Value);
					}
				}

				/// <summary>
				/// <para>Amounts in currency</para>
				/// <para>Expressed in Currency</para>
				/// </summary>
				public System.Double? SideValue2
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.SideValue2, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SideValue2); else fieldSet.Set(Tags.SideValue2, value.Value);
					}
				}

				private BidRequestNoBidDescriptorsCollection noBidDescriptors;
				/// <summary>
				/// <para>Number of BidDescriptor entries.</para>
				/// <para>Used if BidType='Non Disclosed'</para>
				/// </summary>
				public BidRequestNoBidDescriptorsCollection NoBidDescriptors
				{
					get
					{
						return noBidDescriptors;
					}
				}

				private BidRequestNoBidComponentsCollection noBidComponents;
				/// <summary>
				/// <para>Indicates the number of list entries.</para>
				/// <para>Used if BidType='Disclosed'</para>
				/// </summary>
				public BidRequestNoBidComponentsCollection NoBidComponents
				{
					get
					{
						return noBidComponents;
					}
				}

				/// <summary>
				/// <para>Code to identify the type of liquidity indicator.</para>
				/// <para>Valid values:</para>
				/// <para>1 - 5day moving average</para>
				/// <para>2 - 20 day moving average</para>
				/// <para>3 - Normal Market Size</para>
				/// <para>4 - Other</para>
				/// </summary>
				public LiquidityIndType? LiquidityIndType
				{
					get
					{
						LiquidityIndType v;
						if (fieldSet.TryGetLiquidityIndType(Tags.LiquidityIndType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LiquidityIndType); else fieldSet.Set(Tags.LiquidityIndType, value.Value);
					}
				}

				/// <summary>
				/// <para>Overall weighted average liquidity expressed as a % of average daily volume. Represented as a percentage.</para>
				/// <para>Overall weighted average liquidity expressed as a % of average daily volume</para>
				/// </summary>
				public System.String WtAverageLiquidity
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.WtAverageLiquidity, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.WtAverageLiquidity); else fieldSet.Set(Tags.WtAverageLiquidity, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not to exchange for phsyical.</para>
				/// <para>Valid values:</para>
				/// <para>Y = True</para>
				/// <para>N = False</para>
				/// </summary>
				public ExchangeForPhysical? ExchangeForPhysical
				{
					get
					{
						ExchangeForPhysical v;
						if (fieldSet.TryGetExchangeForPhysical(Tags.ExchangeForPhysical, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExchangeForPhysical); else fieldSet.Set(Tags.ExchangeForPhysical, value.Value);
					}
				}

				/// <summary>
				/// <para>Value of stocks in Currency</para>
				/// <para>% value of stocks outside main country in Currency</para>
				/// </summary>
				public System.Double? OutMainCntryUIndex
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OutMainCntryUIndex, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OutMainCntryUIndex); else fieldSet.Set(Tags.OutMainCntryUIndex, value.Value);
					}
				}

				/// <summary>
				/// <para>Percentage of program that crosses in Currency. Represented as a percentage.</para>
				/// <para>% of program that crosses in Currency</para>
				/// </summary>
				public System.String CrossPercent
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CrossPercent, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CrossPercent); else fieldSet.Set(Tags.CrossPercent, value);
					}
				}

				/// <summary>
				/// <para>Code to identify the desired frequency of progress reports.</para>
				/// <para>Valid values:</para>
				/// <para>1 - BuySide explicitly requests status using StatusRequest (Default) The sell-side firm can however, send a DONE status List Status Response in an unsolicited fashion</para>
				/// <para>2 - SellSide periodically sends status using ListStatus. Period optionally specified in ProgressPeriod</para>
				/// <para>3 - Real-time execution reports (to be discouraged)</para>
				/// </summary>
				public ProgRptReqs? ProgRptReqs
				{
					get
					{
						ProgRptReqs v;
						if (fieldSet.TryGetProgRptReqs(Tags.ProgRptReqs, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ProgRptReqs); else fieldSet.Set(Tags.ProgRptReqs, value.Value);
					}
				}

				/// <summary>
				/// <para>Time in minutes between each ListStatus report sent by SellSide. Zero means don't send status.</para>
				/// <para>Time in minutes between each ListStatus report sent by SellSide. Zero means don't send status.</para>
				/// </summary>
				public System.String ProgPeriodInterval
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ProgPeriodInterval, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ProgPeriodInterval); else fieldSet.Set(Tags.ProgPeriodInterval, value);
					}
				}

				/// <summary>
				/// <para>Code to represent whether value is net (inclusive of tax) or gross.</para>
				/// <para>Valid values:</para>
				/// <para>1 - Net</para>
				/// <para>2 - Gross</para>
				/// <para>Net/Gross</para>
				/// </summary>
				public IncTaxInd? IncTaxInd
				{
					get
					{
						IncTaxInd v;
						if (fieldSet.TryGetIncTaxInd(Tags.IncTaxInd, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IncTaxInd); else fieldSet.Set(Tags.IncTaxInd, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates request for forex accommodation trade to be executed along with security transaction.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Execute Forex after security trade</para>
				/// <para>N = Do not execute Forex after security trade</para>
				/// <para>Is foreign exchange required</para>
				/// </summary>
				public ForexReq? ForexReq
				{
					get
					{
						ForexReq v;
						if (fieldSet.TryGetForexReq(Tags.ForexReq, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ForexReq); else fieldSet.Set(Tags.ForexReq, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates the total number of bidders on the list</para>
				/// <para>Indicates the total number of bidders on the list</para>
				/// </summary>
				public System.String NumBidders
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.NumBidders, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.NumBidders); else fieldSet.Set(Tags.NumBidders, value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// </summary>
				public System.DateTime? TradeDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradeDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradeDate); else fieldSet.Set(Tags.TradeDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Code to represent the type of trade.</para>
				/// <para>Valid values:</para>
				/// <para>R: Risk Trade</para>
				/// <para>G: VWAP Guarantee</para>
				/// <para>A: Agency</para>
				/// <para>J: Guaranteed Close</para>
				/// </summary>
				public TradeType TradeType
				{
					get
					{
						return fieldSet.GetTradeType(Tags.TradeType);
					}
					set
					{
						fieldSet.Set(Tags.TradeType, value);
					}
				}

				/// <summary>
				/// <para>Code to represent the basis price type.</para>
				/// <para>Valid values:</para>
				/// <para>2: Closing Price at morning session</para>
				/// <para>3: Closing Price</para>
				/// <para>4: Current price</para>
				/// <para>5: SQ</para>
				/// <para>6: VWAP through a day</para>
				/// <para>7: VWAP through a morning session</para>
				/// <para>8: VWAP through an afternoon session</para>
				/// <para>9: VWAP through a day except YORI</para>
				/// <para>A: VWAP through a morning session except YORI</para>
				/// <para>B: VWAP through an afternoon session except YORI</para>
				/// <para>C: Strike</para>
				/// <para>D: Open</para>
				/// <para>Z: Others</para>
				/// </summary>
				public BasisPxType BasisPxType
				{
					get
					{
						return fieldSet.GetBasisPxType(Tags.BasisPxType);
					}
					set
					{
						fieldSet.Set(Tags.BasisPxType, value);
					}
				}

				/// <summary>
				/// <para>The time at which current market prices are used to determine the value of a basket.</para>
				/// <para>Used when BasisPxType = 'C'</para>
				/// </summary>
				public System.DateTime? StrikeTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.StrikeTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikeTime); else fieldSet.Set(Tags.StrikeTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BidRequest(Message message)
				{
					this.fieldSet = message;
					this.noBidDescriptors = new BidRequestNoBidDescriptorsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidDescriptors));
					this.noBidComponents = new BidRequestNoBidComponentsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidComponents));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BidRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Bid_Request, new Dialect(ProtocolVersion.FIX42));
					this.noBidDescriptors = new BidRequestNoBidDescriptorsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidDescriptors));
					this.noBidComponents = new BidRequestNoBidComponentsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidComponents));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BidRequest(System.String clientBidID, BidRequestTransType bidRequestTransType, System.String totalNumSecurities, System.String bidType, TradeType tradeType, BasisPxType basisPxType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Bid_Request, new Dialect(ProtocolVersion.FIX42));
					ClientBidID = clientBidID;
					BidRequestTransType = bidRequestTransType;
					TotalNumSecurities = totalNumSecurities;
					BidType = bidType;
					TradeType = tradeType;
					BasisPxType = basisPxType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(BidRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PreTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The Bid Response message can be used in one of two ways depending on which market conventions are being followed.</para>
			/// <para>In the "Non disclosed" convention the Bid Response message can be used to supply a bid based on the sector, country, index and liquidity information contained within the corresponding Bid Request message. See Appendix N - Program/Basket/List Trading for an example.</para>
			/// <para>In the "Disclosed" convention the Bid Response message can be used to supply bids based on the List Order Detail messages sent in advance of the corresponding Bid Request message.</para>
			/// </summary>
			public class BidResponse
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Bid Response as assigned by broker. Uniqueness must be guaranteed within a single trading day.</para>
				/// </summary>
				public System.String BidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.BidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidID); else fieldSet.Set(Tags.BidID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for a Bid Request as assigned by institution. Uniqueness must be guaranteed within a single trading day.</para>
				/// </summary>
				public System.String ClientBidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientBidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientBidID); else fieldSet.Set(Tags.ClientBidID, value);
					}
				}

				private BidResponseNoBidComponentsCollection noBidComponents;
				/// <summary>
				/// <para>Indicates the number of list entries.</para>
				/// <para>Number of bid repeating groups</para>
				/// </summary>
				public BidResponseNoBidComponentsCollection NoBidComponents
				{
					get
					{
						return noBidComponents;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BidResponse(Message message)
				{
					this.fieldSet = message;
					this.noBidComponents = new BidResponseNoBidComponentsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidComponents));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BidResponse()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Bid_Response, new Dialect(ProtocolVersion.FIX42));
					this.noBidComponents = new BidResponseNoBidComponentsCollection(fieldSet, fieldSet.GetGroup(Tags.NoBidComponents));
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(BidResponse value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The Execution Report message is used to:</para>
			/// <list type="number"><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item><item>confirm the receipt of an orderconfirm changes to an existing order (i.e. accept cancel and replace requests)relay order status informationrelay fill information on working ordersreject ordersreport post-trade fees calculations associated with a trade</item></list><para>NOTE: Execution reports do not replace the end-of-day confirm. Execution reports are to be regarded only as replacements for the existing fill messages currently communicated via telephone.</para>
			/// <para>Each execution report contains three fields which are used to communicate both the current state of the order as understood by the broker and the purpose of the message: OrdStatus, ExecType and ExecTransType.</para>
			/// <para>In an execution report the OrdStatus is used to convey the current state of the order. If an order simultaneously exists in more than one order state, the value with highest precedence is the value that is reported in the OrdStatus field. The order statuses are as follows (in highest to lowest precedence):</para>
			/// <list type="table"><item><term>Precedence</term><description>OrdStatus</description></item><item><term>12</term><description>Pending Cancel</description></item><item><term>11</term><description>Pending Replace</description></item><item><term>10</term><description>Done for Day</description></item><item><term>9</term><description>Calculated</description></item><item><term>8</term><description>Filled</description></item><item><term>7</term><description>Stopped</description></item><item><term>6</term><description>Suspended</description></item><item><term>5</term><description>Canceled</description></item><item><term>5</term><description>Expired</description></item><item><term>4</term><description>Partially Filled</description></item><item><term>3</term><description>Replaced</description></item><item><term>2</term><description>New</description></item><item><term>2</term><description>Rejected</description></item><item><term>2</term><description>Pending New</description></item><item><term>1</term><description>Accepted for bidding</description></item></list><para>The ExecType is used to identify the purpose of the Execution Report message. To transmit a change in OrdStatus for an order, the broker(sell side) should send an Execution Report with the new OrdStatus value in both the ExecType AND the OrdStatus fields to signify this message is changing the state of the order. The only exception to this rule is that when rejecting a cancel or cancel/replace request the CancelReject message is used both to reject the request and to communicate the current OrdStatus. An ExecType of Pending Cancel or Pending Replace is used to indicate that a cancel or cancel/replace request is being processed. An ExecType of Canceled or Replace is used to indicate that the cancel or cancel/replace request has been successfully processed.</para>
			/// <para>Execution information (e.g. new partial fill or complete fill) should not be communicated in the same report as one which communicates other state changes (such as pending cancel, pending replace, canceled, replaced, accepted, done for day etc).</para>
			/// <para>Any fills which occur and need to be communicated to the customer while an order is "pending" and waiting to achieve a new state (i.e. via a Order Cancel Replace (aka Order Modification) Request) must contain the "original" (current order prior to state change request) order parameters (i.e. ClOrdID, OrderQty, Price, etc). These fills will cause the CumQty and AvgPx to be updated. An order cannot be considered replaced until it has been explicitly accepted and confirmed to have reached the replaced status via an execution report with ExecType = 'Replace', at which time the effect of the replacement (ClOrdID, new quantity or limit price etc) will be seen. Note that due to the precedence rules above, in reports where ExecType=Replace, OrdStatus may not = Replaced.</para>
			/// <para>Requests to cancel or cancel/replace an order are only acted upon when there is an outstanding order quantity. Requests to replace the OrderQty to a level less than the CumQty will be interpreted by the broker as requests to stop executing the order. Requests to change price on a filled order will be rejected (see Order Cancel Reject message type). The OrderQty, CumQty, LeavesQty, and AvgPx fields should be calculated to reflect the cumulative result of all versions of an order. For example, if partially filled order A were replaced by order B, the OrderQty, CumQty, LeavesQty, and AvgPx on order B's fills should represent the cumulative result of order A plus those on order B.</para>
			/// <para>The general rule is: OrderQty = CumQty + LeavesQty.</para>
			/// <para>There can be exceptions to this rule when ExecType and/or OrdStatus are Canceled, DoneForTheDay (e.g. on a day order), Expired, Calculated, or Rejected in which case the order is no longer active and LeavesQty could be 0.</para>
			/// <para>Execution report messages are transmitted with a transaction type (ExecTransType) NEW, CANCEL, CORRECT or STATUS. Transaction types CANCEL and CORRECT modify the state of the message identified in field ExecRefID, and are used to cancel or correct a previously reported execution. Transaction type STATUS indicates that the execution message contains no new information, only summary information regarding order status.</para>
			/// <list type="bullet"><item>The NEW transaction type indicates that this message represents a new order, a change in status of the order, or a new fill against an existing order. The combination of the ExecTransType, ExecType, and OrdStatus fields will indicate how the message is to be applied to an order.The CANCEL transaction type applies at the execution level. The Cancel transaction will be used to cancel an execution which has been reported in error. The canceled execution will be identified in the ExecRefID field. Note: ExecTransType of Cancel should not be used to cancel a previous ExecutionRpt with ExecTransType of Cancel (e.g. cannot cancel a cancel).The CORRECT transaction type applies at the execution level and is used to modify an incorrectly reported fill. The incorrect execution will be identified in the ExecRefID field. If a single execution is corrected more than once, ExecRefID should refer to the ExecID of the last corrected ExecutionRpt (same convention as ClOrdID and OrigClOrdID). To correct an ExecutionRpt which was previously canceled, an ExecutionRpt with ExecTransType=New should be sent (e.g. cannot send ExecTransType=Correct for an ExecutionRpt with ExecTransType=Cancel). Note: Data reported in the CumQty, LeavesQty, and AvgPx fields represent the status of the order as of the time of the correction, not as of the time of the originally reported execution.</item><item>The NEW transaction type indicates that this message represents a new order, a change in status of the order, or a new fill against an existing order. The combination of the ExecTransType, ExecType, and OrdStatus fields will indicate how the message is to be applied to an order.The CANCEL transaction type applies at the execution level. The Cancel transaction will be used to cancel an execution which has been reported in error. The canceled execution will be identified in the ExecRefID field. Note: ExecTransType of Cancel should not be used to cancel a previous ExecutionRpt with ExecTransType of Cancel (e.g. cannot cancel a cancel).The CORRECT transaction type applies at the execution level and is used to modify an incorrectly reported fill. The incorrect execution will be identified in the ExecRefID field. If a single execution is corrected more than once, ExecRefID should refer to the ExecID of the last corrected ExecutionRpt (same convention as ClOrdID and OrigClOrdID). To correct an ExecutionRpt which was previously canceled, an ExecutionRpt with ExecTransType=New should be sent (e.g. cannot send ExecTransType=Correct for an ExecutionRpt with ExecTransType=Cancel). Note: Data reported in the CumQty, LeavesQty, and AvgPx fields represent the status of the order as of the time of the correction, not as of the time of the originally reported execution.</item><item>The NEW transaction type indicates that this message represents a new order, a change in status of the order, or a new fill against an existing order. The combination of the ExecTransType, ExecType, and OrdStatus fields will indicate how the message is to be applied to an order.The CANCEL transaction type applies at the execution level. The Cancel transaction will be used to cancel an execution which has been reported in error. The canceled execution will be identified in the ExecRefID field. Note: ExecTransType of Cancel should not be used to cancel a previous ExecutionRpt with ExecTransType of Cancel (e.g. cannot cancel a cancel).The CORRECT transaction type applies at the execution level and is used to modify an incorrectly reported fill. The incorrect execution will be identified in the ExecRefID field. If a single execution is corrected more than once, ExecRefID should refer to the ExecID of the last corrected ExecutionRpt (same convention as ClOrdID and OrigClOrdID). To correct an ExecutionRpt which was previously canceled, an ExecutionRpt with ExecTransType=New should be sent (e.g. cannot send ExecTransType=Correct for an ExecutionRpt with ExecTransType=Cancel). Note: Data reported in the CumQty, LeavesQty, and AvgPx fields represent the status of the order as of the time of the correction, not as of the time of the originally reported execution.</item></list><para>See Appendix D: Order State Change Matrices for examples of key state changes, processing of cancel and cancel/replace requests, and for execution cancel/corrects.</para>
			/// <para>An ExecutionRpt with ExecType = Restated represents an ExecutionRpt sent by the sellside communicating a change in the order or a restatement of the order's parameters without an electronic request from the customer. ExecRestatementReason must be set. This is used for GT orders and corporate actions (see below), changes communicated verbally to the sellside either due to normal business practices or as an emergency measure when electronic systems are not available, repricing of orders by the sellside (such as making Sell Short orders compliant with uptick / downtick rules), or other reasons (Broker option). ExecRestatementReason can also be used to communicate unsolicited cancels.</para>
			/// <para>The field ClOrdID is provided for institutions to affix an identification number to an order to coincide with internal systems. The OrderID field is populated with the broker-generated order number. Unlike ClOrdID/OrigClOrdID which requires a chaining through Cancel/Replaces and Cancels, OrderID and SecondaryOrderID are not required to change through changes to an order.</para>
			/// <para>The underlying business assumption of orders that can trade over multiple days, such as GTC and Good Till Date orders expiring on a future trading date (henceforth referred to as GT orders) is that a GT order that is not fully executed and has not been canceled and has not expired on a given day remains good for the broker to execute the following day. Note that the concept of day is determined by the market convention, which will be security specific. At the end of each trading day, once the order is no longer subject to execution, the broker may optionally send an Execution Report with ExecType=Done for Day(3). When the ExpireDate or ExpireTime of a Good Till Date order is reached, or a GTC order reaches a maximum age, the order is considered expired and the broker may optionally send an Execution Report with ExecType and OrdStatus=Expired(C).</para>
			/// <para>In handling GT orders, the OrderQty, CumQty and AvgPx fields will represent the entirety of the order over all days. The fields DayOrderQty, DayCumQty, and DayAvgPx can be used on days following the day of the first trade on a GT order. Prior to the start of business each day, for all GT orders that have partial fills on previous days, DayCumQty and DayAvgPx are set to zero, and DayOrderQty becomes the LeavesQty. The following relationship holds: DayOrderQty = OrderQty - (CumQty - DayCumQty). Since (CumQty - DayCumQty) represents the volume traded on all previous days, DayOrderQty = OrderQty - Volume traded on all previous days. Note that when changing the quantity of an order, both OrderQty and DayOrderQty will change. Requests to change or cancel an order will be made in terms of the total quantity for the order, not the quantity open today. For example, on an order where OrderQty=10000 and 2000 shares trade during the previous days, a request to change OrderQty to 15000 will mean that 13000 shares will be open. See Appendix D - Order State Change Matrices for examples of canceling and changing GT orders partially filled on previous days.</para>
			/// <para>A Cancel on an execution (trade bust) happening the same day of the trade will result in CumQty and DayCumQty each decreasing by the quantity busted, and LeavesQty increasing by the quantity busted. OrderQty and DayOrderQty will remain unchanged. If the business rules allow for a trade bust to be reported on a later date than the trade being busted, the OrderQty and DayCumQty will remain unchanged, the LeavesQty and DayOrderQty will increase by the quantity busted, and the CumQty will decrease by the quantity busted.</para>
			/// <para>If bilaterally agreed between counterparties, a broker may wish to transmit a list of all open GT orders, permitting reconciliation of the open orders. Typically this transmission may occur at the end of the trading day or at the start of the following trading day. There is no expected response to such retransmission; in the event of a reconciliation problem this should be resolved manually or via the DK message. Assuming no corporate actions have occurred, the broker will send an Execution Report with ExecType = Restated (D) and ExecRestatementReason = GT renewal / restatement (no corporate action) (1) for each open GT order. These Execution Reports may have DayCumQty and DayAvgPx restated to zero, and DayOrderQty restated to LeavesQty if the transmission occurs at the start of the following business day. The broker has the option of changing the OrderID and SecondaryOrderID fields, or leaving them unchanged. If they are changed, then the buy-side should use these new ID fields when sending Order Cancel Request, Order Cancel/Replace Request, and Order Status Request messages.</para>
			/// <para>In the case of a corporate action resulting in the adjustment of an open GT order, the broker will send an Execution Report with ExecType = Restated (D) and ExecRestatementReason = GT Corporate action (0) with the order's state after the corporate action adjustment. In the case of stock splits, OrderQty, CumQty, AvgPx, and LeavesQty will be adjusted to reflect the order's state in terms of current shares, not pre-split shares. See Appendix D - Order State Change Matrices for examples of GT order restatement with and without a corporate action.</para>
			/// </summary>
			public class ExecutionReport
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// <para>OrderID is required to be unique for each chain of orders.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						return fieldSet.Get(Tags.OrderID);
					}
					set
					{
						fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Assigned by the party which accepts the order. Can be used to provide the OrderID used by an exchange or executing system.</para>
				/// <para>Can be used to provide order id used by exchange or executing system.</para>
				/// </summary>
				public System.String SecondaryOrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecondaryOrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecondaryOrderID); else fieldSet.Set(Tags.SecondaryOrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// <para>Required for executions against electronically submitted orders which were assigned an ID by the institution. Not required for orders manually entered by the broker.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClOrdID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClOrdID); else fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) as assigned by the institution, used to identify the previous order in cancel and cancel/replace requests.</para>
				/// <para>Conditionally required for response to an electronic Cancel or Cancel/Replace request (ExecType=PendingCancel, Replaced, or Canceled). ClOrdID of the previous order (NOT the initial order of the day) when canceling or replacing an order.</para>
				/// </summary>
				public System.String OrigClOrdID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.OrigClOrdID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrigClOrdID); else fieldSet.Set(Tags.OrigClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				private ExecutionReportNoContraBrokersCollection noContraBrokers;
				/// <summary>
				/// <para>The number of ContraBroker entries.</para>
				/// <para>Number of ContraBrokers repeating group instances.</para>
				/// </summary>
				public ExecutionReportNoContraBrokersCollection NoContraBrokers
				{
					get
					{
						return noContraBrokers;
					}
				}

				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Required for executions against orders which were submitted as part of a list.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier of execution message as assigned by broker (will be 0 (zero) for ExecTransType=3 (Status)).</para>
				/// <para>Uniqueness must be guaranteed within a single trading day or the life of a multi-day order. Firms which accept multi-day orders should consider embedding a date within the ExecID field to assure uniqueness across days.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Must be unique for each Execution Report message</para>
				/// </summary>
				public System.String ExecID
				{
					get
					{
						return fieldSet.Get(Tags.ExecID);
					}
					set
					{
						fieldSet.Set(Tags.ExecID, value);
					}
				}

				/// <summary>
				/// <para>Identifies transaction type</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Cancel</para>
				/// <para>2 = Correct</para>
				/// <para>3 = Status</para>
				/// </summary>
				public ExecTransType ExecTransType
				{
					get
					{
						return fieldSet.GetExecTransType(Tags.ExecTransType);
					}
					set
					{
						fieldSet.Set(Tags.ExecTransType, value);
					}
				}

				/// <summary>
				/// <para>Reference identifier used with Cancel and Correct transaction types.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for Cancel and Correct ExecTransType messages</para>
				/// </summary>
				public System.String ExecRefID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecRefID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecRefID); else fieldSet.Set(Tags.ExecRefID, value);
					}
				}

				/// <summary>
				/// <para>Describes the specific ExecutionRpt (i.e. Pending Cancel) while OrdStatus will always identify the current order status (i.e. Partially Filled)</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Partial fill</para>
				/// <para>2 = Fill</para>
				/// <para>3 = Done for day</para>
				/// <para>4 = Canceled</para>
				/// <para>5 = Replace</para>
				/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request)</para>
				/// <para>7 = Stopped</para>
				/// <para>8 = Rejected</para>
				/// <para>9 = Suspended</para>
				/// <para>A = Pending New</para>
				/// <para>B = Calculated</para>
				/// <para>C = Expired</para>
				/// <para>D = Restated (ExecutionRpt sent unsolicited by sellside, with ExecRestatementReason set)</para>
				/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
				/// <para>Describes the type of execution report. Same possible values as OrdStatus.</para>
				/// </summary>
				public ExecType ExecType
				{
					get
					{
						return fieldSet.GetExecType(Tags.ExecType);
					}
					set
					{
						fieldSet.Set(Tags.ExecType, value);
					}
				}

				/// <summary>
				/// <para>Identifies current status of order.</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Partially filled</para>
				/// <para>2 = Filled</para>
				/// <para>3 = Done for day</para>
				/// <para>4 = Canceled</para>
				/// <para>5 = Replaced</para>
				/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request) 7 = Stopped</para>
				/// <para>8 = Rejected</para>
				/// <para>9 = Suspended</para>
				/// <para>A = Pending New</para>
				/// <para>B = Calculated</para>
				/// <para>C = Expired</para>
				/// <para>D = Accepted for bidding</para>
				/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
				/// <para>Describes the current state of a CHAIN of orders, same scope as OrderQty, CumQty, LeavesQty, and AvgPx</para>
				/// </summary>
				public OrdStatus OrdStatus
				{
					get
					{
						return fieldSet.GetOrdStatus(Tags.OrdStatus);
					}
					set
					{
						fieldSet.Set(Tags.OrdStatus, value);
					}
				}

				/// <summary>
				/// <para>Code to identify reason for order rejection.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Broker option</para>
				/// <para>1 = Unknown symbol</para>
				/// <para>2 = Exchange closed</para>
				/// <para>3 = Order exceeds limit</para>
				/// <para>4 = Too late to enter</para>
				/// <para>5 = Unknown Order</para>
				/// <para>6 = Duplicate Order (e.g. dupe ClOrdID)</para>
				/// <para>7 = Duplicate of a verbally communicated order</para>
				/// <para>8 = Stale Order</para>
				/// <para>For optional use with ExecType = 8 (Rejected)</para>
				/// </summary>
				public OrdRejReason? OrdRejReason
				{
					get
					{
						OrdRejReason v;
						if (fieldSet.TryGetOrdRejReason(Tags.OrdRejReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrdRejReason); else fieldSet.Set(Tags.OrdRejReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify reason for an ExecutionRpt message sent with ExecType=Restated or used when communicating an unsolicited cancel.</para>
				/// <para>Valid values:</para>
				/// <para>0 = GT Corporate action</para>
				/// <para>1 = GT renewal / restatement (no corporate action)</para>
				/// <para>2 = Verbal change</para>
				/// <para>3 = Repricing of order</para>
				/// <para>4 = Broker option</para>
				/// <para>5 = Partial decline of OrderQty (e.g. exchange-initiated partial cancel)</para>
				/// <para>Required for ExecType = D (Restated).</para>
				/// </summary>
				public ExecRestatementReason? ExecRestatementReason
				{
					get
					{
						ExecRestatementReason v;
						if (fieldSet.TryGetExecRestatementReason(Tags.ExecRestatementReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecRestatementReason); else fieldSet.Set(Tags.ExecRestatementReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// <para>Required for executions against electronically submitted orders which were assigned an account by the institution</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				/// <summary>
				/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Regular</para>
				/// <para>1 = Cash</para>
				/// <para>2 = Next Day</para>
				/// <para>3 = T+2</para>
				/// <para>4 = T+3</para>
				/// <para>5 = T+4</para>
				/// <para>6 = Future</para>
				/// <para>7 = When Issued</para>
				/// <para>8 = Sellers Option</para>
				/// <para>9 = T+ 5</para>
				/// <para>Absence of this field is interpreted as Regular.</para>
				/// </summary>
				public SettlmntTyp? SettlmntTyp
				{
					get
					{
						SettlmntTyp v;
						if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
					}
				}

				/// <summary>
				/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
				/// <para>Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option)</para>
				/// </summary>
				public System.DateTime? FutSettDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Either CashOrderQty or OrderQty is required. Not required for a rejected cash order or an order ack for a cash order.</para>
				/// </summary>
				public System.Double? OrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
				/// <para>Either CashOrderQty or OrderQty is required. Specifies the approximate 'monetary quantity' conveyed on the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages involving fills.</para>
				/// </summary>
				public System.Double? CashOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Order type.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Market</para>
				/// <para>2 = Limit</para>
				/// <para>3 = Stop</para>
				/// <para>4 = Stop limit</para>
				/// <para>5 = Market on close</para>
				/// <para>6 = With or without</para>
				/// <para>7 = Limit or better</para>
				/// <para>8 = Limit with or without</para>
				/// <para>9 = On basis</para>
				/// <para>A = On close</para>
				/// <para>B = Limit on close</para>
				/// <para>C =Forex - Market</para>
				/// <para>D = Previously quoted</para>
				/// <para>E = Previously indicated</para>
				/// <para>F = Forex - Limit</para>
				/// <para>G = Forex - Swap</para>
				/// <para>H = Forex - Previously Quoted</para>
				/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
				/// <para>P = Pegged</para>
				/// </summary>
				public OrdType? OrdType
				{
					get
					{
						OrdType v;
						if (fieldSet.TryGetOrdType(Tags.OrdType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrdType); else fieldSet.Set(Tags.OrdType, value.Value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required if specified on the order</para>
				/// </summary>
				public System.Double? Price
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required if specified on the order</para>
				/// </summary>
				public System.Double? StopPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StopPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StopPx); else fieldSet.Set(Tags.StopPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the price of the peg for a pegged order.</para>
				/// <para>Required if specified on the order</para>
				/// </summary>
				public System.Double? PegDifference
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.PegDifference, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PegDifference); else fieldSet.Set(Tags.PegDifference, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Related to displayed price</para>
				/// <para>1 = Related to market price</para>
				/// <para>2 = Related to primary price</para>
				/// <para>3 = Related to local primary price</para>
				/// <para>4 = Related to midpoint price</para>
				/// <para>5 = Related to last trade price</para>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to. Required if DiscretionOffset is specified.</para>
				/// </summary>
				public DiscretionInst? DiscretionInst
				{
					get
					{
						DiscretionInst v;
						if (fieldSet.TryGetDiscretionInst(Tags.DiscretionInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionInst); else fieldSet.Set(Tags.DiscretionInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// </summary>
				public System.Double? DiscretionOffset
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DiscretionOffset, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionOffset); else fieldSet.Set(Tags.DiscretionOffset, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>ID used to represent this transaction for compliance purposes (e.g. OATS reporting).</para>
				/// </summary>
				public System.String ComplianceID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ComplianceID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ComplianceID); else fieldSet.Set(Tags.ComplianceID, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the order was solicited.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Was solcitied</para>
				/// <para>N = Was not solicited</para>
				/// </summary>
				public SolicitedFlag? SolicitedFlag
				{
					get
					{
						SolicitedFlag v;
						if (fieldSet.TryGetSolicitedFlag(Tags.SolicitedFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SolicitedFlag); else fieldSet.Set(Tags.SolicitedFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Day</para>
				/// <para>1 = Good Till Cancel (GTC)</para>
				/// <para>2 = At the Opening (OPG)</para>
				/// <para>3 = Immediate or Cancel (IOC)</para>
				/// <para>4 = Fill or Kill (FOK)</para>
				/// <para>5 = Good Till Crossing (GTX)</para>
				/// <para>6 = Good Till Date</para>
				/// <para>Absence of this field indicates Day order</para>
				/// </summary>
				public TimeInForce? TimeInForce
				{
					get
					{
						TimeInForce v;
						if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
					}
				}

				/// <summary>
				/// <para>Time the details within the message should take effect (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time specified on the order at which the order should be considered valid</para>
				/// </summary>
				public System.DateTime? EffectiveTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.EffectiveTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EffectiveTime); else fieldSet.Set(Tags.EffectiveTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireTime is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireDate is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Not held</para>
				/// <para>2 = Work</para>
				/// <para>3 = Go along</para>
				/// <para>4 = Over the day</para>
				/// <para>5 = Held</para>
				/// <para>6 = Participate don't initiate</para>
				/// <para>7 = Strict scale</para>
				/// <para>8 = Try to scale</para>
				/// <para>9 = Stay on bidside</para>
				/// <para>0 = Stay on offerside</para>
				/// <para>A = No cross (cross is forbidden)</para>
				/// <para>B = OK to cross</para>
				/// <para>C = Call first</para>
				/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
				/// <para>E = Do not increase - DNI</para>
				/// <para>F = Do not reduce - DNR</para>
				/// <para>G = All or none - AON</para>
				/// <para>I = Institutions only</para>
				/// <para>L = Last peg (last sale)</para>
				/// <para>M = Mid-price peg (midprice of inside quote)</para>
				/// <para>N = Non-negotiable</para>
				/// <para>O = Opening peg</para>
				/// <para>P = Market peg</para>
				/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
				/// <para>S = Suspend</para>
				/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
				/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
				/// <para>V = Netting (for Forex)</para>
				/// <para>W = Peg to VWAP</para>
				/// <para>Can contain multiple instructions, space delimited.</para>
				/// </summary>
				public ExecInst? ExecInst
				{
					get
					{
						ExecInst v;
						if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Note that the name of this field is changing to 'OrderCapacity' as Rule80A is a very US market-specific term. Other world markets need to convey similar information, however, often a subset of the US values. . See the 'Rule80A (aka OrderCapacity) Usage by Market' appendix for market-specific usage of this field.Valid values:</para>
				/// <para>A = Agency single order</para>
				/// <para>B = Short exempt transaction (refer to A type)</para>
				/// <para>C = Program Order, non-index arb, for Member firm/org</para>
				/// <para>D = Program Order, index arb, for Member firm/org</para>
				/// <para>E = Registered Equity Market Maker trades</para>
				/// <para>F = Short exempt transaction (refer to W type)</para>
				/// <para>H = Short exempt transaction (refer to I type)</para>
				/// <para>I = Individual Investor, single order</para>
				/// <para>J = Program Order, index arb, for individual customer</para>
				/// <para>K = Program Order, non-index arb, for individual customer</para>
				/// <para>L = Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
				/// <para>M = Program Order, index arb, for other member</para>
				/// <para>N = Program Order, non-index arb, for other member</para>
				/// <para>O = Competing dealer trades</para>
				/// <para>P = Principal</para>
				/// <para>R = Competing dealer trades</para>
				/// <para>S = Specialist trades</para>
				/// <para>T = Competing dealer trades</para>
				/// <para>U = Program Order, index arb, for other agency</para>
				/// <para>W = All other orders as agent for other member</para>
				/// <para>X = Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
				/// <para>Y = Program Order, non-index arb, for other agency</para>
				/// <para>Z = Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
				/// </summary>
				public Rule80AAkaOrderCapacity? Rule80AAkaOrderCapacity
				{
					get
					{
						Rule80AAkaOrderCapacity v;
						if (fieldSet.TryGetRule80AAkaOrderCapacity(Tags.Rule80A, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Rule80A); else fieldSet.Set(Tags.Rule80A, value.Value);
					}
				}

				/// <summary>
				/// <para>Quantity of shares bought/sold on this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Quantity of shares bought/sold on this (last) fill. Not required ExecTransType = 3 (Status). When required, should be "0" for non-fills ("fill" defined as ExecTransType=New and ExecType=Partial Fill or Fill) unless noted below.</para>
				/// <para>If ExecType=Stopped, represents the quantity stopped/guaranteed/protected for.</para>
				/// </summary>
				public System.Double? LastShares
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastShares, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastShares); else fieldSet.Set(Tags.LastShares, value.Value);
					}
				}

				/// <summary>
				/// <para>Price of this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
				/// <para>Price of this (last) fill. Not required for ExecTransType = 3 (Status), Should represent the 'all-in' (LastSpotRate + LastForwardPoints) rate for F/X orders. ). When required, should be "0" for non-fills ("fill" defined as ExecTransType=New and ExecType=Partial Fill or Fill) unless noted below.</para>
				/// <para>If ExecType=Stopped, represents the price stopped/guaranteed/protected at.</para>
				/// </summary>
				public System.Double? LastPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastPx); else fieldSet.Set(Tags.LastPx, value.Value);
					}
				}

				/// <summary>
				/// <para>F/X spot rate.</para>
				/// <para>Applicable for F/X orders</para>
				/// </summary>
				public System.Double? LastSpotRate
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastSpotRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastSpotRate); else fieldSet.Set(Tags.LastSpotRate, value.Value);
					}
				}

				/// <summary>
				/// <para>F/X forward points added to LastSpotRate. May be a negative value.</para>
				/// <para>Applicable for F/X orders</para>
				/// </summary>
				public System.Double? LastForwardPoints
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastForwardPoints, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastForwardPoints); else fieldSet.Set(Tags.LastForwardPoints, value.Value);
					}
				}

				/// <summary>
				/// <para>Market of execution for last fill</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String LastMkt
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.LastMkt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastMkt); else fieldSet.Set(Tags.LastMkt, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Broker capacity in order execution</para>
				/// <para>Valid values:</para>
				/// <para>1 = Agent</para>
				/// <para>2 = Cross as agent</para>
				/// <para>3 = Cross as principal</para>
				/// <para>4 = Principal</para>
				/// </summary>
				public LastCapacity? LastCapacity
				{
					get
					{
						LastCapacity v;
						if (fieldSet.TryGetLastCapacity(Tags.LastCapacity, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastCapacity); else fieldSet.Set(Tags.LastCapacity, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount of shares open for further execution. If the OrdStatus is Canceled, DoneForTheDay, Expired, Calculated, or Rejected (in which case the order is no longer active) then LeavesQty could be 0, otherwise LeavesQty = OrderQty - CumQty.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Amount of shares open for further execution. If the OrdStatus is Canceled, DoneForTheDay, Expired, Calculated, or Rejected (in which case the order is no longer active) then LeavesQty could be 0, otherwise LeavesQty = OrderQty - CumQty.</para>
				/// </summary>
				public System.Double LeavesQty
				{
					get
					{
						return fieldSet.GetDouble(Tags.LeavesQty);
					}
					set
					{
						fieldSet.Set(Tags.LeavesQty, value);
					}
				}

				/// <summary>
				/// <para>Total number of shares filled.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Currently executed shares for chain of orders.</para>
				/// </summary>
				public System.Double CumQty
				{
					get
					{
						return fieldSet.GetDouble(Tags.CumQty);
					}
					set
					{
						fieldSet.Set(Tags.CumQty, value);
					}
				}

				/// <summary>
				/// <para>Calculated average price of all fills on this order.</para>
				/// </summary>
				public System.Double AvgPx
				{
					get
					{
						return fieldSet.GetDouble(Tags.AvgPx);
					}
					set
					{
						fieldSet.Set(Tags.AvgPx, value);
					}
				}

				/// <summary>
				/// <para>For GT orders, the OrderQty less all shares (adjusted for stock splits) that traded on previous days. DayOrderQty = OrderQty - (CumQty - DayCumQty)</para>
				/// <para>For GT orders on days following the day of the first trade.</para>
				/// </summary>
				public System.Double? DayOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DayOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DayOrderQty); else fieldSet.Set(Tags.DayOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>The number of shares on a GT order that have traded today.</para>
				/// <para>For GT orders on days following the day of the first trade.</para>
				/// </summary>
				public System.Double? DayCumQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DayCumQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DayCumQty); else fieldSet.Set(Tags.DayCumQty, value.Value);
					}
				}

				/// <summary>
				/// <para>The average price of shares on a GT order that have traded today.</para>
				/// <para>For GT orders on days following the day of the first trade.</para>
				/// </summary>
				public System.Double? DayAvgPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DayAvgPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DayAvgPx); else fieldSet.Set(Tags.DayAvgPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify whether to book out executions on a part-filled GT order on the day of execution or to accumulate.</para>
				/// <para>Valid values:</para>
				/// <para>0 = book out all trades on day of execution</para>
				/// <para>1 = accumulate executions until order is filled or expires</para>
				/// <para>2 = accumulate until verbally notified otherwise</para>
				/// <para>States whether executions are booked out or accumulated on a partially filled GT order</para>
				/// </summary>
				public GTBookingInst? GTBookingInst
				{
					get
					{
						GTBookingInst v;
						if (fieldSet.TryGetGTBookingInst(Tags.GTBookingInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GTBookingInst); else fieldSet.Set(Tags.GTBookingInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// <para>Used when reporting other than current day trades.</para>
				/// </summary>
				public System.DateTime? TradeDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradeDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradeDate); else fieldSet.Set(Tags.TradeDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time the transaction represented by this ExecutionReport occurred</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies party of trade responsible for exchange reporting.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Indicates that party receiving message must report trade</para>
				/// <para>N = Indicates that party sending message will report trade</para>
				/// </summary>
				public ReportToExch? ReportToExch
				{
					get
					{
						ReportToExch v;
						if (fieldSet.TryGetReportToExch(Tags.ReportToExch, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ReportToExch); else fieldSet.Set(Tags.ReportToExch, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
				/// <para>On a fill/partial fill messages, it represents value for that fill/partial fill, on ExecType=Calculated, it represents cumulative value for the order. Monetary commission values are expressed in the currency reflected by the Currency field.</para>
				/// </summary>
				public System.Double? Commission
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Commission, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Commission); else fieldSet.Set(Tags.Commission, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission type</para>
				/// <para>Valid values:</para>
				/// <para>1 = per share</para>
				/// <para>2 = percentage</para>
				/// <para>3 = absolute</para>
				/// </summary>
				public CommType? CommType
				{
					get
					{
						CommType v;
						if (fieldSet.TryGetCommType(Tags.CommType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CommType); else fieldSet.Set(Tags.CommType, value.Value);
					}
				}

				/// <summary>
				/// <para>Total amount traded (e.g. CumQty * AvgPx) expressed in units of currency.</para>
				/// </summary>
				public System.Double? GrossTradeAmt
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.GrossTradeAmt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GrossTradeAmt); else fieldSet.Set(Tags.GrossTradeAmt, value.Value);
					}
				}

				/// <summary>
				/// <para>Total amount due expressed in settlement currency (includes the effect of the forex transaction)</para>
				/// <para>Used to report results of forex accommodation trade</para>
				/// </summary>
				public System.Double? SettlCurrAmt
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.SettlCurrAmt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrAmt); else fieldSet.Set(Tags.SettlCurrAmt, value.Value);
					}
				}

				/// <summary>
				/// <para>Currency code of settlement denomination.</para>
				/// <para>Used to report results of forex accommodation trade</para>
				/// </summary>
				public System.String SettlCurrency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlCurrency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrency); else fieldSet.Set(Tags.SettlCurrency, value);
					}
				}

				/// <summary>
				/// <para>Foreign exchange rate used to compute SettlCurrAmt from Currency to SettlCurrency</para>
				/// <para>Foreign exchange rate used to compute SettlCurrAmt from Currency to SettlCurrency</para>
				/// </summary>
				public System.String SettlCurrFxRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlCurrFxRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrFxRate); else fieldSet.Set(Tags.SettlCurrFxRate, value);
					}
				}

				/// <summary>
				/// <para>Specifies whether or not SettlCurrFxRate should be multiplied or divided.</para>
				/// <para>M=Multiply</para>
				/// <para>D=Divide</para>
				/// <para>Specifies whether the SettlCurrFxRate should be multiplied or divided</para>
				/// </summary>
				public System.Char? SettlCurrFxRateCalc
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.SettlCurrFxRateCalc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrFxRateCalc); else fieldSet.Set(Tags.SettlCurrFxRateCalc, value.Value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on Broker trading floor</para>
				/// <para>Valid values:</para>
				/// <para>1 = Automated execution order, private, no Broker intervention</para>
				/// <para>2 = Automated execution order, public, Broker intervention OK</para>
				/// <para>3 = Manual order, best execution</para>
				/// </summary>
				public HandlInst? HandlInst
				{
					get
					{
						HandlInst v;
						if (fieldSet.TryGetHandlInst(Tags.HandlInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.HandlInst); else fieldSet.Set(Tags.HandlInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Minimum quantity of an order to be executed.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MinQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown on the exchange floor at any given time.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxFloor
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxFloor, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxFloor); else fieldSet.Set(Tags.MaxFloor, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
				/// <para>Valid Values:</para>
				/// <para>O=Open</para>
				/// <para>C=Close</para>
				/// <para>For options</para>
				/// </summary>
				public OpenClose? OpenClose
				{
					get
					{
						OpenClose v;
						if (fieldSet.TryGetOpenClose(Tags.OpenClose, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OpenClose); else fieldSet.Set(Tags.OpenClose, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown to other customers (i.e. sent via an IOI).</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxShow
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxShow, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxShow); else fieldSet.Set(Tags.MaxShow, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>FutSettDate of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
				/// </summary>
				public System.DateTime? FutSettDate2
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>OrderQty of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
				/// </summary>
				public System.Double? OrderQty2
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
					}
				}

				/// <summary>
				/// <para>Firm that will clear the trade. Used if different from the executing firm.</para>
				/// </summary>
				public System.String ClearingFirm
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingFirm, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingFirm); else fieldSet.Set(Tags.ClearingFirm, value);
					}
				}

				/// <summary>
				/// <para>Supplemental accounting information forwared to clearing house/firm.</para>
				/// </summary>
				public System.String ClearingAccount
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingAccount, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingAccount); else fieldSet.Set(Tags.ClearingAccount, value);
					}
				}

				/// <summary>
				/// <para>Used to indicate what an Execution Report represents (e.g. used with multi-leg securiteis, such as option strategies, spreads, etc.).</para>
				/// <para>Valid Values:</para>
				/// <para>1 - Single Security (default if not specified)</para>
				/// <para>2 - Individual leg of a multi-leg security</para>
				/// <para>3 - Multi-leg security</para>
				/// <para>Default is a single security if not specified.</para>
				/// </summary>
				public MultiLegReportingType? MultiLegReportingType
				{
					get
					{
						MultiLegReportingType v;
						if (fieldSet.TryGetMultiLegReportingType(Tags.MultiLegReportingType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MultiLegReportingType); else fieldSet.Set(Tags.MultiLegReportingType, value.Value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ExecutionReport(Message message)
				{
					this.fieldSet = message;
					this.noContraBrokers = new ExecutionReportNoContraBrokersCollection(fieldSet, fieldSet.GetGroup(Tags.NoContraBrokers));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ExecutionReport()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Execution_Report, new Dialect(ProtocolVersion.FIX42));
					this.noContraBrokers = new ExecutionReportNoContraBrokersCollection(fieldSet, fieldSet.GetGroup(Tags.NoContraBrokers));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ExecutionReport(System.String orderID, System.String execID, ExecTransType execTransType, ExecType execType, OrdStatus ordStatus, System.String symbol, Side side, System.Double leavesQty, System.Double cumQty, System.Double avgPx)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Execution_Report, new Dialect(ProtocolVersion.FIX42));
					OrderID = orderID;
					ExecID = execID;
					ExecTransType = execTransType;
					ExecType = execType;
					OrdStatus = ordStatus;
					Symbol = symbol;
					Side = side;
					LeavesQty = leavesQty;
					CumQty = cumQty;
					AvgPx = avgPx;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ExecutionReport value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The Order Cancel Reject message is issued by the broker upon receipt of a cancel request or cancel/replace request message which cannot be honored. Requests to change price or decrease quantity are executed only when an outstanding quantity exists. Filled orders cannot be changed (i.e quantity reduced or price change. However, the broker/sellside may support increasing the order quantity on a currently filled order).</para>
			/// <para>When rejecting a Cancel/Replace Request, the Cancel Reject message should provide the ClOrdID and OrigClOrdID values which were specified on the Cancel/Replace Request message for identification</para>
			/// <para>The execution message responds to accepted cancel request and cancel/replace request messages.</para>
			/// </summary>
			public class OrderCancelReject
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// <para>If CxlRejReason='Unknown order', specify 'NONE'.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						return fieldSet.Get(Tags.OrderID);
					}
					set
					{
						fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Assigned by the party which accepts the order. Can be used to provide the OrderID used by an exchange or executing system.</para>
				/// <para>Can be used to provide order id used by exchange or executing system.</para>
				/// </summary>
				public System.String SecondaryOrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecondaryOrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecondaryOrderID); else fieldSet.Set(Tags.SecondaryOrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// <para>Unique order id assigned by institution to the cancel request or to the replacement order.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.ClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) as assigned by the institution, used to identify the previous order in cancel and cancel/replace requests.</para>
				/// <para>ClOrdID which could not be canceled/replaced. ClOrdID of the previous order (NOT the initial order of the day) when canceling or replacing an order.</para>
				/// </summary>
				public System.String OrigClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.OrigClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.OrigClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Identifies current status of order.</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Partially filled</para>
				/// <para>2 = Filled</para>
				/// <para>3 = Done for day</para>
				/// <para>4 = Canceled</para>
				/// <para>5 = Replaced</para>
				/// <para>6 = Pending Cancel (e.g. result of Order Cancel Request) 7 = Stopped</para>
				/// <para>8 = Rejected</para>
				/// <para>9 = Suspended</para>
				/// <para>A = Pending New</para>
				/// <para>B = Calculated</para>
				/// <para>C = Expired</para>
				/// <para>D = Accepted for bidding</para>
				/// <para>E = Pending Replace (e.g. result of Order Cancel/Replace Request)</para>
				/// <para>OrdStatus value after this cancel reject is applied.</para>
				/// </summary>
				public OrdStatus OrdStatus
				{
					get
					{
						return fieldSet.GetOrdStatus(Tags.OrdStatus);
					}
					set
					{
						fieldSet.Set(Tags.OrdStatus, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Required for rejects against orders which were submitted as part of a list.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of request that a Cancel Reject is in response to.</para>
				/// <para>Valid values:</para>
				/// <para>1 - Order Cancel Request</para>
				/// <para>2 - Order Cancel/Replace Request</para>
				/// </summary>
				public CxlRejResponseTo CxlRejResponseTo
				{
					get
					{
						return fieldSet.GetCxlRejResponseTo(Tags.CxlRejResponseTo);
					}
					set
					{
						fieldSet.Set(Tags.CxlRejResponseTo, value);
					}
				}

				/// <summary>
				/// <para>Code to identify reason for cancel rejection.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Too late to cancel</para>
				/// <para>1 = Unknown order</para>
				/// <para>2 = Broker Option</para>
				/// <para>3 = Order already in Pending Cancel or Pending Replace status</para>
				/// </summary>
				public CxlRejReason? CxlRejReason
				{
					get
					{
						CxlRejReason v;
						if (fieldSet.TryGetCxlRejReason(Tags.CxlRejReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CxlRejReason); else fieldSet.Set(Tags.CxlRejReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReject(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReject()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Reject, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReject(System.String orderID, System.String clOrdID, System.String origClOrdID, OrdStatus ordStatus, CxlRejResponseTo cxlRejResponseTo)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Reject, new Dialect(ProtocolVersion.FIX42));
					OrderID = orderID;
					ClOrdID = clOrdID;
					OrigClOrdID = origClOrdID;
					OrdStatus = ordStatus;
					CxlRejResponseTo = cxlRejResponseTo;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderCancelReject value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The new order message type is used by institutions wishing to electronically submit securities and forex orders to a broker for execution.</para>
			/// <para>Orders can be submitted with special handling instructions and execution instructions. Handling instructions refer to how the broker should handle the order on its trading floor (see HandlInst field). Execution instructions contain explicit directions as to how the order should be executed (see ExecInst field).</para>
			/// <para>New Order messages received with the PossResend flag set in the header should be validated by ClOrdID. Implementations should also consider checking order parameters (side, symbol, quantity, etc.) to determine if the order had been previously submitted. PossResends previously received should be acknowledged back to the client via an Execution - Status message. PossResends not previously received should be processed as a new order and acknowledged via an Execution - New message.</para>
			/// <para>The value specified in the TransactTime field should allow the receiver of the order to apply business rules to determine if the order is potentially "stale" (e.g. in the event that there have been communication problems).To support forex accommodation trades, two fields, ForexReq and SettlCurrency, are included in the message. To request a broker to execute a forex trade in conjunction with the securities trade, the institution would set the ForexReq = Y and SettlCurrency = "intended settlement currency". The broker would then execute a forex trade from the execution currency to the settlement currency and report the results via the execution message in the SettlCurrAmt and SettlCurrency fields.</para>
			/// <para>The order message can also be used to request a straight forex trade. Conventions for identifying a forex transaction are as follows:</para>
			/// <list type="bullet"><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item><item>The forex Symbol is defined in "EBS" (Electronic Banking System) format: "CCY1/CCY2".Rates are expressed as "currency1 in currency2" (or "currency2 per currency1") and are calculated as CCY2 divided by CCY1 (NOT CCY1 divided by CCY2)(e.g. "GBP/USD" represents a rate expressed as USD per GBP, "USD/JPY" represents a rate expressed as JPY per USD, etc.).CCY1 and CCY2 are ISO currency codesThe value of the Currency field represents the denomination of the quantity fields (e.g. JPY represents quantity of JPY).In the case of a Forex - Swap (buying (or selling) a currency at one value date and selling (or buying) the same currency at a different value date), Side should represent the side of the FutSettDate2 transaction.OrdType = Forex - Market, Forex - Limit, Forex- Swap, or Forex - Previously QuotedNetting can be specified via the ExecInst field.See Appendix O - Foreign Exchange Trading</item></list><para>Orders involving or requiring Pre-Trade Allocation consist of the following steps:</para>
			/// <list type="bullet"><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item></list><para>To "take" an IOI (or Quote) from an ECN or exchange and not display the order on the book, the New Order message should contain the TimeInForce field with ImmediateOrCancel and an OrdType field with Previously Indicated ( or Previously Quoted).</para>
			/// <para>The presence of DiscretionInst on an order indicates that the trader wishes to display one price but will accept trades at another price. For example a sell order with OrdType = Limit, Price=50.00, DiscretionInst = Related to displayed price and DiscretionOffset = -0.25 means that the order should be displayed as an offer for 50.00, but will match any bid &gt;= 49.75 Discretionary pricing can also be used when pegging an order - for example to indicate that a buy order is to be displayed as pegged to the bid minus 0.25, but can be matched by anything &lt;= the offer, set OrdType=Pegged, ExecInst = Primary Peg, PegDifference = -0.25, DiscretionInst = Related to market price and DiscretionOffset = 0.</para>
			/// <para>See Appendix D: Order State Change Matrices</para>
			/// <para>New Order - Single</para>
			/// </summary>
			public class OrderSingle
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// <para>Unique identifier of the order as assigned by institution.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.ClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				private OrderSingleNoAllocsCollection noAllocs;
				/// <summary>
				/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
				/// <para>Number of repeating groups for pre-trade allocation</para>
				/// </summary>
				public OrderSingleNoAllocsCollection NoAllocs
				{
					get
					{
						return noAllocs;
					}
				}

				/// <summary>
				/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Regular</para>
				/// <para>1 = Cash</para>
				/// <para>2 = Next Day</para>
				/// <para>3 = T+2</para>
				/// <para>4 = T+3</para>
				/// <para>5 = T+4</para>
				/// <para>6 = Future</para>
				/// <para>7 = When Issued</para>
				/// <para>8 = Sellers Option</para>
				/// <para>9 = T+ 5</para>
				/// <para>Absence of this field is interpreted as Regular.</para>
				/// </summary>
				public SettlmntTyp? SettlmntTyp
				{
					get
					{
						SettlmntTyp v;
						if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
					}
				}

				/// <summary>
				/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
				/// <para>Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option)</para>
				/// </summary>
				public System.DateTime? FutSettDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on Broker trading floor</para>
				/// <para>Valid values:</para>
				/// <para>1 = Automated execution order, private, no Broker intervention</para>
				/// <para>2 = Automated execution order, public, Broker intervention OK</para>
				/// <para>3 = Manual order, best execution</para>
				/// </summary>
				public HandlInst HandlInst
				{
					get
					{
						return fieldSet.GetHandlInst(Tags.HandlInst);
					}
					set
					{
						fieldSet.Set(Tags.HandlInst, value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Not held</para>
				/// <para>2 = Work</para>
				/// <para>3 = Go along</para>
				/// <para>4 = Over the day</para>
				/// <para>5 = Held</para>
				/// <para>6 = Participate don't initiate</para>
				/// <para>7 = Strict scale</para>
				/// <para>8 = Try to scale</para>
				/// <para>9 = Stay on bidside</para>
				/// <para>0 = Stay on offerside</para>
				/// <para>A = No cross (cross is forbidden)</para>
				/// <para>B = OK to cross</para>
				/// <para>C = Call first</para>
				/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
				/// <para>E = Do not increase - DNI</para>
				/// <para>F = Do not reduce - DNR</para>
				/// <para>G = All or none - AON</para>
				/// <para>I = Institutions only</para>
				/// <para>L = Last peg (last sale)</para>
				/// <para>M = Mid-price peg (midprice of inside quote)</para>
				/// <para>N = Non-negotiable</para>
				/// <para>O = Opening peg</para>
				/// <para>P = Market peg</para>
				/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
				/// <para>S = Suspend</para>
				/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
				/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
				/// <para>V = Netting (for Forex)</para>
				/// <para>W = Peg to VWAP</para>
				/// <para>Can contain multiple instructions, space delimited. If OrdType=P, exactly one of the following values (ExecInst = L, R, M, P, O, T, or W) must be specified.</para>
				/// </summary>
				public ExecInst? ExecInst
				{
					get
					{
						ExecInst v;
						if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Minimum quantity of an order to be executed.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MinQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown on the exchange floor at any given time.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxFloor
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxFloor, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxFloor); else fieldSet.Set(Tags.MaxFloor, value.Value);
					}
				}

				/// <summary>
				/// <para>Execution destination as defined by institution when order is entered.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String ExDestination
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExDestination, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExDestination); else fieldSet.Set(Tags.ExDestination, value);
					}
				}

				private OrderSingleNoTradingSessionsCollection noTradingSessions;
				/// <summary>
				/// <para>Number of TradingSessionIDs in repeating group.</para>
				/// <para>Specifies the number of repeating TradingSessionIDs</para>
				/// </summary>
				public OrderSingleNoTradingSessionsCollection NoTradingSessions
				{
					get
					{
						return noTradingSessions;
					}
				}

				/// <summary>
				/// <para>Processing code for sub-account. Absence of this field in AllocAccount / AllocPrice/AllocShares / ProcessCode instance indicates regular trade.</para>
				/// <para>Valid values:</para>
				/// <para>0 = regular</para>
				/// <para>1 = soft dollar</para>
				/// <para>2 = step-in</para>
				/// <para>3 = step-out</para>
				/// <para>4 = soft-dollar step-in</para>
				/// <para>5 = soft-dollar step-out</para>
				/// <para>6 = plan sponsor</para>
				/// <para>Used to identify soft trades at order entry.</para>
				/// </summary>
				public ProcessCode? ProcessCode
				{
					get
					{
						ProcessCode v;
						if (fieldSet.TryGetProcessCode(Tags.ProcessCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ProcessCode); else fieldSet.Set(Tags.ProcessCode, value.Value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Previous closing price of security.</para>
				/// <para>Useful for verifying security identification</para>
				/// </summary>
				public System.Double? PrevClosePx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.PrevClosePx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PrevClosePx); else fieldSet.Set(Tags.PrevClosePx, value.Value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the broker is to locate the stock in conjunction with a short sell order.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Indicates the broker is responsible for locating the stock</para>
				/// <para>N = Indicates the broker is not required to locate</para>
				/// <para>Required for short sell orders</para>
				/// </summary>
				public LocateReqd? LocateReqd
				{
					get
					{
						LocateReqd v;
						if (fieldSet.TryGetLocateReqd(Tags.LocateReqd, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LocateReqd); else fieldSet.Set(Tags.LocateReqd, value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time this order request was initiated/released by the trader or trading system.</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified.</para>
				/// </summary>
				public System.Double? OrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
				/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified. Specifies the approximate 'monetary quantity' for the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages.</para>
				/// </summary>
				public System.Double? CashOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Order type.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Market</para>
				/// <para>2 = Limit</para>
				/// <para>3 = Stop</para>
				/// <para>4 = Stop limit</para>
				/// <para>5 = Market on close</para>
				/// <para>6 = With or without</para>
				/// <para>7 = Limit or better</para>
				/// <para>8 = Limit with or without</para>
				/// <para>9 = On basis</para>
				/// <para>A = On close</para>
				/// <para>B = Limit on close</para>
				/// <para>C =Forex - Market</para>
				/// <para>D = Previously quoted</para>
				/// <para>E = Previously indicated</para>
				/// <para>F = Forex - Limit</para>
				/// <para>G = Forex - Swap</para>
				/// <para>H = Forex - Previously Quoted</para>
				/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
				/// <para>P = Pegged</para>
				/// </summary>
				public OrdType OrdType
				{
					get
					{
						return fieldSet.GetOrdType(Tags.OrdType);
					}
					set
					{
						fieldSet.Set(Tags.OrdType, value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required for limit OrdTypes. For F/X orders, should be the 'all-in' rate (spot rate adjusted for forward points). Can be used to specify a limit price for a pegged order, previously indicated, etc.</para>
				/// </summary>
				public System.Double? Price
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required for OrdType = 'Stop' or OrdType = 'Stop limit'.</para>
				/// </summary>
				public System.Double? StopPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StopPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StopPx); else fieldSet.Set(Tags.StopPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>ID used to represent this transaction for compliance purposes (e.g. OATS reporting).</para>
				/// </summary>
				public System.String ComplianceID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ComplianceID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ComplianceID); else fieldSet.Set(Tags.ComplianceID, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the order was solicited.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Was solcitied</para>
				/// <para>N = Was not solicited</para>
				/// </summary>
				public SolicitedFlag? SolicitedFlag
				{
					get
					{
						SolicitedFlag v;
						if (fieldSet.TryGetSolicitedFlag(Tags.SolicitedFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SolicitedFlag); else fieldSet.Set(Tags.SolicitedFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>Unique identifier of IOI message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for Previously Indicated Orders (OrdType=E)</para>
				/// </summary>
				public System.String IOIid
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.IOIid, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IOIid); else fieldSet.Set(Tags.IOIid, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for quote</para>
				/// <para>Required for Previously Quoted Orders (OrdType=D)</para>
				/// </summary>
				public System.String QuoteID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.QuoteID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.QuoteID); else fieldSet.Set(Tags.QuoteID, value);
					}
				}

				/// <summary>
				/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Day</para>
				/// <para>1 = Good Till Cancel (GTC)</para>
				/// <para>2 = At the Opening (OPG)</para>
				/// <para>3 = Immediate or Cancel (IOC)</para>
				/// <para>4 = Fill or Kill (FOK)</para>
				/// <para>5 = Good Till Crossing (GTX)</para>
				/// <para>6 = Good Till Date</para>
				/// <para>Absence of this field indicates Day order</para>
				/// </summary>
				public TimeInForce? TimeInForce
				{
					get
					{
						TimeInForce v;
						if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
					}
				}

				/// <summary>
				/// <para>Time the details within the message should take effect (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Can specify the time at which the order should be considered valid</para>
				/// </summary>
				public System.DateTime? EffectiveTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.EffectiveTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EffectiveTime); else fieldSet.Set(Tags.EffectiveTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireTime is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireDate is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify whether to book out executions on a part-filled GT order on the day of execution or to accumulate.</para>
				/// <para>Valid values:</para>
				/// <para>0 = book out all trades on day of execution</para>
				/// <para>1 = accumulate executions until order is filled or expires</para>
				/// <para>2 = accumulate until verbally notified otherwise</para>
				/// <para>States whether executions are booked out or accumulated on a partially filled GT order</para>
				/// </summary>
				public GTBookingInst? GTBookingInst
				{
					get
					{
						GTBookingInst v;
						if (fieldSet.TryGetGTBookingInst(Tags.GTBookingInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GTBookingInst); else fieldSet.Set(Tags.GTBookingInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
				/// </summary>
				public System.Double? Commission
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Commission, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Commission); else fieldSet.Set(Tags.Commission, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission type</para>
				/// <para>Valid values:</para>
				/// <para>1 = per share</para>
				/// <para>2 = percentage</para>
				/// <para>3 = absolute</para>
				/// </summary>
				public CommType? CommType
				{
					get
					{
						CommType v;
						if (fieldSet.TryGetCommType(Tags.CommType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CommType); else fieldSet.Set(Tags.CommType, value.Value);
					}
				}

				/// <summary>
				/// <para>Note that the name of this field is changing to 'OrderCapacity' as Rule80A is a very US market-specific term. Other world markets need to convey similar information, however, often a subset of the US values. . See the 'Rule80A (aka OrderCapacity) Usage by Market' appendix for market-specific usage of this field.Valid values:</para>
				/// <para>A = Agency single order</para>
				/// <para>B = Short exempt transaction (refer to A type)</para>
				/// <para>C = Program Order, non-index arb, for Member firm/org</para>
				/// <para>D = Program Order, index arb, for Member firm/org</para>
				/// <para>E = Registered Equity Market Maker trades</para>
				/// <para>F = Short exempt transaction (refer to W type)</para>
				/// <para>H = Short exempt transaction (refer to I type)</para>
				/// <para>I = Individual Investor, single order</para>
				/// <para>J = Program Order, index arb, for individual customer</para>
				/// <para>K = Program Order, non-index arb, for individual customer</para>
				/// <para>L = Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
				/// <para>M = Program Order, index arb, for other member</para>
				/// <para>N = Program Order, non-index arb, for other member</para>
				/// <para>O = Competing dealer trades</para>
				/// <para>P = Principal</para>
				/// <para>R = Competing dealer trades</para>
				/// <para>S = Specialist trades</para>
				/// <para>T = Competing dealer trades</para>
				/// <para>U = Program Order, index arb, for other agency</para>
				/// <para>W = All other orders as agent for other member</para>
				/// <para>X = Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
				/// <para>Y = Program Order, non-index arb, for other agency</para>
				/// <para>Z = Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
				/// </summary>
				public Rule80AAkaOrderCapacity? Rule80AAkaOrderCapacity
				{
					get
					{
						Rule80AAkaOrderCapacity v;
						if (fieldSet.TryGetRule80AAkaOrderCapacity(Tags.Rule80A, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Rule80A); else fieldSet.Set(Tags.Rule80A, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates request for forex accommodation trade to be executed along with security transaction.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Execute Forex after security trade</para>
				/// <para>N = Do not execute Forex after security trade</para>
				/// <para>Indicates that broker is requested to execute a Forex accommodation trade in conjunction with the security trade.</para>
				/// </summary>
				public ForexReq? ForexReq
				{
					get
					{
						ForexReq v;
						if (fieldSet.TryGetForexReq(Tags.ForexReq, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ForexReq); else fieldSet.Set(Tags.ForexReq, value.Value);
					}
				}

				/// <summary>
				/// <para>Currency code of settlement denomination.</para>
				/// <para>Required if ForexReq = Y.</para>
				/// </summary>
				public System.String SettlCurrency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlCurrency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrency); else fieldSet.Set(Tags.SettlCurrency, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>FutSettDate of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
				/// </summary>
				public System.DateTime? FutSettDate2
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>OrderQty of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
				/// </summary>
				public System.Double? OrderQty2
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
				/// <para>Valid Values:</para>
				/// <para>O=Open</para>
				/// <para>C=Close</para>
				/// <para>For options</para>
				/// </summary>
				public OpenClose? OpenClose
				{
					get
					{
						OpenClose v;
						if (fieldSet.TryGetOpenClose(Tags.OpenClose, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OpenClose); else fieldSet.Set(Tags.OpenClose, value.Value);
					}
				}

				/// <summary>
				/// <para>Used for options</para>
				/// <para>Valid values:</para>
				/// <para>0 = Covered</para>
				/// <para>1 = Uncovered</para>
				/// <para>For options</para>
				/// </summary>
				public CoveredOrUncovered? CoveredOrUncovered
				{
					get
					{
						CoveredOrUncovered v;
						if (fieldSet.TryGetCoveredOrUncovered(Tags.CoveredOrUncovered, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CoveredOrUncovered); else fieldSet.Set(Tags.CoveredOrUncovered, value.Value);
					}
				}

				/// <summary>
				/// <para>Used for options when delivering the order to an execution system/exchange to specify if the order is for a customer or the firm placing the order itself.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Customer</para>
				/// <para>1 = Firm</para>
				/// <para>For options when delivering the order to execution system/exchange.</para>
				/// </summary>
				public CustomerOrFirm? CustomerOrFirm
				{
					get
					{
						CustomerOrFirm v;
						if (fieldSet.TryGetCustomerOrFirm(Tags.CustomerOrFirm, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CustomerOrFirm); else fieldSet.Set(Tags.CustomerOrFirm, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown to other customers (i.e. sent via an IOI).</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxShow
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxShow, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxShow); else fieldSet.Set(Tags.MaxShow, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the price of the peg for a pegged order.</para>
				/// <para>Amount (signed) added to the price of the peg</para>
				/// </summary>
				public System.Double? PegDifference
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.PegDifference, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PegDifference); else fieldSet.Set(Tags.PegDifference, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Related to displayed price</para>
				/// <para>1 = Related to market price</para>
				/// <para>2 = Related to primary price</para>
				/// <para>3 = Related to local primary price</para>
				/// <para>4 = Related to midpoint price</para>
				/// <para>5 = Related to last trade price</para>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to. Required if DiscretionOffset is specified.</para>
				/// </summary>
				public DiscretionInst? DiscretionInst
				{
					get
					{
						DiscretionInst v;
						if (fieldSet.TryGetDiscretionInst(Tags.DiscretionInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionInst); else fieldSet.Set(Tags.DiscretionInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// </summary>
				public System.Double? DiscretionOffset
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DiscretionOffset, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionOffset); else fieldSet.Set(Tags.DiscretionOffset, value.Value);
					}
				}

				/// <summary>
				/// <para>Firm that will clear the trade. Used if different from the executing firm.</para>
				/// </summary>
				public System.String ClearingFirm
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingFirm, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingFirm); else fieldSet.Set(Tags.ClearingFirm, value);
					}
				}

				/// <summary>
				/// <para>Supplemental accounting information forwared to clearing house/firm.</para>
				/// </summary>
				public System.String ClearingAccount
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingAccount, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingAccount); else fieldSet.Set(Tags.ClearingAccount, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderSingle(Message message)
				{
					this.fieldSet = message;
					this.noAllocs = new OrderSingleNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
					this.noTradingSessions = new OrderSingleNoTradingSessionsCollection(fieldSet, fieldSet.GetGroup(Tags.NoTradingSessions));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderSingle()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Single, new Dialect(ProtocolVersion.FIX42));
					this.noAllocs = new OrderSingleNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
					this.noTradingSessions = new OrderSingleNoTradingSessionsCollection(fieldSet, fieldSet.GetGroup(Tags.NoTradingSessions));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderSingle(System.String clOrdID, HandlInst handlInst, System.String symbol, Side side, System.DateTime transactTime, OrdType ordType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Single, new Dialect(ProtocolVersion.FIX42));
					ClOrdID = clOrdID;
					HandlInst = handlInst;
					Symbol = symbol;
					Side = side;
					TransactTime = transactTime;
					OrdType = ordType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderSingle value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The Order Cancel Request message requests the cancelation of all of the remaining quantity of an existing order. Note that the Order Cancel/Replace Request should be used to partially cancel (reduce) an order).</para>
			/// <para>The request will only be accepted if the order can successfully be pulled back from the exchange floor without executing.</para>
			/// <para>A cancel request is assigned a ClOrdID and is treated as a separate entity. If rejected, the ClOrdID of the cancel request will be sent in the Cancel Reject message, as well as the ClOrdID of the actual order in the OrigClOrdID field. The ClOrdID assigned to the cancel request must be unique amongst the ClOrdID assigned to regular orders and replacement orders.</para>
			/// <para>An immediate response to this message is required. It is recommended that an ExecutionRpt with ExecType=Pending Cancel be sent unless the Order Cancel Request can be immediately accepted (ExecutionRpt with ExecType=Canceled) or rejected (Order Cancel Reject message).</para>
			/// </summary>
			public class OrderCancelRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) as assigned by the institution, used to identify the previous order in cancel and cancel/replace requests.</para>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) when canceling or replacing an order.</para>
				/// </summary>
				public System.String OrigClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.OrigClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.OrigClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// <para>Unique identifier of most recent order as assigned by broker.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// <para>Unique ID of cancel request as assigned by the institution.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.ClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Required for List Orders</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time this order request was initiated/released by the trader or trading system.</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Either CashOrderQty or OrderQty is required. OrderQty = CumQty + LeavesQty (see exceptions above)</para>
				/// </summary>
				public System.Double? OrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
				/// <para>Either CashOrderQty or OrderQty is required. Specifies the approximate 'monetary quantity' for the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages.</para>
				/// </summary>
				public System.Double? CashOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>ID used to represent this transaction for compliance purposes (e.g. OATS reporting).</para>
				/// </summary>
				public System.String ComplianceID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ComplianceID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ComplianceID); else fieldSet.Set(Tags.ComplianceID, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the order was solicited.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Was solcitied</para>
				/// <para>N = Was not solicited</para>
				/// </summary>
				public SolicitedFlag? SolicitedFlag
				{
					get
					{
						SolicitedFlag v;
						if (fieldSet.TryGetSolicitedFlag(Tags.SolicitedFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SolicitedFlag); else fieldSet.Set(Tags.SolicitedFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelRequest(System.String origClOrdID, System.String clOrdID, System.String symbol, Side side, System.DateTime transactTime)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Request, new Dialect(ProtocolVersion.FIX42));
					OrigClOrdID = origClOrdID;
					ClOrdID = clOrdID;
					Symbol = symbol;
					Side = side;
					TransactTime = transactTime;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderCancelRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The order cancel/replace request is used to change the parameters of an existing order.</para>
			/// <para>Do not use this message to cancel the remaining quantity of an outstanding order, use the Cancel Request message for this purpose.</para>
			/// <para>Cancel/Replace will be used to change any valid attribute of an open order (i.e. reduce/increase quantity, change limit price, change instructions, etc.) It can be used to re-open a filled order by increasing OrderQty.</para>
			/// <para>An immediate response to this message is required. It is recommended that an ExecutionRpt with ExecType=Pending Replace be sent unless the Order Cancel/Replace Request can be immediately accepted (ExecutionRpt with ExecType=Replaced) or rejected (Order Cancel Reject message).</para>
			/// <para>The Cancel/Replace request will only be accepted if the order can successfully be pulled back from the exchange floor without executing. Requests which cannot be processed will be rejected using the Cancel Reject message. The Cancel Reject message should provide the ClOrdID and OrigClOrdID values which were specified on the Cancel/Replace Request message for identification.</para>
			/// <para>Note that while it is necessary for the ClOrdID to change and be unique, the broker's OrderID field does not necessarily have to change as a result of the Cancel/Replace request.</para>
			/// <para>Only a limited number of fields can be changed via the cancel/replace request message. All other fields should be retransmitted as sent in the original order. The fields which can be changed via this message are:</para>
			/// <list type="bullet"><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item><item>ExecInstOrderQtyOrdTypePriceHandlInstTimeInForceTradingSessionIDEffectiveTimeExpireDateExpireTimeMinQtyMaxFloorStopPxPegDifferenceDiscretionInstDiscretionOffsetCashOrderQtyOrderQty2OpenCloseCoveredOrUncoveredSide (i.e. sell to sell plus)MaxShowLocateReqd</item></list><para>When modifying ExecInst fields in a replacement order, it is necessary to re-declare all ExecInst in the replacement order. ExecInst's will not be carried forward from the original order to the replacement unless re-declared.</para>
			/// <para>Order Cancel/Replace Request (a.k.a. Order Modification Request)</para>
			/// </summary>
			public class OrderCancelReplaceRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// <para>Unique identifier of most recent order as assigned by broker.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) as assigned by the institution, used to identify the previous order in cancel and cancel/replace requests.</para>
				/// <para>ClOrdID of the previous order (NOT the initial order of the day) when canceling or replacing an order.</para>
				/// </summary>
				public System.String OrigClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.OrigClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.OrigClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// <para>Unique identifier of replacement order as assigned by institution. Note that this identifier will be used in ClOrdID field of the Cancel Reject message if the replacement request is rejected.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.ClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Required for List Orders</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListID); else fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				private OrderCancelReplaceRequestNoAllocsCollection noAllocs;
				/// <summary>
				/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
				/// <para>Number of repeating groups for pre-trade allocation</para>
				/// </summary>
				public OrderCancelReplaceRequestNoAllocsCollection NoAllocs
				{
					get
					{
						return noAllocs;
					}
				}

				/// <summary>
				/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Regular</para>
				/// <para>1 = Cash</para>
				/// <para>2 = Next Day</para>
				/// <para>3 = T+2</para>
				/// <para>4 = T+3</para>
				/// <para>5 = T+4</para>
				/// <para>6 = Future</para>
				/// <para>7 = When Issued</para>
				/// <para>8 = Sellers Option</para>
				/// <para>9 = T+ 5</para>
				/// <para>Absence of this field is interpreted as Regular.</para>
				/// </summary>
				public SettlmntTyp? SettlmntTyp
				{
					get
					{
						SettlmntTyp v;
						if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
					}
				}

				/// <summary>
				/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
				/// <para>Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option)</para>
				/// </summary>
				public System.DateTime? FutSettDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on Broker trading floor</para>
				/// <para>Valid values:</para>
				/// <para>1 = Automated execution order, private, no Broker intervention</para>
				/// <para>2 = Automated execution order, public, Broker intervention OK</para>
				/// <para>3 = Manual order, best execution</para>
				/// </summary>
				public HandlInst HandlInst
				{
					get
					{
						return fieldSet.GetHandlInst(Tags.HandlInst);
					}
					set
					{
						fieldSet.Set(Tags.HandlInst, value);
					}
				}

				/// <summary>
				/// <para>Instructions for order handling on exchange trading floor. If more than one instruction is applicable to an order, this field can contain multiple instructions separated by space.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Not held</para>
				/// <para>2 = Work</para>
				/// <para>3 = Go along</para>
				/// <para>4 = Over the day</para>
				/// <para>5 = Held</para>
				/// <para>6 = Participate don't initiate</para>
				/// <para>7 = Strict scale</para>
				/// <para>8 = Try to scale</para>
				/// <para>9 = Stay on bidside</para>
				/// <para>0 = Stay on offerside</para>
				/// <para>A = No cross (cross is forbidden)</para>
				/// <para>B = OK to cross</para>
				/// <para>C = Call first</para>
				/// <para>D = Percent of volume '(indicates that the sender does not want to be all of the volume on the floor vs. a specific percentage)'</para>
				/// <para>E = Do not increase - DNI</para>
				/// <para>F = Do not reduce - DNR</para>
				/// <para>G = All or none - AON</para>
				/// <para>I = Institutions only</para>
				/// <para>L = Last peg (last sale)</para>
				/// <para>M = Mid-price peg (midprice of inside quote)</para>
				/// <para>N = Non-negotiable</para>
				/// <para>O = Opening peg</para>
				/// <para>P = Market peg</para>
				/// <para>R = Primary peg (primary market - buy at bid/sell at offer)</para>
				/// <para>S = Suspend</para>
				/// <para>T = Fixed Peg to Local best bid or offer at time of order</para>
				/// <para>U = Customer Display Instruction (Rule11Ac1-1/4)</para>
				/// <para>V = Netting (for Forex)</para>
				/// <para>W = Peg to VWAP</para>
				/// <para>Can contain multiple instructions, space delimited. Replacement order must be created with new parameters (i.e. original order values will not be brought forward to replacement order unless redefined within this message).</para>
				/// </summary>
				public ExecInst? ExecInst
				{
					get
					{
						ExecInst v;
						if (fieldSet.TryGetExecInst(Tags.ExecInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecInst); else fieldSet.Set(Tags.ExecInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Minimum quantity of an order to be executed.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MinQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MinQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MinQty); else fieldSet.Set(Tags.MinQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown on the exchange floor at any given time.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxFloor
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxFloor, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxFloor); else fieldSet.Set(Tags.MaxFloor, value.Value);
					}
				}

				/// <summary>
				/// <para>Execution destination as defined by institution when order is entered.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// </summary>
				public System.String ExDestination
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExDestination, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExDestination); else fieldSet.Set(Tags.ExDestination, value);
					}
				}

				private OrderCancelReplaceRequestNoTradingSessionsCollection noTradingSessions;
				/// <summary>
				/// <para>Number of TradingSessionIDs in repeating group.</para>
				/// <para>Specifies the number of repeating TradingSessionIDs</para>
				/// </summary>
				public OrderCancelReplaceRequestNoTradingSessionsCollection NoTradingSessions
				{
					get
					{
						return noTradingSessions;
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// <para>Must match original order</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// <para>Must match original order</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// <para>Must match original order</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// <para>Must match original side, however, Buy and Buy Minus can be interchanged as well as Sell and Sell Plus</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time this order request was initiated/released by the trader or trading system.</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified. Should be the 'Total Intended Order Quantity' (including the amount already executed for this chain of orders)</para>
				/// </summary>
				public System.Double? OrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
				/// <para>Either CashOrderQty or OrderQty is required. Note that either, but not both, CashOrderQty or OrderQty should be specified. Specifies the approximate 'monetary quantity' for the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages.</para>
				/// </summary>
				public System.Double? CashOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Order type.</para>
				/// <para>Valid values:</para>
				/// <para>1 = Market</para>
				/// <para>2 = Limit</para>
				/// <para>3 = Stop</para>
				/// <para>4 = Stop limit</para>
				/// <para>5 = Market on close</para>
				/// <para>6 = With or without</para>
				/// <para>7 = Limit or better</para>
				/// <para>8 = Limit with or without</para>
				/// <para>9 = On basis</para>
				/// <para>A = On close</para>
				/// <para>B = Limit on close</para>
				/// <para>C =Forex - Market</para>
				/// <para>D = Previously quoted</para>
				/// <para>E = Previously indicated</para>
				/// <para>F = Forex - Limit</para>
				/// <para>G = Forex - Swap</para>
				/// <para>H = Forex - Previously Quoted</para>
				/// <para>I = Funari (Limit Day Order with unexecuted portion handled as Market On Close. e.g. Japan)</para>
				/// <para>P = Pegged</para>
				/// </summary>
				public OrdType OrdType
				{
					get
					{
						return fieldSet.GetOrdType(Tags.OrdType);
					}
					set
					{
						fieldSet.Set(Tags.OrdType, value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required for limit OrdTypes. For F/X orders, should be the 'all-in' rate (spot rate adjusted for forward points). Can be used to specify a limit price for a pegged order, previously indicated, etc.</para>
				/// </summary>
				public System.Double? Price
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Price, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Price); else fieldSet.Set(Tags.Price, value.Value);
					}
				}

				/// <summary>
				/// <para>Price per share</para>
				/// <para>Required for OrdType = 'Stop' or OrdType = 'Stop limit'.</para>
				/// </summary>
				public System.Double? StopPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StopPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StopPx); else fieldSet.Set(Tags.StopPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the price of the peg for a pegged order.</para>
				/// <para>Amount (signed) added to the price of the peg</para>
				/// </summary>
				public System.Double? PegDifference
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.PegDifference, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PegDifference); else fieldSet.Set(Tags.PegDifference, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Related to displayed price</para>
				/// <para>1 = Related to market price</para>
				/// <para>2 = Related to primary price</para>
				/// <para>3 = Related to local primary price</para>
				/// <para>4 = Related to midpoint price</para>
				/// <para>5 = Related to last trade price</para>
				/// <para>Code to identify the price a DiscretionOffset is related to and should be mathematically added to. Required if DiscretionOffset is specified.</para>
				/// </summary>
				public DiscretionInst? DiscretionInst
				{
					get
					{
						DiscretionInst v;
						if (fieldSet.TryGetDiscretionInst(Tags.DiscretionInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionInst); else fieldSet.Set(Tags.DiscretionInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// <para>Amount (signed) added to the 'related to' price specified via DiscretionInst.</para>
				/// </summary>
				public System.Double? DiscretionOffset
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.DiscretionOffset, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.DiscretionOffset); else fieldSet.Set(Tags.DiscretionOffset, value.Value);
					}
				}

				/// <summary>
				/// <para>ID used to represent this transaction for compliance purposes (e.g. OATS reporting).</para>
				/// </summary>
				public System.String ComplianceID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ComplianceID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ComplianceID); else fieldSet.Set(Tags.ComplianceID, value);
					}
				}

				/// <summary>
				/// <para>Indicates whether or not the order was solicited.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Was solcitied</para>
				/// <para>N = Was not solicited</para>
				/// </summary>
				public SolicitedFlag? SolicitedFlag
				{
					get
					{
						SolicitedFlag v;
						if (fieldSet.TryGetSolicitedFlag(Tags.SolicitedFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SolicitedFlag); else fieldSet.Set(Tags.SolicitedFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// <para>Must match original order.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Specifies how long the order remains in effect. Absence of this field is interpreted as DAY.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Day</para>
				/// <para>1 = Good Till Cancel (GTC)</para>
				/// <para>2 = At the Opening (OPG)</para>
				/// <para>3 = Immediate or Cancel (IOC)</para>
				/// <para>4 = Fill or Kill (FOK)</para>
				/// <para>5 = Good Till Crossing (GTX)</para>
				/// <para>6 = Good Till Date</para>
				/// <para>Absence of this field indicates Day order</para>
				/// </summary>
				public TimeInForce? TimeInForce
				{
					get
					{
						TimeInForce v;
						if (fieldSet.TryGetTimeInForce(Tags.TimeInForce, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TimeInForce); else fieldSet.Set(Tags.TimeInForce, value.Value);
					}
				}

				/// <summary>
				/// <para>Time the details within the message should take effect (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Can specify the time at which the order should be considered valid</para>
				/// </summary>
				public System.DateTime? EffectiveTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.EffectiveTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EffectiveTime); else fieldSet.Set(Tags.EffectiveTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Date of order expiration (last day the order can trade), always expressed in terms of the local market date. The time at which the order expires is determined by the local market's business practices</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireTime is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireDate); else fieldSet.Set(Tags.ExpireDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Time/Date of order expiration (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Conditionally required if TimeInForce = GTD and ExpireDate is not specified.</para>
				/// </summary>
				public System.DateTime? ExpireTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.ExpireTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExpireTime); else fieldSet.Set(Tags.ExpireTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify whether to book out executions on a part-filled GT order on the day of execution or to accumulate.</para>
				/// <para>Valid values:</para>
				/// <para>0 = book out all trades on day of execution</para>
				/// <para>1 = accumulate executions until order is filled or expires</para>
				/// <para>2 = accumulate until verbally notified otherwise</para>
				/// <para>States whether executions are booked out or accumulated on a partially filled GT order</para>
				/// </summary>
				public GTBookingInst? GTBookingInst
				{
					get
					{
						GTBookingInst v;
						if (fieldSet.TryGetGTBookingInst(Tags.GTBookingInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GTBookingInst); else fieldSet.Set(Tags.GTBookingInst, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission. Note if CommType is percentage, Commission of 5% should be represented as .05.</para>
				/// </summary>
				public System.Double? Commission
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.Commission, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Commission); else fieldSet.Set(Tags.Commission, value.Value);
					}
				}

				/// <summary>
				/// <para>Commission type</para>
				/// <para>Valid values:</para>
				/// <para>1 = per share</para>
				/// <para>2 = percentage</para>
				/// <para>3 = absolute</para>
				/// </summary>
				public CommType? CommType
				{
					get
					{
						CommType v;
						if (fieldSet.TryGetCommType(Tags.CommType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CommType); else fieldSet.Set(Tags.CommType, value.Value);
					}
				}

				/// <summary>
				/// <para>Note that the name of this field is changing to 'OrderCapacity' as Rule80A is a very US market-specific term. Other world markets need to convey similar information, however, often a subset of the US values. . See the 'Rule80A (aka OrderCapacity) Usage by Market' appendix for market-specific usage of this field.Valid values:</para>
				/// <para>A = Agency single order</para>
				/// <para>B = Short exempt transaction (refer to A type)</para>
				/// <para>C = Program Order, non-index arb, for Member firm/org</para>
				/// <para>D = Program Order, index arb, for Member firm/org</para>
				/// <para>E = Registered Equity Market Maker trades</para>
				/// <para>F = Short exempt transaction (refer to W type)</para>
				/// <para>H = Short exempt transaction (refer to I type)</para>
				/// <para>I = Individual Investor, single order</para>
				/// <para>J = Program Order, index arb, for individual customer</para>
				/// <para>K = Program Order, non-index arb, for individual customer</para>
				/// <para>L = Short exempt transaction for member competing market-maker affiliated with the firm clearing the trade (refer to P and O types)</para>
				/// <para>M = Program Order, index arb, for other member</para>
				/// <para>N = Program Order, non-index arb, for other member</para>
				/// <para>O = Competing dealer trades</para>
				/// <para>P = Principal</para>
				/// <para>R = Competing dealer trades</para>
				/// <para>S = Specialist trades</para>
				/// <para>T = Competing dealer trades</para>
				/// <para>U = Program Order, index arb, for other agency</para>
				/// <para>W = All other orders as agent for other member</para>
				/// <para>X = Short exempt transaction for member competing market-maker not affiliated with the firm clearing the trade (refer to W and T types)</para>
				/// <para>Y = Program Order, non-index arb, for other agency</para>
				/// <para>Z = Short exempt transaction for non-member competing market-maker (refer to A and R types)</para>
				/// <para>Must match original order</para>
				/// </summary>
				public Rule80AAkaOrderCapacity? Rule80AAkaOrderCapacity
				{
					get
					{
						Rule80AAkaOrderCapacity v;
						if (fieldSet.TryGetRule80AAkaOrderCapacity(Tags.Rule80A, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Rule80A); else fieldSet.Set(Tags.Rule80A, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates request for forex accommodation trade to be executed along with security transaction.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Execute Forex after security trade</para>
				/// <para>N = Do not execute Forex after security trade</para>
				/// <para>Indicates that broker is requested to execute a Forex accommodation trade in conjunction with the security trade.</para>
				/// </summary>
				public ForexReq? ForexReq
				{
					get
					{
						ForexReq v;
						if (fieldSet.TryGetForexReq(Tags.ForexReq, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ForexReq); else fieldSet.Set(Tags.ForexReq, value.Value);
					}
				}

				/// <summary>
				/// <para>Currency code of settlement denomination.</para>
				/// <para>Required if ForexReq = Y.</para>
				/// </summary>
				public System.String SettlCurrency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlCurrency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlCurrency); else fieldSet.Set(Tags.SettlCurrency, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>FutSettDate of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the 'value date' for the future portion of a F/X swap.</para>
				/// </summary>
				public System.DateTime? FutSettDate2
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate2, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate2); else fieldSet.Set(Tags.FutSettDate2, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>OrderQty of the future part of a F/X swap order.</para>
				/// <para>Can be used with OrdType = 'Forex - Swap' to specify the order quantity for the future portion of a F/X swap.</para>
				/// </summary>
				public System.Double? OrderQty2
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty2, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty2); else fieldSet.Set(Tags.OrderQty2, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
				/// <para>Valid Values:</para>
				/// <para>O=Open</para>
				/// <para>C=Close</para>
				/// <para>For options</para>
				/// </summary>
				public OpenClose? OpenClose
				{
					get
					{
						OpenClose v;
						if (fieldSet.TryGetOpenClose(Tags.OpenClose, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OpenClose); else fieldSet.Set(Tags.OpenClose, value.Value);
					}
				}

				/// <summary>
				/// <para>Used for options</para>
				/// <para>Valid values:</para>
				/// <para>0 = Covered</para>
				/// <para>1 = Uncovered</para>
				/// <para>For options</para>
				/// </summary>
				public CoveredOrUncovered? CoveredOrUncovered
				{
					get
					{
						CoveredOrUncovered v;
						if (fieldSet.TryGetCoveredOrUncovered(Tags.CoveredOrUncovered, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CoveredOrUncovered); else fieldSet.Set(Tags.CoveredOrUncovered, value.Value);
					}
				}

				/// <summary>
				/// <para>Used for options when delivering the order to an execution system/exchange to specify if the order is for a customer or the firm placing the order itself.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Customer</para>
				/// <para>1 = Firm</para>
				/// <para>For options when delivering the order to execution system/exchange.</para>
				/// </summary>
				public CustomerOrFirm? CustomerOrFirm
				{
					get
					{
						CustomerOrFirm v;
						if (fieldSet.TryGetCustomerOrFirm(Tags.CustomerOrFirm, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CustomerOrFirm); else fieldSet.Set(Tags.CustomerOrFirm, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of shares within an order to be shown to other customers (i.e. sent via an IOI).</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// </summary>
				public System.Double? MaxShow
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.MaxShow, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxShow); else fieldSet.Set(Tags.MaxShow, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the broker is to locate the stock in conjunction with a short sell order.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Indicates the broker is responsible for locating the stock</para>
				/// <para>N = Indicates the broker is not required to locate</para>
				/// </summary>
				public LocateReqd? LocateReqd
				{
					get
					{
						LocateReqd v;
						if (fieldSet.TryGetLocateReqd(Tags.LocateReqd, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LocateReqd); else fieldSet.Set(Tags.LocateReqd, value.Value);
					}
				}

				/// <summary>
				/// <para>Firm that will clear the trade. Used if different from the executing firm.</para>
				/// </summary>
				public System.String ClearingFirm
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingFirm, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingFirm); else fieldSet.Set(Tags.ClearingFirm, value);
					}
				}

				/// <summary>
				/// <para>Supplemental accounting information forwared to clearing house/firm.</para>
				/// </summary>
				public System.String ClearingAccount
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClearingAccount, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClearingAccount); else fieldSet.Set(Tags.ClearingAccount, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReplaceRequest(Message message)
				{
					this.fieldSet = message;
					this.noAllocs = new OrderCancelReplaceRequestNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
					this.noTradingSessions = new OrderCancelReplaceRequestNoTradingSessionsCollection(fieldSet, fieldSet.GetGroup(Tags.NoTradingSessions));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReplaceRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Replace_Request, new Dialect(ProtocolVersion.FIX42));
					this.noAllocs = new OrderCancelReplaceRequestNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
					this.noTradingSessions = new OrderCancelReplaceRequestNoTradingSessionsCollection(fieldSet, fieldSet.GetGroup(Tags.NoTradingSessions));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderCancelReplaceRequest(System.String origClOrdID, System.String clOrdID, HandlInst handlInst, System.String symbol, Side side, System.DateTime transactTime, OrdType ordType)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Cancel_Replace_Request, new Dialect(ProtocolVersion.FIX42));
					OrigClOrdID = origClOrdID;
					ClOrdID = clOrdID;
					HandlInst = handlInst;
					Symbol = symbol;
					Side = side;
					TransactTime = transactTime;
					OrdType = ordType;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderCancelReplaceRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The Order Status Request message is used by the institution to generate an order status message back from the broker.</para>
			/// </summary>
			public class OrderStatusRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.OrderID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderID); else fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Order as assigned by institution (identified by SenderCompID or OnBehalfOfCompID as appropriate). Uniqueness must be guaranteed within a single trading day. Firms, particularly those which electronically submit multi-day orders, trade globally or throughout market close periods,should ensure uniqueness across days, for example by embedding a date within the ClOrdID field.</para>
				/// </summary>
				public System.String ClOrdID
				{
					get
					{
						return fieldSet.Get(Tags.ClOrdID);
					}
					set
					{
						fieldSet.Set(Tags.ClOrdID, value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Account mnemonic as agreed between broker and institution.</para>
				/// </summary>
				public System.String Account
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Account, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Account); else fieldSet.Set(Tags.Account, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderStatusRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderStatusRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Status_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderStatusRequest(System.String clOrdID, System.String symbol, Side side)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_Status_Request, new Dialect(ProtocolVersion.FIX42));
					ClOrdID = clOrdID;
					Symbol = symbol;
					Side = side;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderStatusRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling
	{
			/// <summary>
			/// <para>The Don't Know Trade (DK) message notifies a trading partner that an electronically received execution has been rejected. This message can be thought of as an execution Reject message.</para>
			/// <para>This message has special utility when dealing with one-way execution reporting. If the initial Order Acknowledgment message (LastShares=0 and OrdStatus=New) does not match an existing order this message can be used to notify the broker of a potential problem order.</para>
			/// <para>Note that the decision to DK an execution lies with the institution. Some of the mismatches listed in the DKReason field may be acceptable and will not require a DK messages to be generated.</para>
			/// <para>Don't Know Trade (DK)</para>
			/// </summary>
			public class DonTKnowTrade
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Order as assigned by broker. Uniqueness must be guaranteed within a single trading day. Firms which accept multi-day orders should consider embedding a date within the OrderID field to assure uniqueness across days.</para>
				/// <para>Broker Order ID as identified on problem execution</para>
				/// </summary>
				public System.String OrderID
				{
					get
					{
						return fieldSet.Get(Tags.OrderID);
					}
					set
					{
						fieldSet.Set(Tags.OrderID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier of execution message as assigned by broker (will be 0 (zero) for ExecTransType=3 (Status)).</para>
				/// <para>Uniqueness must be guaranteed within a single trading day or the life of a multi-day order. Firms which accept multi-day orders should consider embedding a date within the ExecID field to assure uniqueness across days.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Execution ID of problem execution</para>
				/// </summary>
				public System.String ExecID
				{
					get
					{
						return fieldSet.Get(Tags.ExecID);
					}
					set
					{
						fieldSet.Set(Tags.ExecID, value);
					}
				}

				/// <summary>
				/// <para>Reason for execution rejection.</para>
				/// <para>Valid values:</para>
				/// <para>A = Unknown symbol</para>
				/// <para>B = Wrong side</para>
				/// <para>C = Quantity exceeds order</para>
				/// <para>D = No matching order</para>
				/// <para>E = Price exceeds limit</para>
				/// <para>Z = Other</para>
				/// </summary>
				public DKReason DKReason
				{
					get
					{
						return fieldSet.GetDKReason(Tags.DKReason);
					}
					set
					{
						fieldSet.Set(Tags.DKReason, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Number of shares ordered. This represents the number of shares for equities or based on normal convention the number of contracts for options, futures, convertible bonds, etc.</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Either CashOrderQty or OrderQty is required.</para>
				/// </summary>
				public System.Double? OrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.OrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OrderQty); else fieldSet.Set(Tags.OrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the approximate order quantity desired in total monetary units vs. as a number of shares. The broker would be responsible for converting and calculating a share quantity (OrderQty) based upon this amount to be used for the actual order and subsequent messages.</para>
				/// <para>Either CashOrderQty or OrderQty is required. Specifies the approximate 'monetary quantity' for the order. Broker is responsible for converting and calculating OrderQty in shares for subsequent messages.</para>
				/// </summary>
				public System.Double? CashOrderQty
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.CashOrderQty, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashOrderQty); else fieldSet.Set(Tags.CashOrderQty, value.Value);
					}
				}

				/// <summary>
				/// <para>Quantity of shares bought/sold on this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Required if specified on the ExecutionRpt</para>
				/// </summary>
				public System.Double? LastShares
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastShares, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastShares); else fieldSet.Set(Tags.LastShares, value.Value);
					}
				}

				/// <summary>
				/// <para>Price of this (last) fill. Field not required for ExecTransType = 3 (Status)</para>
				/// <para>Required if specified on the ExecutionRpt</para>
				/// </summary>
				public System.Double? LastPx
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.LastPx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastPx); else fieldSet.Set(Tags.LastPx, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public DonTKnowTrade(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public DonTKnowTrade()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Dont_Know_Trade, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public DonTKnowTrade(System.String orderID, System.String execID, DKReason dKReason, System.String symbol, Side side)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Dont_Know_Trade, new Dialect(ProtocolVersion.FIX42));
					OrderID = orderID;
					ExecID = execID;
					DKReason = dKReason;
					Symbol = symbol;
					Side = side;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(DonTKnowTrade value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The NewOrderList Message can be used in one of two ways depending on which market conventions are being followed.</para>
			/// <para>In the "Non disclosed" convention the New Order - List message is sent after the bidding process has been completed, by telephone or electronically. The New Order - List message enumerates the stocks, quantities, direction for the trade and may contain pre-allocation information.</para>
			/// <para>This message may also be used as the first message for the transmission of a program trade where the bidding process has been done by means other than FIX. In this scenario the messages may either be used as a staging process, in which case the broker will start execution once either a ListExecute is received or for immediate execution, in which case the orders will be executed on receipt.</para>
			/// <para>In the "Disclosed" convention the New Order - List message is sent before the bidding process is started, by telephone or electronically. The New Order - List message enumerates the stocks and quantities from the bidding process, and may contain pre-allocation information. The direction of the trade is disclosed after the bidding process is completed.</para>
			/// <para>See Appendix N - Program/Basket/List Trading for an example.</para>
			/// <para>New Order - List</para>
			/// </summary>
			public class OrderList
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Must be unique, by customer, for the day</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Bid Response as assigned by broker. Uniqueness must be guaranteed within a single trading day.</para>
				/// <para>Should refer to an earlier program if bidding took place.</para>
				/// </summary>
				public System.String BidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.BidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidID); else fieldSet.Set(Tags.BidID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for a Bid Request as assigned by institution. Uniqueness must be guaranteed within a single trading day.</para>
				/// </summary>
				public System.String ClientBidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientBidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientBidID); else fieldSet.Set(Tags.ClientBidID, value);
					}
				}

				/// <summary>
				/// <para>Code to identify the desired frequency of progress reports.</para>
				/// <para>Valid values:</para>
				/// <para>1 - BuySide explicitly requests status using StatusRequest (Default) The sell-side firm can however, send a DONE status List Status Response in an unsolicited fashion</para>
				/// <para>2 - SellSide periodically sends status using ListStatus. Period optionally specified in ProgressPeriod</para>
				/// <para>3 - Real-time execution reports (to be discouraged)</para>
				/// </summary>
				public ProgRptReqs? ProgRptReqs
				{
					get
					{
						ProgRptReqs v;
						if (fieldSet.TryGetProgRptReqs(Tags.ProgRptReqs, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ProgRptReqs); else fieldSet.Set(Tags.ProgRptReqs, value.Value);
					}
				}

				/// <summary>
				/// <para>Code to identify the type of Bid Request.</para>
				/// <para>Valid values:</para>
				/// <para>1 - 'Non Disclosed' Style (e.g. US/European)</para>
				/// <para>2 - 'Disclosed' Style (e.g. Japanese)</para>
				/// <para>3 - No Bidding Process</para>
				/// <para>e.g. Non Disclosed Model, Disclosed Model, No Bidding Process</para>
				/// </summary>
				public System.String BidType
				{
					get
					{
						return fieldSet.Get(Tags.BidType);
					}
					set
					{
						fieldSet.Set(Tags.BidType, value);
					}
				}

				/// <summary>
				/// <para>Time in minutes between each ListStatus report sent by SellSide. Zero means don't send status.</para>
				/// </summary>
				public System.String ProgPeriodInterval
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ProgPeriodInterval, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ProgPeriodInterval); else fieldSet.Set(Tags.ProgPeriodInterval, value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of ListExecInst.</para>
				/// <para>Valid values:</para>
				/// <para>1 - Immediate</para>
				/// <para>2 - Wait for Execute Instruction (e.g. a List Execute message or phone call before proceeding with execution of the list)</para>
				/// <para>Controls when execution should be begin.</para>
				/// </summary>
				public ListExecInstType? ListExecInstType
				{
					get
					{
						ListExecInstType v;
						if (fieldSet.TryGetListExecInstType(Tags.ListExecInstType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListExecInstType); else fieldSet.Set(Tags.ListExecInstType, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text message containing list handling and execution instructions.</para>
				/// <para>Free-form text.</para>
				/// </summary>
				public System.String ListExecInst
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListExecInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListExecInst); else fieldSet.Set(Tags.ListExecInst, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedListExecInst field.</para>
				/// <para>Must be set if EncodedListExecInst field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedListExecInstLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedListExecInstLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedListExecInstLen); else fieldSet.Set(Tags.EncodedListExecInstLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the ListExecInst field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the ListExecInst field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the ListExecInst field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedListExecInst
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedListExecInst, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedListExecInst); else fieldSet.Set(Tags.EncodedListExecInst, value);
					}
				}

				/// <summary>
				/// <para>Total number of list order entries across all messages. Should be the sum of all NoOrders in each message that has repeating list order entries related to the same ListID. Used to support fragmentation.</para>
				/// <para>(Prior to FIX 4.2 this field was named "ListNoOrds")</para>
				/// <para>Used to support fragmentation. Sum of NoOrders across all messages with the same ListID.</para>
				/// </summary>
				public System.String TotNoOrdersFormerlyNamedListNoOrds
				{
					get
					{
						return fieldSet.Get(Tags.TotNoOrders);
					}
					set
					{
						fieldSet.Set(Tags.TotNoOrders, value);
					}
				}

				private OrderListNoOrdersCollection noOrders;
				/// <summary>
				/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
				/// <para>Number of orders in this message (number of repeating groups to follow)</para>
				/// </summary>
				public OrderListNoOrdersCollection NoOrders
				{
					get
					{
						return noOrders;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderList(Message message)
				{
					this.fieldSet = message;
					this.noOrders = new OrderListNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderList()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_List, new Dialect(ProtocolVersion.FIX42));
					this.noOrders = new OrderListNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public OrderList(System.String listID, System.String bidType, System.String totNoOrdersFormerlyNamedListNoOrds)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Order_List, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
					BidType = bidType;
					TotNoOrdersFormerlyNamedListNoOrds = totNoOrdersFormerlyNamedListNoOrds;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(OrderList value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The List Cancel Request message type is used by institutions wishing to cancel previously submitted lists either before or during execution.</para>
			/// <para>After the list has been staged with the broker, it can be canceled via the submission of the List Cancel message. If the list has not yet been submitted for execution, the List Cancel message will instruct the broker not to execute it, if the list is being executed, the List Cancel message should trigger the broker's system to generate cancel requests for the remaining quantities of each order within the list. Individual orders within the list can be canceled via the Order Cancel Request message.</para>
			/// </summary>
			public class ListCancelRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time this order request was initiated/released by the trader or trading system.</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListCancelRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListCancelRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Cancel_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListCancelRequest(System.String listID, System.DateTime transactTime)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Cancel_Request, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
					TransactTime = transactTime;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ListCancelRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The List Execute message type is used by institutions to instruct the broker to begin execution of a previously submitted list. This message may or may not be used, as it may be mirroring a phone conversation.</para>
			/// </summary>
			public class ListExecute
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// <para>Must be unique, by customer, for the day</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for a Bid Request as assigned by institution. Uniqueness must be guaranteed within a single trading day.</para>
				/// <para>Used with BidType=Disclosed to provide the sell side the ability to determine the direction of the trade to execute.</para>
				/// </summary>
				public System.String ClientBidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientBidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientBidID); else fieldSet.Set(Tags.ClientBidID, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Bid Response as assigned by broker. Uniqueness must be guaranteed within a single trading day.</para>
				/// </summary>
				public System.String BidID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.BidID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BidID); else fieldSet.Set(Tags.BidID, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Time this order request was initiated/released by the trader or trading system.</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListExecute(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListExecute()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Execute, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListExecute(System.String listID, System.DateTime transactTime)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Execute, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
					TransactTime = transactTime;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ListExecute value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The List Status Request message type is used by institutions to instruct the broker to generate status messages for a list.</para>
			/// </summary>
			public class ListStatusRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatusRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatusRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Status_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatusRequest(System.String listID)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Status_Request, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ListStatusRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The List Status message is issued as the response to a List Status Request message sent in an unsolicited fashion by the sell-side. It indicates the current state of the orders within the list as they exists at the broker's site.</para>
			/// <para>Orders within the list are statused at the summary level. Individual executions are not reported, rather, the current state of the order is reported.</para>
			/// <para>The message contains repeating fields for each. The relative position of the repeating fields is important in this message, i.e. each instance of ClOrdID, CumQty, LeavesQty, CxlQty and AvgPx must be in the order shown below.</para>
			/// <para>Description of ListOrderStatus field values:</para>
			/// <list type="bullet"><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item><item>"InBiddingProcess": indicates that a list has been received and is being evalutated for pricing. It is envisaged that this status will only be used with the "Disclosed" List Order Trading model."ReceivedForExecution": indicates that a list has been received and the sell side is awaiting the instruction to start working the trade. It is envisaged that this status will be used under both models."Executing": indicates that a list has been received and the sell side is working it."Canceling": indicates that a List Cancel Message has been received and the sell side is in the process of pulling any orders that were being worked. The status of individual order can be found out from the detail repeating group."AllDone": indicates that a list has been executed as far as possible for the day."Alert": used whenever any of the individual orders have a status that requires something to be done. For instance alert would be used when a buy-side firm has submitted a list that has individual stock reject that have not been addressed."Rejected" used when a response cannot be generated. For example when the ListID is not recognised. The Text field should include an explanation of why the Request s been rejected.</item></list>
			/// </summary>
			public class ListStatus
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Code to represent the price type.</para>
				/// <para>Valid values:</para>
				/// <para>1 - Ack</para>
				/// <para>2 - Response</para>
				/// <para>3 - Timed</para>
				/// <para>4 - ExecStarted</para>
				/// <para>5 - AllDone</para>
				/// <para>6 - Alert</para>
				/// </summary>
				public System.String ListStatusType
				{
					get
					{
						return fieldSet.Get(Tags.ListStatusType);
					}
					set
					{
						fieldSet.Set(Tags.ListStatusType, value);
					}
				}

				/// <summary>
				/// <para>Total number of reports within series.</para>
				/// <para>Total number of messages required to status complete list.</para>
				/// </summary>
				public System.String NoRpts
				{
					get
					{
						return fieldSet.Get(Tags.NoRpts);
					}
					set
					{
						fieldSet.Set(Tags.NoRpts, value);
					}
				}

				/// <summary>
				/// <para>Code to represent the status of a list order.</para>
				/// <para>Valid values:</para>
				/// <para>1 - InBiddingProcess</para>
				/// <para>2 - ReceivedForExecution</para>
				/// <para>3 - Executing</para>
				/// <para>4 - Canceling</para>
				/// <para>5 - Alert</para>
				/// <para>6 - All Done</para>
				/// <para>7 - Reject</para>
				/// </summary>
				public System.String ListOrderStatus
				{
					get
					{
						return fieldSet.Get(Tags.ListOrderStatus);
					}
					set
					{
						fieldSet.Set(Tags.ListOrderStatus, value);
					}
				}

				/// <summary>
				/// <para>Sequence number of message within report series.</para>
				/// <para>Sequence number of this report message.</para>
				/// </summary>
				public System.String RptSeq
				{
					get
					{
						return fieldSet.Get(Tags.RptSeq);
					}
					set
					{
						fieldSet.Set(Tags.RptSeq, value);
					}
				}

				/// <summary>
				/// <para>Free format text string related to List Status.</para>
				/// </summary>
				public System.String ListStatusText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ListStatusText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ListStatusText); else fieldSet.Set(Tags.ListStatusText, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedListStatusText field.</para>
				/// <para>Must be set if EncodedListStatusText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedListStatusTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedListStatusTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedListStatusTextLen); else fieldSet.Set(Tags.EncodedListStatusTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the ListStatusText field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the ListStatusText field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the ListStatusText field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedListStatusText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedListStatusText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedListStatusText); else fieldSet.Set(Tags.EncodedListStatusText, value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Total number of list order entries across all messages. Should be the sum of all NoOrders in each message that has repeating list order entries related to the same ListID. Used to support fragmentation.</para>
				/// <para>(Prior to FIX 4.2 this field was named "ListNoOrds")</para>
				/// <para>Used to support fragmentation. Sum of NoOrders across all messages with the same ListID.</para>
				/// </summary>
				public System.String TotNoOrdersFormerlyNamedListNoOrds
				{
					get
					{
						return fieldSet.Get(Tags.TotNoOrders);
					}
					set
					{
						fieldSet.Set(Tags.TotNoOrders, value);
					}
				}

				private ListStatusNoOrdersCollection noOrders;
				/// <summary>
				/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
				/// <para>Number of orders statused in this message, i.e. number of repeating groups to follow.</para>
				/// </summary>
				public ListStatusNoOrdersCollection NoOrders
				{
					get
					{
						return noOrders;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatus(Message message)
				{
					this.fieldSet = message;
					this.noOrders = new ListStatusNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatus()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Status, new Dialect(ProtocolVersion.FIX42));
					this.noOrders = new ListStatusNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStatus(System.String listID, System.String listStatusType, System.String noRpts, System.String listOrderStatus, System.String rptSeq, System.String totNoOrdersFormerlyNamedListNoOrds)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Status, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
					ListStatusType = listStatusType;
					NoRpts = noRpts;
					ListOrderStatus = listOrderStatus;
					RptSeq = rptSeq;
					TotNoOrdersFormerlyNamedListNoOrds = totNoOrdersFormerlyNamedListNoOrds;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ListStatus value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.OrdersAndExecutionsTrade.ListProgramBasketTrading
	{
			/// <summary>
			/// <para>The strike price message is used to exchange strike price information for principal trades. It can also be used to exchange reference prices for agency trades.</para>
			/// </summary>
			public class ListStrikePrice
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for list as assigned by institution, used to associate multiple individual orders. Uniqueness must be guaranteed within a single trading day. Firms which generate multi-day orders should consider embedding a date within the ListID field to assure uniqueness across days.</para>
				/// </summary>
				public System.String ListID
				{
					get
					{
						return fieldSet.Get(Tags.ListID);
					}
					set
					{
						fieldSet.Set(Tags.ListID, value);
					}
				}

				/// <summary>
				/// <para>Total number of strike price entries across all messages. Should be the sum of all NoStrikes in each message that has repeating strike price entries related to the same ListID. Used to support fragmentation.</para>
				/// <para>Used to support fragmentation. Sum of NoStrikes across all messages with the same ListID.</para>
				/// </summary>
				public System.String TotNoStrikes
				{
					get
					{
						return fieldSet.Get(Tags.TotNoStrikes);
					}
					set
					{
						fieldSet.Set(Tags.TotNoStrikes, value);
					}
				}

				private ListStrikePriceNoStrikesCollection noStrikes;
				/// <summary>
				/// <para>Number of list strike price entries.</para>
				/// <para>Number of strike price entries</para>
				/// </summary>
				public ListStrikePriceNoStrikesCollection NoStrikes
				{
					get
					{
						return noStrikes;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStrikePrice(Message message)
				{
					this.fieldSet = message;
					this.noStrikes = new ListStrikePriceNoStrikesCollection(fieldSet, fieldSet.GetGroup(Tags.NoStrikes));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStrikePrice()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Strike_Price, new Dialect(ProtocolVersion.FIX42));
					this.noStrikes = new ListStrikePriceNoStrikesCollection(fieldSet, fieldSet.GetGroup(Tags.NoStrikes));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ListStrikePrice(System.String listID, System.String totNoStrikes)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.List_Strike_Price, new Dialect(ProtocolVersion.FIX42));
					ListID = listID;
					TotNoStrikes = totNoStrikes;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ListStrikePrice value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PostTrade.AllocationAndReadyToBook
	{
			/// <summary>
			/// <para>The Allocation message provides the ability to specify how an order or set of orders should be subdivided amongst one or more accounts. It can also be used as a confirmation message through which third parties can communicate execution and settlement details between trading partners. In addition, the Allocation message can be sent by the broker to communicate fees and other details that can only be computed once the sub-account breakdowns are known.</para>
			/// <para>Allocation is typically communicated Post-Trade (after fills have been received and processed). It can, however, also be communicated Pre-Trade (at the time the order is being placed) to specify the account(s) and their respective order quantities which make up the order. This is a regulatory requirement in certain markets and for certain types of securities.</para>
			/// <para>An Allocation message can be submitted as preliminary, calculated, calculated without preliminary, new, cancel or replace. The AllocTransType field indicates the purpose of the message. When submitting calculated, replace, or cancel AllocTransType messages the RefAllocID field is required. Note that AllocTransType of Cancel, Reject, or Replace affects the entire Allocation message thus each AllocAccount (cannot cancel, reject, or replace a single AllocAccount instance without affecting the entire Allocation messge). Replacement Allocation messages must contain all data for the replacement allocation. Calculated allocations should have a unique AllocID and use RefAllocID to specify the AllocID from the preliminary. Calculated without preliminary are sent unsolicited from the sellside and do not require RefAllocID.</para>
			/// <para>The Allocation message contains repeating fields for each order, sub-account and individual execution. The repeating fields are shown below in typeface Bold-Italic and indented with the ---&gt;symbol. The field's relative position in the message is important. For example, each instance of allocation must be in the order shown below.</para>
			/// <list type="bullet"><item>The total shares allocated must equal the Shares value which must equal the total executed quantity of the original order. If present, the total shares in the execution section must also be equal to this value.The number of sub-account instances is indicated in NoAllocs.Multiple orders can be combined for allocation by identifying the number of orders in the NoOrders field and each individual order in the OrderID fields. Combined orders must have the same ticker, trade date, settlement date and side.</item><item>The total shares allocated must equal the Shares value which must equal the total executed quantity of the original order. If present, the total shares in the execution section must also be equal to this value.The number of sub-account instances is indicated in NoAllocs.Multiple orders can be combined for allocation by identifying the number of orders in the NoOrders field and each individual order in the OrderID fields. Combined orders must have the same ticker, trade date, settlement date and side.</item><item>The total shares allocated must equal the Shares value which must equal the total executed quantity of the original order. If present, the total shares in the execution section must also be equal to this value.The number of sub-account instances is indicated in NoAllocs.Multiple orders can be combined for allocation by identifying the number of orders in the NoOrders field and each individual order in the OrderID fields. Combined orders must have the same ticker, trade date, settlement date and side.</item></list><para>Pre-Trade Allocation consists of the following steps:</para>
			/// <list type="bullet"><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item><item>Buyside sends a New Order request message specifying one or more AllocAccount and AllocShares values within the repeating group designated by NoAllocs.Sellside sends Execution Report messages for the "New" and resulting fills.Post-Trade Allocation messaging takes place</item></list><para>Post-Trade Allocation can be computed via one of two methods:</para>
			/// <list type="number"><item>Using Average Price: Each AllocAccount has a single AllocAvgPxUsing Executed Price: Combination of each AllocAccount and AllocPrice (unique LastPx) (e.g. Japan)</item><item>Using Average Price: Each AllocAccount has a single AllocAvgPxUsing Executed Price: Combination of each AllocAccount and AllocPrice (unique LastPx) (e.g. Japan)</item></list><para>Post-Trade Allocation supports three different message flows:</para>
			/// <list type="number"><item>Buyside initiated without Misc FeesBuyside-initiated with Misc Fee computationSellside-initiated</item><item>Buyside initiated without Misc FeesBuyside-initiated with Misc Fee computationSellside-initiated</item><item>Buyside initiated without Misc FeesBuyside-initiated with Misc Fee computationSellside-initiated</item></list><para>See Appendix K: Example Usage of Allocations for more examples and details.</para>
			/// <para>Note: Req'd = "Y*" indicates that the field is not required for AllocTransTyp=Cancel</para>
			/// </summary>
			public class Allocation
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Allocation message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// </summary>
				public System.String AllocID
				{
					get
					{
						return fieldSet.Get(Tags.AllocID);
					}
					set
					{
						fieldSet.Set(Tags.AllocID, value);
					}
				}

				/// <summary>
				/// <para>Identifies allocation transaction type</para>
				/// <para>Valid values:</para>
				/// <para>0 = New</para>
				/// <para>1 = Replace</para>
				/// <para>2 = Cancel</para>
				/// <para>3 = Preliminary (without MiscFees and NetMoney)</para>
				/// <para>4 = Calculated (includes MiscFees and NetMoney)</para>
				/// <para>5 = Calculated without Preliminary (sent unsolicited by broker, includes MiscFees and NetMoney)</para>
				/// </summary>
				public AllocTransType AllocTransType
				{
					get
					{
						return fieldSet.GetAllocTransType(Tags.AllocTransType);
					}
					set
					{
						fieldSet.Set(Tags.AllocTransType, value);
					}
				}

				/// <summary>
				/// <para>Reference identifier to be used with Replace, Cancel, and Calculated AllocTransType messages.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for AllocTransType = Calculated, Replace, or Cancel</para>
				/// </summary>
				public System.String RefAllocID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RefAllocID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RefAllocID); else fieldSet.Set(Tags.RefAllocID, value);
					}
				}

				/// <summary>
				/// <para>Can be used to link two different Allocation messages (each with unique AllocID) together, i.e. for F/X 'Netting' or 'Swaps'. Should be unique.</para>
				/// <para>Can be used to link two different Allocation messages (each with unique AllocID) together, i.e. for F/X 'Netting' or 'Swaps'</para>
				/// </summary>
				public System.String AllocLinkID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.AllocLinkID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AllocLinkID); else fieldSet.Set(Tags.AllocLinkID, value);
					}
				}

				/// <summary>
				/// <para>Identifies the type of Allocation linkage when AllocLinkID is used.</para>
				/// <para>Valid values:</para>
				/// <para>0 = F/X Netting</para>
				/// <para>1 = F/X Swap</para>
				/// <para>Can be used to link two different Allocation messages and identifies the type of link. Required if AllocLinkID is specified.</para>
				/// </summary>
				public AllocLinkType? AllocLinkType
				{
					get
					{
						AllocLinkType v;
						if (fieldSet.TryGetAllocLinkType(Tags.AllocLinkType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AllocLinkType); else fieldSet.Set(Tags.AllocLinkType, value.Value);
					}
				}

				private AllocationNoOrdersCollection noOrders;
				/// <summary>
				/// <para>Indicates number of orders to be combined for average pricing and allocation.</para>
				/// <para>Indicates number of orders to be combined for allocation. If order(s) were manually delivered set to 1 (one).</para>
				/// </summary>
				public AllocationNoOrdersCollection NoOrders
				{
					get
					{
						return noOrders;
					}
				}

				private AllocationNoExecsCollection noExecs;
				/// <summary>
				/// <para>No of execution repeating group entries to follow.</para>
				/// <para>Indicates number of individual execution repeating group entries to follow. Absence of this field indicates that no individual execution entries are included. Primarily used to support step-outs.</para>
				/// </summary>
				public AllocationNoExecsCollection NoExecs
				{
					get
					{
						return noExecs;
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// </summary>
				public Side Side
				{
					get
					{
						return fieldSet.GetSide(Tags.Side);
					}
					set
					{
						fieldSet.Set(Tags.Side, value);
					}
				}

				/// <summary>
				/// <para>Ticker symbol</para>
				/// </summary>
				public System.String Symbol
				{
					get
					{
						return fieldSet.Get(Tags.Symbol);
					}
					set
					{
						fieldSet.Set(Tags.Symbol, value);
					}
				}

				/// <summary>
				/// <para>Additional information about the security (e.g. preferred, warrants, etc.). Note also see SecurityType.</para>
				/// <para>Valid values:</para>
				/// <para>As defined in the NYSE Stock and bond Symbol Directory and in the AMEX Fitch Directory</para>
				/// </summary>
				public System.String SymbolSfx
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SymbolSfx, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SymbolSfx); else fieldSet.Set(Tags.SymbolSfx, value);
					}
				}

				/// <summary>
				/// <para>CUSIP or other alternate security identifier</para>
				/// </summary>
				public System.String SecurityID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityID); else fieldSet.Set(Tags.SecurityID, value);
					}
				}

				/// <summary>
				/// <para>Identifies class of alternative SecurityID</para>
				/// <para>Valid values:</para>
				/// <para>1 = CUSIP</para>
				/// <para>2 = SEDOL</para>
				/// <para>3 = QUIK</para>
				/// <para>4 = ISIN number</para>
				/// <para>5 = RIC code</para>
				/// <para>6 = ISO Currency Code</para>
				/// <para>7 = ISO Country Code</para>
				/// <para>8 = Exchange Symbol</para>
				/// <para>9 = Consolidated Tape Association (CTA) Symbol (SIAC CTS/CQS line format)</para>
				/// <para>100+ are reserved for private security identifications</para>
				/// </summary>
				public IDSource? IDSource
				{
					get
					{
						IDSource v;
						if (fieldSet.TryGetIDSource(Tags.IDSource, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.IDSource); else fieldSet.Set(Tags.IDSource, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>Must be specified if a Future or Option. If a Future: Symbol, SecurityType, and MaturityMonthYear are required. If an Option: Symbol, SecurityType, MaturityMonthYear, PutOrCall, and StrikePrice are required.</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Month and Year of the maturity for SecurityType=FUT or SecurityType=OPT. Required if MaturityDay is specified.</para>
				/// <para>Format: YYYYMM</para>
				/// <para>(i.e. 199903)</para>
				/// <para>Specifiesthe month and year of maturity. Required if MaturityDay is specified.</para>
				/// </summary>
				public System.String MaturityMonthYear
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaturityMonthYear, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityMonthYear); else fieldSet.Set(Tags.MaturityMonthYear, value);
					}
				}

				/// <summary>
				/// <para>Day of month used in conjunction with MaturityMonthYear to specify the maturity date for SecurityType=FUT or SecurityType=OPT.</para>
				/// <para>Valid values:</para>
				/// <para>1-31</para>
				/// <para>Can be used in conjunction with MaturityMonthYear to specify a particular maturity date.</para>
				/// </summary>
				public System.Int32? MaturityDay
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.MaturityDay, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaturityDay); else fieldSet.Set(Tags.MaturityDay, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether an Option is for a put or call.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Put</para>
				/// <para>1 = Call</para>
				/// <para>For Options.</para>
				/// </summary>
				public PutOrCall? PutOrCall
				{
					get
					{
						PutOrCall v;
						if (fieldSet.TryGetPutOrCall(Tags.PutOrCall, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.PutOrCall); else fieldSet.Set(Tags.PutOrCall, value.Value);
					}
				}

				/// <summary>
				/// <para>Strike Price for an Option.</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Double? StrikePrice
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.StrikePrice, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StrikePrice); else fieldSet.Set(Tags.StrikePrice, value.Value);
					}
				}

				/// <summary>
				/// <para>Can be used for SecurityType=OPT to identify a particular security.</para>
				/// <para>Valid values vary by SecurityExchange:</para>
				/// <para>For Exchange: MONEP (Paris)</para>
				/// <para>L = Long (a.k.a. 'American')</para>
				/// <para>S = Short (a.k.a. 'European')</para>
				/// <para>For Exchanges: DTB (Frankfurt), HKSE (Hong Kong), and SOFFEX (Zurich)</para>
				/// <para>0-9 = single digit 'version' number assigned by exchange following capital adjustments (0=current, 1=prior, 2=prior to 1, etc).</para>
				/// <para>For Options.</para>
				/// </summary>
				public System.Char? OptAttribute
				{
					get
					{
						System.Char v;
						if (fieldSet.TryGetValue(Tags.OptAttribute, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OptAttribute); else fieldSet.Set(Tags.OptAttribute, value.Value);
					}
				}

				/// <summary>
				/// <para>Specifies the ratio or multiply factor to convert from contracts to shares (e.g. 1.0, 100, 1000, etc). Applicable For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// <para>For Fixed Income, Convertible Bonds, Derivatives, etc. Note: If used, quantities should be expressed in the "nominal" (e.g. contracts vs. shares) amount.</para>
				/// </summary>
				public System.String ContractMultiplier
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ContractMultiplier, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ContractMultiplier); else fieldSet.Set(Tags.ContractMultiplier, value);
					}
				}

				/// <summary>
				/// <para>For Fixed Income. Coupon rate of the bond. Will be zero for step-up bonds.</para>
				/// <para>For Fixed Income.</para>
				/// </summary>
				public System.String CouponRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CouponRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CouponRate); else fieldSet.Set(Tags.CouponRate, value);
					}
				}

				/// <summary>
				/// <para>Market used to help identify a security.</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Can be used to identify the security.</para>
				/// </summary>
				public System.String SecurityExchange
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityExchange, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityExchange); else fieldSet.Set(Tags.SecurityExchange, value);
					}
				}

				/// <summary>
				/// <para>Company name of security issuer (e.g. International Business Machines)</para>
				/// </summary>
				public System.String Issuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Issuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Issuer); else fieldSet.Set(Tags.Issuer, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedIssuer field.</para>
				/// <para>Must be set if EncodedIssuer field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedIssuerLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuerLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuerLen); else fieldSet.Set(Tags.EncodedIssuerLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Issuer field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Issuer field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedIssuer
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedIssuer, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedIssuer); else fieldSet.Set(Tags.EncodedIssuer, value);
					}
				}

				/// <summary>
				/// <para>Security description.</para>
				/// </summary>
				public System.String SecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityDesc); else fieldSet.Set(Tags.SecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedSecurityDesc field.</para>
				/// <para>Must be set if EncodedSecurityDesc field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedSecurityDescLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDescLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDescLen); else fieldSet.Set(Tags.EncodedSecurityDescLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the SecurityDesc field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the SecurityDesc field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedSecurityDesc
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedSecurityDesc, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedSecurityDesc); else fieldSet.Set(Tags.EncodedSecurityDesc, value);
					}
				}

				/// <summary>
				/// <para>Number of shares</para>
				/// <para>(Prior to FIX 4.2 this field was of type int)</para>
				/// <para>Total number of shares allocated to all accounts</para>
				/// </summary>
				public System.Double Shares
				{
					get
					{
						return fieldSet.GetDouble(Tags.Shares);
					}
					set
					{
						fieldSet.Set(Tags.Shares, value);
					}
				}

				/// <summary>
				/// <para>Market of execution for last fill</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Market of the executions.</para>
				/// </summary>
				public System.String LastMkt
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.LastMkt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastMkt); else fieldSet.Set(Tags.LastMkt, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Calculated average price of all fills on this order.</para>
				/// <para>For F/X orders, should be the 'all-in' rate (spot rate adjusted for forward points).</para>
				/// </summary>
				public System.Double AvgPx
				{
					get
					{
						return fieldSet.GetDouble(Tags.AvgPx);
					}
					set
					{
						fieldSet.Set(Tags.AvgPx, value);
					}
				}

				/// <summary>
				/// <para>Identifies currency used for price. Absence of this field is interpreted as the default for the security. It is recommended that systems provide the currency value whenever possible. See Appendix A: Valid Currency Codes for information on obtaining valid values.</para>
				/// <para>Currency of AvgPx. Should be the currency of the local market or exchange where the trade was conducted.</para>
				/// </summary>
				public System.String Currency
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Currency, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Currency); else fieldSet.Set(Tags.Currency, value);
					}
				}

				/// <summary>
				/// <para>Indicates number of decimal places to be used for average pricing. Absence of this field indicates that default precision arranged by the broker/institution is to be used.</para>
				/// <para>Absence of this field indicates that default precision arranged by the broker/institution is to be used</para>
				/// </summary>
				public System.String AvgPrxPrecision
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.AvgPrxPrecision, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AvgPrxPrecision); else fieldSet.Set(Tags.AvgPrxPrecision, value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// </summary>
				public System.DateTime TradeDate
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TradeDate, "LocalMktDate");
					}
					set
					{
						fieldSet.Set(Tags.TradeDate, "LocalMktDate", value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Date/time when allocation is generated</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates order settlement period. Absence of this field is interpreted as Regular. Regular is defined as the default settlement period for the particular security on the exchange of execution.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Regular</para>
				/// <para>1 = Cash</para>
				/// <para>2 = Next Day</para>
				/// <para>3 = T+2</para>
				/// <para>4 = T+3</para>
				/// <para>5 = T+4</para>
				/// <para>6 = Future</para>
				/// <para>7 = When Issued</para>
				/// <para>8 = Sellers Option</para>
				/// <para>9 = T+ 5</para>
				/// <para>Absence of this field is interpreted as Regular</para>
				/// </summary>
				public SettlmntTyp? SettlmntTyp
				{
					get
					{
						SettlmntTyp v;
						if (fieldSet.TryGetSettlmntTyp(Tags.SettlmntTyp, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlmntTyp); else fieldSet.Set(Tags.SettlmntTyp, value.Value);
					}
				}

				/// <summary>
				/// <para>Specific date of trade settlement (SettlementDate) in YYYYMMDD format. Required when SettlmntTyp = 6 (Future) or SettlmntTyp = 8 (Sellers Option). (expressed in local time at place of settlement)</para>
				/// <para>'Settlement Date'. Required with SettlmntTyp other than regular</para>
				/// </summary>
				public System.DateTime? FutSettDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.FutSettDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.FutSettDate); else fieldSet.Set(Tags.FutSettDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Total amount traded (e.g. CumQty * AvgPx) expressed in units of currency.</para>
				/// <para>Expressed in same currency as AvgPx. Sum of (AllocShares * AllocAvgPx or AllocPrice).</para>
				/// </summary>
				public System.Double? GrossTradeAmt
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.GrossTradeAmt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GrossTradeAmt); else fieldSet.Set(Tags.GrossTradeAmt, value.Value);
					}
				}

				/// <summary>
				/// <para>Total amount due as the result of the transaction (e.g. for Buy order - principal + commission + fees) reported in currency of execution.</para>
				/// <para>Expressed in same currency as AvgPx. Sum of AllocNetMoney.</para>
				/// </summary>
				public System.Double? NetMoney
				{
					get
					{
						System.Double v;
						if (fieldSet.TryGetValue(Tags.NetMoney, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.NetMoney); else fieldSet.Set(Tags.NetMoney, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates whether the resulting position after a trade should be an opening position or closing position. Used for omnibus accounting - where accounts are held on a gross basis instead of being netted together.</para>
				/// <para>Valid Values:</para>
				/// <para>O=Open</para>
				/// <para>C=Close</para>
				/// </summary>
				public OpenClose? OpenClose
				{
					get
					{
						OpenClose v;
						if (fieldSet.TryGetOpenClose(Tags.OpenClose, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.OpenClose); else fieldSet.Set(Tags.OpenClose, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// <para>Number of Days of Interest for convertible bonds and fixed income</para>
				/// <para>Applicable for Convertible Bonds and fixed income</para>
				/// </summary>
				public System.String NumDaysInterest
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.NumDaysInterest, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.NumDaysInterest); else fieldSet.Set(Tags.NumDaysInterest, value);
					}
				}

				/// <summary>
				/// <para>Accrued Interest Rate for convertible bonds and fixed income</para>
				/// <para>Applicable for Convertible Bonds and fixed income</para>
				/// </summary>
				public System.String AccruedInterestRate
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.AccruedInterestRate, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AccruedInterestRate); else fieldSet.Set(Tags.AccruedInterestRate, value);
					}
				}

				private AllocationNoAllocsCollection noAllocs;
				/// <summary>
				/// <para>Number of repeating AllocAccount/AllocPrice entries.</para>
				/// <para>Indicates number of allocation groups to follow.</para>
				/// </summary>
				public AllocationNoAllocsCollection NoAllocs
				{
					get
					{
						return noAllocs;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Allocation(Message message)
				{
					this.fieldSet = message;
					this.noOrders = new AllocationNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
					this.noExecs = new AllocationNoExecsCollection(fieldSet, fieldSet.GetGroup(Tags.NoExecs));
					this.noAllocs = new AllocationNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Allocation()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Allocation, new Dialect(ProtocolVersion.FIX42));
					this.noOrders = new AllocationNoOrdersCollection(fieldSet, fieldSet.GetGroup(Tags.NoOrders));
					this.noExecs = new AllocationNoExecsCollection(fieldSet, fieldSet.GetGroup(Tags.NoExecs));
					this.noAllocs = new AllocationNoAllocsCollection(fieldSet, fieldSet.GetGroup(Tags.NoAllocs));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Allocation(System.String allocID, AllocTransType allocTransType, Side side, System.String symbol, System.Double shares, System.Double avgPx, System.DateTime tradeDate)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Allocation, new Dialect(ProtocolVersion.FIX42));
					AllocID = allocID;
					AllocTransType = allocTransType;
					Side = side;
					Symbol = symbol;
					Shares = shares;
					AvgPx = avgPx;
					TradeDate = tradeDate;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Allocation value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PostTrade.AllocationAndReadyToBook
	{
			/// <summary>
			/// <para>The allocation ACK message is used to acknowledge the receipt and status of an Allocation message received from the institution.</para>
			/// <para>It is possible that multiple Allocation ACK messages can be generated for a single allocation to detail the receipt and then the acceptance or rejection of the allocation.</para>
			/// </summary>
			public class AllocationACK
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Allocation message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// </summary>
				public System.String AllocID
				{
					get
					{
						return fieldSet.Get(Tags.AllocID);
					}
					set
					{
						fieldSet.Set(Tags.AllocID, value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// </summary>
				public System.DateTime TradeDate
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TradeDate, "LocalMktDate");
					}
					set
					{
						fieldSet.Set(Tags.TradeDate, "LocalMktDate", value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Date/Time AllocationACK generated</para>
				/// </summary>
				public System.DateTime? TransactTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TransactTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TransactTime); else fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Identifies status of allocation.</para>
				/// <para>Valid values:</para>
				/// <para>0 = accepted (successfully processed)</para>
				/// <para>1 = rejected</para>
				/// <para>2 = partial accept</para>
				/// <para>3 = received (received, not yet processed)</para>
				/// </summary>
				public AllocStatus AllocStatus
				{
					get
					{
						return fieldSet.GetAllocStatus(Tags.AllocStatus);
					}
					set
					{
						fieldSet.Set(Tags.AllocStatus, value);
					}
				}

				/// <summary>
				/// <para>Identifies reason for rejection.</para>
				/// <para>Valid values:</para>
				/// <para>0 = unknown account(s)</para>
				/// <para>1 = incorrect quantity</para>
				/// <para>2 = incorrect average price</para>
				/// <para>3 = unknown executing broker mnemonic</para>
				/// <para>4 = commission difference</para>
				/// <para>5 = unknown OrderID</para>
				/// <para>6 = unknown ListID</para>
				/// <para>7 = other</para>
				/// <para>Required for AllocStatus = 1 (rejected)</para>
				/// </summary>
				public AllocRejCode? AllocRejCode
				{
					get
					{
						AllocRejCode v;
						if (fieldSet.TryGetAllocRejCode(Tags.AllocRejCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AllocRejCode); else fieldSet.Set(Tags.AllocRejCode, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// <para>Can include explanation for AllocRejCode = 7 (other)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public AllocationACK(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public AllocationACK()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Allocation_ACK, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public AllocationACK(System.String allocID, System.DateTime tradeDate, AllocStatus allocStatus)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Allocation_ACK, new Dialect(ProtocolVersion.FIX42));
					AllocID = allocID;
					TradeDate = tradeDate;
					AllocStatus = allocStatus;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(AllocationACK value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.PostTrade.SettlementInstructions
	{
			/// <summary>
			/// <para>The Settlement Instructions message provides either the broker's or the institution's instructions for trade settlement. The SettlInstSource field indicates if the settlement instructions are the broker's or the institution's. This message has been designed so that it can be sent from the broker to the institution, from the institution to the broker, or from either to an independent "standing instructions" database or matching system.</para>
			/// <para>The Settlement Instructions message can be used in one of two modes (SettlInstMode):</para>
			/// <list type="number"><item>To provide "standing instructions" for the settlement of trades occurring in the future, messages should include some combination of.AllocAccountLastMktSideSecurityTypeSettlLocationSettlDeliveryTypeEffectiveTimeTo provide settlement instructions for a specific AllocationAccount either as overriding or standing instructions to support matching. The following key should be used to tie the settlement instructions to the corresponding Allocation message.(TradeDate + AllocID + AllocAccount)</item><item>To provide "standing instructions" for the settlement of trades occurring in the future, messages should include some combination of.AllocAccountLastMktSideSecurityTypeSettlLocationSettlDeliveryTypeEffectiveTimeTo provide settlement instructions for a specific AllocationAccount either as overriding or standing instructions to support matching. The following key should be used to tie the settlement instructions to the corresponding Allocation message.(TradeDate + AllocID + AllocAccount)</item></list><para>The Settlement Instruction detail can be either explicitly specified (via SecuritySettl* and CashSettl* fields) or can exist on within an independent standing instructions database and can be referenced via the StandInstDbType, StandInstDbName, and StandInstDbID fields.</para>
			/// <para>See Appendix F - Settlement Instructions Field Usage Matrix</para>
			/// </summary>
			public class SettlementInstructions
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Unique identifier for Settlement Instructions message.</para>
				/// <para>Unique message ID regardless of SettlInstMode</para>
				/// </summary>
				public System.String SettlInstID
				{
					get
					{
						return fieldSet.Get(Tags.SettlInstID);
					}
					set
					{
						fieldSet.Set(Tags.SettlInstID, value);
					}
				}

				/// <summary>
				/// <para>Settlement Instructions message transaction type</para>
				/// <para>Valid values:</para>
				/// <para>N = New</para>
				/// <para>C = Cancel</para>
				/// <para>R = Replace</para>
				/// <para>New, Replace, or Cancel</para>
				/// </summary>
				public SettlInstTransType SettlInstTransType
				{
					get
					{
						return fieldSet.GetSettlInstTransType(Tags.SettlInstTransType);
					}
					set
					{
						fieldSet.Set(Tags.SettlInstTransType, value);
					}
				}

				/// <summary>
				/// <para>Reference identifier for the SettlInstID with Cancel and Replace SettlInstTransType transaction types.</para>
				/// <para>Required for Cancel and Replace SettlInstTransType messages</para>
				/// </summary>
				public System.String SettlInstRefID
				{
					get
					{
						return fieldSet.Get(Tags.SettlInstRefID);
					}
					set
					{
						fieldSet.Set(Tags.SettlInstRefID, value);
					}
				}

				/// <summary>
				/// <para>Indicates mode used for Settlement Instructions</para>
				/// <para>Valid values:</para>
				/// <para>0 = Default</para>
				/// <para>1 = Standing Instructions Provided</para>
				/// <para>2 = Specific AllocationAccount Overriding</para>
				/// <para>3 = Specific AllocationAccount Standing</para>
				/// <para>1=Standing Instructions, 2=Specific AllocationAccount Overriding, 3=Specific AllocationAccount Standing</para>
				/// </summary>
				public SettlInstMode SettlInstMode
				{
					get
					{
						return fieldSet.GetSettlInstMode(Tags.SettlInstMode);
					}
					set
					{
						fieldSet.Set(Tags.SettlInstMode, value);
					}
				}

				/// <summary>
				/// <para>Indicates source of Settlement Instructions</para>
				/// <para>Valid values:</para>
				/// <para>1 = Broker's Instructions</para>
				/// <para>2 = Institution's Instructions</para>
				/// <para>1=Broker's Settlement Instructions, 2=Institution's Settlement Instructions</para>
				/// </summary>
				public SettlInstSource SettlInstSource
				{
					get
					{
						return fieldSet.GetSettlInstSource(Tags.SettlInstSource);
					}
					set
					{
						fieldSet.Set(Tags.SettlInstSource, value);
					}
				}

				/// <summary>
				/// <para>Sub-account mnemonic</para>
				/// <para>Required for SettlInstMode=1, 2, or 3</para>
				/// </summary>
				public System.String AllocAccount
				{
					get
					{
						return fieldSet.Get(Tags.AllocAccount);
					}
					set
					{
						fieldSet.Set(Tags.AllocAccount, value);
					}
				}

				/// <summary>
				/// <para>Identifies Settlement Depository or Country Code (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>CED = CEDEL</para>
				/// <para>DTC = Depository Trust Company</para>
				/// <para>EUR = Euroclear</para>
				/// <para>FED = Federal Book Entry</para>
				/// <para>PNY= Physical</para>
				/// <para>PTC = Participant Trust Company</para>
				/// <para>ISO Country Code = Local Market Settle Location</para>
				/// <para>Required for SettlInstMode=2 or 3, may be required for SettlInstMode=1 (i.e. may not be required if StandInstDbType and StandInstDbID are used)</para>
				/// </summary>
				public SettlLocation? SettlLocation
				{
					get
					{
						SettlLocation v;
						if (fieldSet.TryGetSettlLocation(Tags.SettlLocation, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlLocation); else fieldSet.Set(Tags.SettlLocation, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates date of trade referenced in this message in YYYYMMDD format. Absence of this field indicates current day (expressed in local time at place of trade).</para>
				/// <para>Required for SettlInstMode=2 or 3</para>
				/// </summary>
				public System.DateTime? TradeDate
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.TradeDate, "LocalMktDate", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradeDate); else fieldSet.Set(Tags.TradeDate, "LocalMktDate", value.Value);
					}
				}

				/// <summary>
				/// <para>Unique identifier for Allocation message.</para>
				/// <para>(Prior to FIX 4.1 this field was of type int)</para>
				/// <para>Required for SettlInstMode=2 or 3</para>
				/// </summary>
				public System.String AllocID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.AllocID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.AllocID); else fieldSet.Set(Tags.AllocID, value);
					}
				}

				/// <summary>
				/// <para>Market of execution for last fill</para>
				/// <para>Valid values:</para>
				/// <para>See Appendix C</para>
				/// <para>Required for SettlInstMode=2 or 3, May be required for SettlInstMode=1</para>
				/// </summary>
				public System.String LastMkt
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.LastMkt, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.LastMkt); else fieldSet.Set(Tags.LastMkt, value);
					}
				}

				/// <summary>
				/// <para>Identifier for Trading Session</para>
				/// <para>Can be used to represent a specific market trading session (e.g. 'PRE-OPEN", "CROSS_2", "AFTER-HOURS", "TOSTNET1", "TOSTNET2", etc).</para>
				/// <para>Values should be bi-laterally agreed to between counterparties.</para>
				/// </summary>
				public System.String TradingSessionID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TradingSessionID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TradingSessionID); else fieldSet.Set(Tags.TradingSessionID, value);
					}
				}

				/// <summary>
				/// <para>Side of order</para>
				/// <para>Valid values:</para>
				/// <para>1 = Buy</para>
				/// <para>2 = Sell</para>
				/// <para>3 = Buy minus</para>
				/// <para>4 = Sell plus</para>
				/// <para>5 = Sell short</para>
				/// <para>6 = Sell short exempt</para>
				/// <para>7 = Undisclosed (valid for IOI and List Order messages only)</para>
				/// <para>8 = Cross (orders where counterparty is an exchange, valid for all messages except IOIs)</para>
				/// <para>9 = Cross short</para>
				/// <para>Required for SettlInstMode=2 or 3, May be required for SettlInstMode=1</para>
				/// </summary>
				public Side? Side
				{
					get
					{
						Side v;
						if (fieldSet.TryGetSide(Tags.Side, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Side); else fieldSet.Set(Tags.Side, value.Value);
					}
				}

				/// <summary>
				/// <para>Indicates type of security (ISITC spec)</para>
				/// <para>Valid values:</para>
				/// <para>BA = Bankers Acceptance</para>
				/// <para>CB = Convertible Bond (Note not part of ISITC spec)</para>
				/// <para>CD = Certificate Of Deposit</para>
				/// <para>CMO = Collateralize Mortgage Obligation</para>
				/// <para>CORP = Corporate Bond</para>
				/// <para>CP = Commercial Paper</para>
				/// <para>CPP = Corporate Private Placement</para>
				/// <para>CS = Common Stock</para>
				/// <para>FHA = Federal Housing Authority</para>
				/// <para>FHL = Federal Home Loan</para>
				/// <para>FN = Federal National Mortgage Association</para>
				/// <para>FOR = Foreign Exchange Contract</para>
				/// <para>FUT = Future</para>
				/// <para>GN = Government National Mortgage Association</para>
				/// <para>GOVT = Treasuries + Agency Debenture</para>
				/// <para>IET Mortgage IOETTE</para>
				/// <para>MF = Mutual Fund</para>
				/// <para>MIO = Mortgage Interest Only</para>
				/// <para>MPO = Mortgage Principal Only</para>
				/// <para>MPP = Mortgage Private Placement</para>
				/// <para>MPT = Miscellaneous Pass-Thru</para>
				/// <para>MUNI = Municipal Bond</para>
				/// <para>NONE = No ISITC Security Type</para>
				/// <para>OPT = Option</para>
				/// <para>PS = Preferred Stock</para>
				/// <para>RP = Repurchase Agreement</para>
				/// <para>RVRP = Reverse Repurchase Agreement</para>
				/// <para>SL = Student Loan Marketing Association</para>
				/// <para>TD = Time Deposit</para>
				/// <para>USTB = US Treasury Bill</para>
				/// <para>WAR = Warrant</para>
				/// <para>ZOO = Cats, Tigers &amp; Lions (a real code: US Treasury Receipts)</para>
				/// <para>? = 'Wildcard' entry (used on Security Definition Request message)</para>
				/// <para>May be required for SettlInstMode=1</para>
				/// </summary>
				public SecurityType? SecurityType
				{
					get
					{
						SecurityType v;
						if (fieldSet.TryGetSecurityType(Tags.SecurityType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecurityType); else fieldSet.Set(Tags.SecurityType, value.Value);
					}
				}

				/// <summary>
				/// <para>Time the details within the message should take effect (always expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>May be required for SettlInstMode=1 (timestamp when it goes in to effect)</para>
				/// </summary>
				public System.DateTime? EffectiveTime
				{
					get
					{
						System.DateTime v;
						if (fieldSet.TryGetValue(Tags.EffectiveTime, "UTCTimestamp", out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EffectiveTime); else fieldSet.Set(Tags.EffectiveTime, "UTCTimestamp", value.Value);
					}
				}

				/// <summary>
				/// <para>Time of execution/order creation (expressed in UTC (Universal Time Coordinated, also known as 'GMT')</para>
				/// <para>Date/Time Settlement Instructions were generated</para>
				/// </summary>
				public System.DateTime TransactTime
				{
					get
					{
						return fieldSet.GetDateTime(Tags.TransactTime, "UTCTimestamp");
					}
					set
					{
						fieldSet.Set(Tags.TransactTime, "UTCTimestamp", value);
					}
				}

				/// <summary>
				/// <para>Firm identifier used in third party-transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ClientID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ClientID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ClientID); else fieldSet.Set(Tags.ClientID, value);
					}
				}

				/// <summary>
				/// <para>Identifies executing / give-up broker. Standard NASD market-maker mnemonic is preferred.</para>
				/// <para>Used for firm identification in third-party transactions (should not be a substitute for OnBehalfOfCompID/DeliverToCompID).</para>
				/// </summary>
				public System.String ExecBroker
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.ExecBroker, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ExecBroker); else fieldSet.Set(Tags.ExecBroker, value);
					}
				}

				/// <summary>
				/// <para>Identifies the Standing Instruction database used</para>
				/// <para>Valid values:</para>
				/// <para>0 = Other</para>
				/// <para>1 = DTC SID</para>
				/// <para>2 = Thomson ALERT</para>
				/// <para>3 = A Global Custodian (StandInstDbName must be provided)</para>
				/// <para>1=DTC SID, 2=Thomson ALERT, 3=Global Custodian's, etc.</para>
				/// </summary>
				public StandInstDbType? StandInstDbType
				{
					get
					{
						StandInstDbType v;
						if (fieldSet.TryGetStandInstDbType(Tags.StandInstDbType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StandInstDbType); else fieldSet.Set(Tags.StandInstDbType, value.Value);
					}
				}

				/// <summary>
				/// <para>Name of the Standing Instruction database represented with StandInstDbType (i.e. the Global Custodian's name).</para>
				/// <para>Name of StandInstDbType (i.e. DTC, Global Custodian's name)</para>
				/// </summary>
				public System.String StandInstDbName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.StandInstDbName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StandInstDbName); else fieldSet.Set(Tags.StandInstDbName, value);
					}
				}

				/// <summary>
				/// <para>Unique identifier used on the Standing Instructions database for the Standing Instructions to be referenced.</para>
				/// <para>Identifier used within the StandInstDbType</para>
				/// </summary>
				public System.String StandInstDbID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.StandInstDbID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.StandInstDbID); else fieldSet.Set(Tags.StandInstDbID, value);
					}
				}

				/// <summary>
				/// <para>Identifies type of settlement</para>
				/// <para>0 = 'Versus. Payment': Deliver (if Sell) or Receive (if Buy) vs. (Against) Payment</para>
				/// <para>1 = 'Free': Deliver (if Sell) or Receive (if Buy) Free</para>
				/// </summary>
				public System.String SettlDeliveryType
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlDeliveryType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlDeliveryType); else fieldSet.Set(Tags.SettlDeliveryType, value);
					}
				}

				/// <summary>
				/// <para>Broker's account code at the depository (i.e. CEDEL ID for CEDEL, FINS for DTC, or Euroclear ID for Euroclear) if SettlLocation is a depository</para>
				/// <para>Applicable when SettlLocation is a depository</para>
				/// </summary>
				public System.String SettlDepositoryCode
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlDepositoryCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlDepositoryCode); else fieldSet.Set(Tags.SettlDepositoryCode, value);
					}
				}

				/// <summary>
				/// <para>BIC (Bank Identification Code-Swift managed) code of the broker involved (i.e. for multi-company brokerage firms)</para>
				/// </summary>
				public System.String SettlBrkrCode
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlBrkrCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlBrkrCode); else fieldSet.Set(Tags.SettlBrkrCode, value);
					}
				}

				/// <summary>
				/// <para>BIC (Bank Identification Code-Swift managed) code of the institution involved (i.e. for multi-company institution firms)</para>
				/// </summary>
				public System.String SettlInstCode
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SettlInstCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SettlInstCode); else fieldSet.Set(Tags.SettlInstCode, value);
					}
				}

				/// <summary>
				/// <para>Name of SettlInstSource's local agent bank if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentName); else fieldSet.Set(Tags.SecuritySettlAgentName, value);
					}
				}

				/// <summary>
				/// <para>BIC (Bank Identification Code-Swift managed) code of the SettlInstSource's local agent bank if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentCode
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentCode); else fieldSet.Set(Tags.SecuritySettlAgentCode, value);
					}
				}

				/// <summary>
				/// <para>SettlInstSource's account number at local agent bank if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentAcctNum
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentAcctNum, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentAcctNum); else fieldSet.Set(Tags.SecuritySettlAgentAcctNum, value);
					}
				}

				/// <summary>
				/// <para>Name of SettlInstSource's account at local agent bank if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentAcctName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentAcctName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentAcctName); else fieldSet.Set(Tags.SecuritySettlAgentAcctName, value);
					}
				}

				/// <summary>
				/// <para>Name of contact at local agent bank for SettlInstSource's account if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentContactName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentContactName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentContactName); else fieldSet.Set(Tags.SecuritySettlAgentContactName, value);
					}
				}

				/// <summary>
				/// <para>Phone number for contact at local agent bank if SettlLocation is not a depository</para>
				/// <para>Applicable when settlement is being performed at a country vs. a depository</para>
				/// </summary>
				public System.String SecuritySettlAgentContactPhone
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.SecuritySettlAgentContactPhone, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SecuritySettlAgentContactPhone); else fieldSet.Set(Tags.SecuritySettlAgentContactPhone, value);
					}
				}

				/// <summary>
				/// <para>Name of SettlInstSource's local agent bank if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentName); else fieldSet.Set(Tags.CashSettlAgentName, value);
					}
				}

				/// <summary>
				/// <para>BIC (Bank Identification Code-Swift managed) code of the SettlInstSource's local agent bank if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentCode
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentCode, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentCode); else fieldSet.Set(Tags.CashSettlAgentCode, value);
					}
				}

				/// <summary>
				/// <para>SettlInstSource's account number at local agent bank if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentAcctNum
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentAcctNum, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentAcctNum); else fieldSet.Set(Tags.CashSettlAgentAcctNum, value);
					}
				}

				/// <summary>
				/// <para>Name of SettlInstSource's account at local agent bank if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentAcctName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentAcctName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentAcctName); else fieldSet.Set(Tags.CashSettlAgentAcctName, value);
					}
				}

				/// <summary>
				/// <para>Name of contact at local agent bank for SettlInstSource's account if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentContactName
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentContactName, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentContactName); else fieldSet.Set(Tags.CashSettlAgentContactName, value);
					}
				}

				/// <summary>
				/// <para>Phone number for contact at local agent bank for SettlInstSource's account if SettlDeliveryType=Free</para>
				/// <para>Applicable when SettlDeliveryType=Free</para>
				/// </summary>
				public System.String CashSettlAgentContactPhone
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.CashSettlAgentContactPhone, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.CashSettlAgentContactPhone); else fieldSet.Set(Tags.CashSettlAgentContactPhone, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SettlementInstructions(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SettlementInstructions()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Settlement_Instructions, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SettlementInstructions(System.String settlInstID, SettlInstTransType settlInstTransType, System.String settlInstRefID, SettlInstMode settlInstMode, SettlInstSource settlInstSource, System.String allocAccount, System.DateTime transactTime)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Settlement_Instructions, new Dialect(ProtocolVersion.FIX42));
					SettlInstID = settlInstID;
					SettlInstTransType = settlInstTransType;
					SettlInstRefID = settlInstRefID;
					SettlInstMode = settlInstMode;
					SettlInstSource = settlInstSource;
					AllocAccount = allocAccount;
					TransactTime = transactTime;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SettlementInstructions value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Application.Other.CommonApplicationMessages
	{
			/// <summary>
			/// <para>The Business Message Reject message can reject an application-level message which fulfills session-level rules and cannot be rejected via any other means. Note if the message fails a session-level rule (e.g. body length is incorrect), a session-level Reject message should be issued.</para>
			/// <para>See the session-level Reject message</para>
			/// <para>It should *NOT* be used in the following situations:</para>
			/// <list type="table"><item><term>Session-level problem meeting the criteria of the session-level Reject message</term><description>Use the session-level Reject message (MsgType=3)</description></item><item><term>In response toNew Order - SingleOrder Status RequestNew Order - ListList Execute</term><description>Use the Execution Report message</description></item><item><term>In response to:Order Cancel RequestOrder Cancel/Replace RequestList Cancel Request</term><description>Use the Order Cancel Reject message</description></item><item><term>In response to:Execution Report</term><description>Use the Don't Know Trade (DK) message</description></item><item><term>In response to:Allocation</term><description>Use the Allocation ACK message</description></item><item><term>In response to:List Status Request</term><description>Use the List Status message</description></item><item><term>In response to:Quote RequestQuoteMass QuoteQuote CancelQuote Status Request</term><description>Use the Quote Acknowledgment message</description></item><item><term>In response to:Market Data Request</term><description>Use the Market Data Request Reject message</description></item><item><term>In response to:Security Definition Request</term><description>Use the Security Definition message</description></item><item><term>In response to:Security Status Request</term><description>Use the Security Status message</description></item><item><term>In response to:Trading Session Status Request</term><description>Use the Trading Session Status message</description></item></list><para>Note the only exception to this rule is in the event a business message is received, fulfills session-level rules, however, the message cannot be communicated to the business-level processing system. In this situation a Business Message Reject with BusinessRejectReason = "Application not available at this time" can be issued if the the system is unable to send the specific "reject" message listed above due to this condition.</para>
			/// <para>Messages which can be referenced via the Business Message Reject message are (the "ID" field BusinessRejectRefID refers to noted in [ ]):</para>
			/// <list type="bullet"><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item><item>Indication of Interest (IOI) [IOIid]Advertisement [AdvId]News [Headline]Email [EmailThreadID]Order Cancel Reject [ClOrdID]Allocation ACK [AllocID]List Status [ListID]Don't Know Trade (DK) - may respond with Order Cancel Reject if attempting to cancel order [ExecID]Settlement Instructions [SettlInstID]Market Data-Snapshot/Full Refresh [MDReqID]Market Data-Incremental Refresh [MDReqID]Market Data Request Reject [MDReqID]Quote Acknowledgment [QuoteID]Security Definition [SecurityResponseID]Security Status [SecurityStatusReqID]Trading Session Status [TradSesReqID]</item></list><para>Scenarios for Business Message Reject:</para>
			/// <list type="table"><item><term></term><description>BusinessRejectReason</description></item><item><term>0</term><description>Other</description></item><item><term>1</term><description>Unkown ID</description></item><item><term>2</term><description>Unknown Security</description></item><item><term>3</term><description>Unsupported Message Type (receive a valid, but unsupported MsgType)</description></item><item><term>4</term><description>Application not available</description></item><item><term>5</term><description>Conditionally Required Field Missing</description></item></list><para>Whenever possible, it is strongly recommended that the cause of the failure be described in the Text field (e.g. "UNKNOWN SYBMOL: XYZ").</para>
			/// </summary>
			public class BusinessMessageReject
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Reference message sequence number</para>
				/// <para>MsgSeqNum of rejected message</para>
				/// </summary>
				public System.String RefSeqNum
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RefSeqNum, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RefSeqNum); else fieldSet.Set(Tags.RefSeqNum, value);
					}
				}

				/// <summary>
				/// <para>The MsgType of the FIX message being referenced.</para>
				/// <para>The MsgType of the FIX message being referenced.</para>
				/// </summary>
				public System.String RefMsgType
				{
					get
					{
						return fieldSet.Get(Tags.RefMsgType);
					}
					set
					{
						fieldSet.Set(Tags.RefMsgType, value);
					}
				}

				/// <summary>
				/// <para>The value of the business-level 'ID' field on the message being referenced.</para>
				/// <para>The value of the business-level 'ID' field on the message being referenced. Required unless the corresponding ID field (see list above) was not specified.</para>
				/// </summary>
				public System.String BusinessRejectRefID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.BusinessRejectRefID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.BusinessRejectRefID); else fieldSet.Set(Tags.BusinessRejectRefID, value);
					}
				}

				/// <summary>
				/// <para>Code to identify reason for a Business Message Reject message.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Other</para>
				/// <para>1 = Unkown ID</para>
				/// <para>2 = Unknown Security</para>
				/// <para>3 = Unsupported Message Type</para>
				/// <para>4 = Application not available</para>
				/// <para>5 = Conditionally Required Field Missing</para>
				/// <para>Code to identify reason for a Business Message Reject message.</para>
				/// </summary>
				public BusinessRejectReason BusinessRejectReason
				{
					get
					{
						return fieldSet.GetBusinessRejectReason(Tags.BusinessRejectReason);
					}
					set
					{
						fieldSet.Set(Tags.BusinessRejectReason, value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// <para>Where possible, message to explain reason for rejection</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BusinessMessageReject(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BusinessMessageReject()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Business_Message_Reject, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public BusinessMessageReject(System.String refMsgType, BusinessRejectReason businessRejectReason)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Business_Message_Reject, new Dialect(ProtocolVersion.FIX42));
					RefMsgType = refMsgType;
					BusinessRejectReason = businessRejectReason;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(BusinessMessageReject value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Heartbeat monitors the status of the communication link and identifies when the last of a string of messages was not received.</para>
			/// <para>When either end of a FIX connection has not sent any data for [HeartBtInt] seconds, it will transmit a Heartbeat message. When either end of the connection has not received any data for (HeartBtInt + "some reasonable transmission time") seconds, it will transmit a Test Request message. If there is still no Heartbeat message received after (HeartBtInt + "some reasonable transmission time") seconds then the connection should be considered lost and corrective action be initiated. If HeartBtInt is set to zero then no regular Heartbeat messages will be generated. Note that a Test Request message can still be sent independent of the value of the HeartBtInt, which will force a Heartbeat message.</para>
			/// <para>Heartbeats issued as the result of Test Request must contain the TestReqID transmitted in the Test Request message. This is useful to verify that the Heartbeat is the result of the Test Request and not as the result of a regular timeout.</para>
			/// </summary>
			public class Heartbeat
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Identifier included in Test Request message to be returned in resulting Heartbeat</para>
				/// <para>Required when the heartbeat is the result of a Test Request message.</para>
				/// </summary>
				public System.String TestReqID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.TestReqID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.TestReqID); else fieldSet.Set(Tags.TestReqID, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Heartbeat(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Heartbeat()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Heartbeat, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Heartbeat value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Test Request message forces a heartbeat from the opposing application. The Test Request message checks sequence numbers or verifies communication line status. The opposite application responds to the Test Request with a Heartbeat containing the TestReqID.</para>
			/// <para>The TestReqID verifies that the opposite application is generating the heartbeat as the result of Test Request and not a normal timeout. The opposite application includes the TestReqID in the resulting Heartbeat. Any string can be used as the TestReqID (one suggestion is to use a timestamp string).</para>
			/// </summary>
			public class TestRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Identifier included in Test Request message to be returned in resulting Heartbeat</para>
				/// </summary>
				public System.String TestReqID
				{
					get
					{
						return fieldSet.Get(Tags.TestReqID);
					}
					set
					{
						fieldSet.Set(Tags.TestReqID, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TestRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TestRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Test_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public TestRequest(System.String testReqID)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Test_Request, new Dialect(ProtocolVersion.FIX42));
					TestReqID = testReqID;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(TestRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The resend request is sent by the receiving application to initiate the retransmission of messages. This function is utilized if a sequence number gap is detected, if the receiving application lost a message, or as a function of the initialization process.</para>
			/// <para>The resend request can be used to request a single message, a range of messages or all messages subsequent to a particular message.</para>
			/// <para>Note: the sending application may wish to consider the message type when resending messages; e.g. if a new order is in the resend series and a significant time period has elapsed since its original inception, the sender may not wish to retransmit the order given the potential for changed market conditions. (The Sequence Reset-GapFill message is used to skip messages that a sender does not wish to resend.)</para>
			/// <para>Note: it is imperative that the receiving application process messages in sequence order, e.g. if message number 7 is missed and 8-9 received, the application should ignore 8 and 9 and ask for a resend of 7-9, or, preferably, 7-0 (0 represents infinity). This latter approach is strongly recommended to recover from out of sequence conditions as it allows for faster recovery in the presence of certain race conditions when both sides are simultaneously attempting to recover a gap.</para>
			/// <list type="bullet"><item>To request a single message: BeginSeqNo = EndSeqNoTo request a range of messages: BeginSeqNo = first message of range, EndSeqNo = last message of rangeTo request all messages subsequent to a particular message: BeginSeqNo = first message of range, EndSeqNo = 0 (represents infinity) .</item><item>To request a single message: BeginSeqNo = EndSeqNoTo request a range of messages: BeginSeqNo = first message of range, EndSeqNo = last message of rangeTo request all messages subsequent to a particular message: BeginSeqNo = first message of range, EndSeqNo = 0 (represents infinity) .</item><item>To request a single message: BeginSeqNo = EndSeqNoTo request a range of messages: BeginSeqNo = first message of range, EndSeqNo = last message of rangeTo request all messages subsequent to a particular message: BeginSeqNo = first message of range, EndSeqNo = 0 (represents infinity) .</item></list>
			/// </summary>
			public class ResendRequest
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Message sequence number of first message in range to be resent</para>
				/// </summary>
				public System.String BeginSeqNo
				{
					get
					{
						return fieldSet.Get(Tags.BeginSeqNo);
					}
					set
					{
						fieldSet.Set(Tags.BeginSeqNo, value);
					}
				}

				/// <summary>
				/// <para>Message sequence number of last message in range to be resent. If request is for a single message BeginSeqNo = EndSeqNo. If request is for all messages subsequent to a particular message, EndSeqNo = '0' (representing infinity).</para>
				/// </summary>
				public System.String EndSeqNo
				{
					get
					{
						return fieldSet.Get(Tags.EndSeqNo);
					}
					set
					{
						fieldSet.Set(Tags.EndSeqNo, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ResendRequest(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ResendRequest()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Resend_Request, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public ResendRequest(System.String beginSeqNo, System.String endSeqNo)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Resend_Request, new Dialect(ProtocolVersion.FIX42));
					BeginSeqNo = beginSeqNo;
					EndSeqNo = endSeqNo;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(ResendRequest value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Reject message should be issued when a message is received but cannot be properly processed due to a session-level rule violation. An example of when a reject may be appropriate would be the receipt of a message with invalid basic data (e.g. MsgType=&amp;) which successfully passes de-encryption, CheckSum and BodyLength checks. As a rule, messages should be forwarded to the trading application for business level rejections whenever possible.</para>
			/// <para>Rejected messages should be logged and the incoming sequence number incremented.</para>
			/// <para>Note: The receiving application should disregard any message that is garbled, cannot be parsed or fails a data integrity check. Processing of the next valid FIX message will cause detection of a sequence gap and a Resend Request will be generated. Logic should be included in the FIX engine to recognize the possible infinite resend loop, which may be encountered in this situation.</para>
			/// <para>Generation and receipt of a Reject message indicates a serious error that may be the result of faulty logic in either the sending or receiving application.</para>
			/// <para>If the sending application chooses to retransmit the rejected message, it should be assigned a new sequence number and sent with PossResend=Y.</para>
			/// <para>Whenever possible, it is strongly recommended that the cause of the failure be described in the Text field (e.g. INVALID DATA - FIELD 35).</para>
			/// <para>If an application-level message received fulfills session-level rules, it should then be processed at a business message-level. If this processing detects a rule violation, a business-level reject should be issued. Many business-level messages have specific "reject" messages, which should be used. All others can be rejected at a business-level via the Business Message Reject message. See the Business Message Reject message</para>
			/// <para>Note that in the event a business message is received, fulfills session-level rules, however, the message cannot be communicated to the business-level processing system, a Business Message Reject with BusinessRejectReason = "Application not available at this time" should be issued.</para>
			/// <para>Scenarios for session-level Reject:</para>
			/// <list type="table"><item><term></term><description>SessionRejectReason</description></item><item><term>0</term><description>Invalid tag number</description></item><item><term>1</term><description>Required tag missing</description></item><item><term>2</term><description>Tag not defined for this message type</description></item><item><term>3</term><description>Undefined Tag</description></item><item><term>4</term><description>Tag specified without a value</description></item><item><term>5</term><description>Value is incorrect (out of range) for this tag</description></item><item><term>6</term><description>Incorrect data format for value</description></item><item><term>7</term><description>Decryption problem</description></item><item><term>8</term><description>Signature problem</description></item><item><term>9</term><description>CompID problem</description></item><item><term>10</term><description>SendingTime accuracy problem</description></item><item><term>11</term><description>Invalid MsgType</description></item></list><para>(Note other session-level rule violations may exist in which case SessionRejectReason is not specified)</para>
			/// </summary>
			public class Reject
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Reference message sequence number</para>
				/// <para>MsgSeqNum of rejected message</para>
				/// </summary>
				public System.String RefSeqNum
				{
					get
					{
						return fieldSet.Get(Tags.RefSeqNum);
					}
					set
					{
						fieldSet.Set(Tags.RefSeqNum, value);
					}
				}

				/// <summary>
				/// <para>The tag number of the FIX field being referenced.</para>
				/// <para>The tag number of the FIX field being referenced.</para>
				/// </summary>
				public System.String RefTagID
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RefTagID, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RefTagID); else fieldSet.Set(Tags.RefTagID, value);
					}
				}

				/// <summary>
				/// <para>The MsgType of the FIX message being referenced.</para>
				/// <para>The MsgType of the FIX message being referenced.</para>
				/// </summary>
				public System.String RefMsgType
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RefMsgType, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RefMsgType); else fieldSet.Set(Tags.RefMsgType, value);
					}
				}

				/// <summary>
				/// <para>Code to identify reason for a session-level Reject message.</para>
				/// <para>Valid values:</para>
				/// <para>0 = Invalid tag number</para>
				/// <para>1 = Required tag missing</para>
				/// <para>2 = Tag not defined for this message type</para>
				/// <para>3 = Undefined Tag</para>
				/// <para>4 = Tag specified without a value</para>
				/// <para>5 = Value is incorrect (out of range) for this tag</para>
				/// <para>6 = Incorrect data format for value</para>
				/// <para>7 = Decryption problem</para>
				/// <para>8 = Signature problem</para>
				/// <para>9 = CompID problem</para>
				/// <para>10 = SendingTime accuracy problem</para>
				/// <para>11 = Invalid MsgType</para>
				/// <para>Code to identify reason for a session-level Reject message.</para>
				/// </summary>
				public SessionRejectReason? SessionRejectReason
				{
					get
					{
						SessionRejectReason v;
						if (fieldSet.TryGetSessionRejectReason(Tags.SessionRejectReason, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.SessionRejectReason); else fieldSet.Set(Tags.SessionRejectReason, value.Value);
					}
				}

				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// <para>Where possible, message to explain reason for rejection</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Reject(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Reject()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Reject, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Reject(System.String refSeqNum)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Reject, new Dialect(ProtocolVersion.FIX42));
					RefSeqNum = refSeqNum;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Reject value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Sequence Reset message is used by the sending application to reset the incoming sequence number on the opposing side. This message has two modes: "Sequence Reset-Gap Fill" when GapFillFlag is 'Y' and "Sequence Reset-Reset" when GapFillFlag is N or not present. The "Sequence Reset-Reset" mode should ONLY be used to recover from a disaster situation which cannot be otherwise recovered via "Gap Fill" mode. The Sequence Reset message can be used in the following situations:</para>
			/// <list type="bullet"><item>During normal resend processing, the sending application may choose not to send a message (e.g. an aged order). The Sequence Reset - Gap Fill is used to mark the place of that message.During normal resend processing, a number of administrative messages are not resent, the Sequence Reset - Gap Fill message is used to fill the sequence gap created.In the event of an application failure, it may be necessary to force synchronization of sequence numbers on the sending and receiving sides via the use of Sequence Reset - Reset</item><item>During normal resend processing, the sending application may choose not to send a message (e.g. an aged order). The Sequence Reset - Gap Fill is used to mark the place of that message.During normal resend processing, a number of administrative messages are not resent, the Sequence Reset - Gap Fill message is used to fill the sequence gap created.In the event of an application failure, it may be necessary to force synchronization of sequence numbers on the sending and receiving sides via the use of Sequence Reset - Reset</item><item>During normal resend processing, the sending application may choose not to send a message (e.g. an aged order). The Sequence Reset - Gap Fill is used to mark the place of that message.During normal resend processing, a number of administrative messages are not resent, the Sequence Reset - Gap Fill message is used to fill the sequence gap created.In the event of an application failure, it may be necessary to force synchronization of sequence numbers on the sending and receiving sides via the use of Sequence Reset - Reset</item></list><para>The sending application will initiate the sequence reset. The message in all situations specifies NewSeqNo to reset as thevalue of the next sequence numberimmediately following the messages and/or sequence numbers being skipped.</para>
			/// <para>If the GapFillFlag field is not present (or set to N), it can be assumed that the purpose of the Sequence Reset message is to recover from an out-of-sequence condition. The MsgSeqNum in the header should be ignored (i.e. the receipt of a Sequence Reset - Reset message with an out of sequence MsgSeqNum should not generate resend requests). Sequence Reset - Reset should NOT be used as a normal response to a Resend Request (use Sequence Reset - Gap Fill). The Sequence Reset - Reset should ONLY be used to recover from a disaster situation which cannot be recovered via the use of Sequence Reset - Gap Fill. Note that the use of Sequence Reset - Reset may result in the possibility of lost messages</para>
			/// <para>If the GapFillFlag field is present (and equal to Y), the MsgSeqNum should conform to standard message sequencing rules (i.e. the MsgSeqNum of the Sequence Reset-GapFill message should represent the beginning MsgSeqNum in the GapFill range because the remote side is expecting that next message).</para>
			/// <para>The sequence reset can only increase the sequence number. If a sequence reset is received attempting to decrease the next expected sequence number the message should be rejected and treated as a serious error. It is possible to have multiple ResendRequests issued in a row (i.e. 5 to 10 followed by 5 to 11). If sequence number 8, 10, and 11 represent application messages while the 5-7 and 9 represent administrative messages, the series of messages as result of the Resend Request may appear as SeqReset-GapFill with NewSeqNo of 8, message 8, SeqReset-GapFill with NewSeqNo of 10, and message 10. This could then followed by SeqReset-GapFill with NewSeqNo of 8, message 8, SeqReset-GapFill with NewSeqNo of 10, message 10, and message 11. One must be careful to ignore the duplicate SeqReset-GapFill which is attempting to lower the next expected sequence number. This can be detected by checking to see if its MsgSeqNum is less than expected. If so, the SeqReset-GapFill is a duplicate and should be discarded.</para>
			/// </summary>
			public class SequenceReset
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Indicates that the Sequence Reset message is replacing administrative or application messages which will not be resent.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Gap Fill message, MsgSeqNum field valid</para>
				/// <para>N = Sequence Reset, ignore MsgSeqNum</para>
				/// </summary>
				public GapFillFlag? GapFillFlag
				{
					get
					{
						GapFillFlag v;
						if (fieldSet.TryGetGapFillFlag(Tags.GapFillFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.GapFillFlag); else fieldSet.Set(Tags.GapFillFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>New sequence number</para>
				/// </summary>
				public System.String NewSeqNo
				{
					get
					{
						return fieldSet.Get(Tags.NewSeqNo);
					}
					set
					{
						fieldSet.Set(Tags.NewSeqNo, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SequenceReset(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SequenceReset()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Sequence_Reset, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public SequenceReset(System.String newSeqNo)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Sequence_Reset, new Dialect(ProtocolVersion.FIX42));
					NewSeqNo = newSeqNo;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(SequenceReset value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Logout message initiates or confirms the termination of a FIX session. Disconnection without the exchange of Logout messages should be interpreted as an abnormal condition.</para>
			/// <para>Before actually closing the session, the logout initiator should wait for the opposite side to respond with a confirming Logout message. This gives the remote end a chance to perform any Gap Fill operations that may be necessary. The session may be terminated if the remote side does not respond in an appropriate timeframe.</para>
			/// <para>After sending the Logout message, the logout initiator should not send any messages unless requested to do so by the logout acceptor via a ResendRequest.</para>
			/// </summary>
			public class Logout
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Free format text string</para>
				/// <para>(Note: this field does not have a specified maximum length)</para>
				/// </summary>
				public System.String Text
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.Text, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.Text); else fieldSet.Set(Tags.Text, value);
					}
				}

				/// <summary>
				/// <para>Byte length of encoded (non-ASCII characters) EncodedText field.</para>
				/// <para>Must be set if EncodedText field is specified and must immediately precede it.</para>
				/// </summary>
				public System.Int32? EncodedTextLen
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.EncodedTextLen, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedTextLen); else fieldSet.Set(Tags.EncodedTextLen, value.Value);
					}
				}

				/// <summary>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field. If used, the ASCII (English) representation should also be specified in the Text field.</para>
				/// <para>Encoded (non-ASCII characters) representation of the Text field in the encoded format specified via the MessageEncoding field.</para>
				/// </summary>
				public System.String EncodedText
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.EncodedText, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.EncodedText); else fieldSet.Set(Tags.EncodedText, value);
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Logout(Message message)
				{
					this.fieldSet = message;
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Logout()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Logout, new Dialect(ProtocolVersion.FIX42));
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Logout value)
				{
					return value.fieldSet;
				}

			}

		}
	namespace Session
	{
			/// <summary>
			/// <para>The Logon message authenticates a user establishing a connection to a remote system. The Logon message must be the first message sent by the application requesting to initiate a FIX session.</para>
			/// <para>The HeartBtInt (108) field is used to declare the timeout interval for generating heartbeats (same value used by both sides). The HeartBtInt value should be agreed upon by the two firms and specified by the Logon initiator and echoed back by the Logon acceptor.</para>
			/// <para>Upon receipt of a Logon message, the session acceptor will authenticate the party requesting connection and issue a Logon message as acknowledgment that the connection request has been accepted. The acknowledgment Logon can also be used by the initiator to validate that the connection was established with the correct party.</para>
			/// <para>The session acceptor must be prepared to immediately begin processing messages after receipt of the Logon. The session initiator can choose to begin transmission of FIX messages before receipt of the confirmation Logon, however it is recommended that normal message delivery wait until after the return Logon is received to accommodate encryption key negotiation.</para>
			/// <para>The confirmation Logon can be used for encryption key negotiation. If a session key is deemed to be weak, a stronger session key can be suggested by returning a Logon message with a new key. This is only valid for encryption protocols that allow for key negotiation. (See the FIX Web Site's Application notes for more information on a method for encryption and key passing.)</para>
			/// <para>The Logon message can be used to specify the MaxMessageSize supported (e.g. can be used to control fragmentation rules for very large messages which support fragmentation). It can also be used to specify the MsgTypes supported for both sending and receiving.</para>
			/// </summary>
			public class Logon
			{
				private Message fieldSet;
				/// <summary>
				/// <para>Method of encryption.</para>
				/// <para>Valid values:</para>
				/// <para>0 = None / other</para>
				/// <para>1 = PKCS (proprietary)</para>
				/// <para>2 = DES (ECB mode)</para>
				/// <para>3 = PKCS/DES (proprietary)</para>
				/// <para>4 = PGP/DES (defunct)</para>
				/// <para>5 = PGP/DES-MD5 (see app note on FIX web site)</para>
				/// <para>6 = PEM/DES-MD5 (see app note on FIX web site)</para>
				/// <para>(Always unencrypted)</para>
				/// </summary>
				public EncryptMethod EncryptMethod
				{
					get
					{
						return fieldSet.GetEncryptMethod(Tags.EncryptMethod);
					}
					set
					{
						fieldSet.Set(Tags.EncryptMethod, value);
					}
				}

				/// <summary>
				/// <para>Heartbeat interval (seconds)</para>
				/// <para>Note same value used by both sides</para>
				/// </summary>
				public System.String HeartBtInt
				{
					get
					{
						return fieldSet.Get(Tags.HeartBtInt);
					}
					set
					{
						fieldSet.Set(Tags.HeartBtInt, value);
					}
				}

				/// <summary>
				/// <para>Number of bytes in raw data field.</para>
				/// <para>Required for some authentication methods</para>
				/// </summary>
				public System.Int32? RawDataLength
				{
					get
					{
						System.Int32 v;
						if (fieldSet.TryGetValue(Tags.RawDataLength, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawDataLength); else fieldSet.Set(Tags.RawDataLength, value.Value);
					}
				}

				/// <summary>
				/// <para>Unformatted raw data, can include bitmaps, word processor documents, etc.</para>
				/// <para>Required for some authentication methods</para>
				/// </summary>
				public System.String RawData
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.RawData, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.RawData); else fieldSet.Set(Tags.RawData, value);
					}
				}

				/// <summary>
				/// <para>Indicates that the both sides of the FIX session should reset sequence numbers.</para>
				/// <para>Valid values:</para>
				/// <para>Y = Yes, reset sequence numbers</para>
				/// <para>N = No</para>
				/// <para>Indicates both sides of a FIX session should reset sequence numbers</para>
				/// </summary>
				public ResetSeqNumFlag? ResetSeqNumFlag
				{
					get
					{
						ResetSeqNumFlag v;
						if (fieldSet.TryGetResetSeqNumFlag(Tags.ResetSeqNumFlag, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.ResetSeqNumFlag); else fieldSet.Set(Tags.ResetSeqNumFlag, value.Value);
					}
				}

				/// <summary>
				/// <para>Maximum number of bytes supported for a single message.</para>
				/// <para>Can be used to specify the maximum number of bytes supported for messages received</para>
				/// </summary>
				public System.String MaxMessageSize
				{
					get
					{
						System.String v;
						if (fieldSet.TryGetValue(Tags.MaxMessageSize, out v)) return v;
						return null;
					}
					set
					{
						if (value == null) fieldSet.Remove(Tags.MaxMessageSize); else fieldSet.Set(Tags.MaxMessageSize, value);
					}
				}

				private LogonNoMsgTypesCollection noMsgTypes;
				/// <summary>
				/// <para>Number of MsgTypes in repeating group.</para>
				/// <para>Specifies the number of repeating MsgTypes specified</para>
				/// </summary>
				public LogonNoMsgTypesCollection NoMsgTypes
				{
					get
					{
						return noMsgTypes;
					}
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Logon(Message message)
				{
					this.fieldSet = message;
					this.noMsgTypes = new LogonNoMsgTypesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMsgTypes));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Logon()
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Logon, new Dialect(ProtocolVersion.FIX42));
					this.noMsgTypes = new LogonNoMsgTypesCollection(fieldSet, fieldSet.GetGroup(Tags.NoMsgTypes));
				}

				/// <summary>
				/// Constructor
				/// </summary>
				public Logon(EncryptMethod encryptMethod, System.String heartBtInt)
				{
					fieldSet = new Message(FIXForge.NET.FIX.FIX42.MsgType.Logon, new Dialect(ProtocolVersion.FIX42));
					EncryptMethod = encryptMethod;
					HeartBtInt = heartBtInt;
				}

				/// <summary>
				/// Returns underlying message
				/// </summary>
				public static implicit operator Message(Logon value)
				{
					return value.fieldSet;
				}

			}

		}
		/// <summary>
		/// Listener for typed messages
		/// </summary>
		public class TypedMessageListener
		{
			/// <summary>
			/// Constructor
			/// </summary>
			public TypedMessageListener(FIXForge.NET.FIX.Session session, bool processSessionLevel)
			{
				session.InboundApplicationMsgEvent += new InboundApplicationMsgEventHandler(SessionInboundApplicationMsgEvent);
				if (processSessionLevel) session.InboundSessionMsgEvent += new InboundSessionMsgEventHandler(SessionInboundSessionMsgEvent);
			}

			/// <summary>
			/// Constructor
			/// </summary>
			public TypedMessageListener(FIXForge.NET.FIX.Session session)
				: this(session, false)
			{
				 
			}

			/// <summary>
			/// InboundApplicationMsgEventHandler
			/// </summary>
			public void SessionInboundApplicationMsgEvent(object sender, InboundApplicationMsgEventArgs args)
			{
				ProcessMessage(args.Msg);
			}

			/// <summary>
			/// InboundSessionMsgEventHandler
			/// </summary>
			public void SessionInboundSessionMsgEvent(object sender, InboundSessionMsgEventArgs args)
			{
				ProcessMessage(args.Msg);
			}

			/// <summary>
			/// IndicationOfInterest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Indication.IndicationOfInterest> IndicationOfInterestReceived;
			/// <summary>
			/// Advertisement message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Indication.Advertisement> AdvertisementReceived;
			/// <summary>
			/// News message receiving event
			/// </summary>
			public event Action<Application.PreTrade.EventCommunication.News> NewsReceived;
			/// <summary>
			/// Email message receiving event
			/// </summary>
			public event Action<Application.PreTrade.EventCommunication.Email> EmailReceived;
			/// <summary>
			/// QuoteRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.QuoteRequest> QuoteRequestReceived;
			/// <summary>
			/// Quote message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.Quote> QuoteReceived;
			/// <summary>
			/// QuoteCancel message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.QuoteCancel> QuoteCancelReceived;
			/// <summary>
			/// QuoteStatusRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.QuoteStatusRequest> QuoteStatusRequestReceived;
			/// <summary>
			/// QuoteAcknowledgement message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.QuoteAcknowledgement> QuoteAcknowledgementReceived;
			/// <summary>
			/// MassQuote message receiving event
			/// </summary>
			public event Action<Application.PreTrade.Quotation.MassQuote> MassQuoteReceived;
			/// <summary>
			/// MarketDataRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.MarketData.MarketDataRequest> MarketDataRequestReceived;
			/// <summary>
			/// MarketDataSnapshotFullRefresh message receiving event
			/// </summary>
			public event Action<Application.PreTrade.MarketData.MarketDataSnapshotFullRefresh> MarketDataSnapshotFullRefreshReceived;
			/// <summary>
			/// MarketDataIncrementalRefresh message receiving event
			/// </summary>
			public event Action<Application.PreTrade.MarketData.MarketDataIncrementalRefresh> MarketDataIncrementalRefreshReceived;
			/// <summary>
			/// MarketDataRequestReject message receiving event
			/// </summary>
			public event Action<Application.PreTrade.MarketData.MarketDataRequestReject> MarketDataRequestRejectReceived;
			/// <summary>
			/// SecurityDefinitionRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityDefinitionRequest> SecurityDefinitionRequestReceived;
			/// <summary>
			/// SecurityDefinition message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityDefinition> SecurityDefinitionReceived;
			/// <summary>
			/// SecurityStatusRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityStatusRequest> SecurityStatusRequestReceived;
			/// <summary>
			/// SecurityStatus message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityStatus> SecurityStatusReceived;
			/// <summary>
			/// TradingSessionStatusRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.TradingSessionStatusRequest> TradingSessionStatusRequestReceived;
			/// <summary>
			/// TradingSessionStatus message receiving event
			/// </summary>
			public event Action<Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.TradingSessionStatus> TradingSessionStatusReceived;
			/// <summary>
			/// BidRequest message receiving event
			/// </summary>
			public event Action<Application.PreTrade.ListProgramBasketTrading.BidRequest> BidRequestReceived;
			/// <summary>
			/// BidResponse message receiving event
			/// </summary>
			public event Action<Application.PreTrade.ListProgramBasketTrading.BidResponse> BidResponseReceived;
			/// <summary>
			/// ExecutionReport message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.ExecutionReport> ExecutionReportReceived;
			/// <summary>
			/// OrderCancelReject message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelReject> OrderCancelRejectReceived;
			/// <summary>
			/// OrderSingle message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderSingle> OrderSingleReceived;
			/// <summary>
			/// OrderCancelRequest message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelRequest> OrderCancelRequestReceived;
			/// <summary>
			/// OrderCancelReplaceRequest message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelReplaceRequest> OrderCancelReplaceRequestReceived;
			/// <summary>
			/// OrderStatusRequest message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderStatusRequest> OrderStatusRequestReceived;
			/// <summary>
			/// DonTKnowTrade message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.DonTKnowTrade> DonTKnowTradeReceived;
			/// <summary>
			/// OrderList message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.OrderList> OrderListReceived;
			/// <summary>
			/// ListCancelRequest message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListCancelRequest> ListCancelRequestReceived;
			/// <summary>
			/// ListExecute message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListExecute> ListExecuteReceived;
			/// <summary>
			/// ListStatusRequest message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStatusRequest> ListStatusRequestReceived;
			/// <summary>
			/// ListStatus message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStatus> ListStatusReceived;
			/// <summary>
			/// ListStrikePrice message receiving event
			/// </summary>
			public event Action<Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStrikePrice> ListStrikePriceReceived;
			/// <summary>
			/// Allocation message receiving event
			/// </summary>
			public event Action<Application.PostTrade.AllocationAndReadyToBook.Allocation> AllocationReceived;
			/// <summary>
			/// AllocationACK message receiving event
			/// </summary>
			public event Action<Application.PostTrade.AllocationAndReadyToBook.AllocationACK> AllocationACKReceived;
			/// <summary>
			/// SettlementInstructions message receiving event
			/// </summary>
			public event Action<Application.PostTrade.SettlementInstructions.SettlementInstructions> SettlementInstructionsReceived;
			/// <summary>
			/// BusinessMessageReject message receiving event
			/// </summary>
			public event Action<Application.Other.CommonApplicationMessages.BusinessMessageReject> BusinessMessageRejectReceived;
			/// <summary>
			/// Heartbeat message receiving event
			/// </summary>
			public event Action<Session.Heartbeat> HeartbeatReceived;
			/// <summary>
			/// TestRequest message receiving event
			/// </summary>
			public event Action<Session.TestRequest> TestRequestReceived;
			/// <summary>
			/// ResendRequest message receiving event
			/// </summary>
			public event Action<Session.ResendRequest> ResendRequestReceived;
			/// <summary>
			/// Reject message receiving event
			/// </summary>
			public event Action<Session.Reject> RejectReceived;
			/// <summary>
			/// SequenceReset message receiving event
			/// </summary>
			public event Action<Session.SequenceReset> SequenceResetReceived;
			/// <summary>
			/// Logout message receiving event
			/// </summary>
			public event Action<Session.Logout> LogoutReceived;
			/// <summary>
			/// Logon message receiving event
			/// </summary>
			public event Action<Session.Logon> LogonReceived;
			/// <summary>
			/// Unrecognized message receiving event
			/// </summary>
			public event Action<Message> UnrecognizedMessageReceived;
			/// <summary>
			/// Typed messages process method
			/// </summary>
			private void ProcessMessage(Message message)
			{
				switch (message.Type)
				{
					case "6":
						if (IndicationOfInterestReceived != null) IndicationOfInterestReceived(new Application.PreTrade.Indication.IndicationOfInterest(message));
						break;
					case "7":
						if (AdvertisementReceived != null) AdvertisementReceived(new Application.PreTrade.Indication.Advertisement(message));
						break;
					case "B":
						if (NewsReceived != null) NewsReceived(new Application.PreTrade.EventCommunication.News(message));
						break;
					case "C":
						if (EmailReceived != null) EmailReceived(new Application.PreTrade.EventCommunication.Email(message));
						break;
					case "R":
						if (QuoteRequestReceived != null) QuoteRequestReceived(new Application.PreTrade.Quotation.QuoteRequest(message));
						break;
					case "S":
						if (QuoteReceived != null) QuoteReceived(new Application.PreTrade.Quotation.Quote(message));
						break;
					case "Z":
						if (QuoteCancelReceived != null) QuoteCancelReceived(new Application.PreTrade.Quotation.QuoteCancel(message));
						break;
					case "a":
						if (QuoteStatusRequestReceived != null) QuoteStatusRequestReceived(new Application.PreTrade.Quotation.QuoteStatusRequest(message));
						break;
					case "b":
						if (QuoteAcknowledgementReceived != null) QuoteAcknowledgementReceived(new Application.PreTrade.Quotation.QuoteAcknowledgement(message));
						break;
					case "i":
						if (MassQuoteReceived != null) MassQuoteReceived(new Application.PreTrade.Quotation.MassQuote(message));
						break;
					case "V":
						if (MarketDataRequestReceived != null) MarketDataRequestReceived(new Application.PreTrade.MarketData.MarketDataRequest(message));
						break;
					case "W":
						if (MarketDataSnapshotFullRefreshReceived != null) MarketDataSnapshotFullRefreshReceived(new Application.PreTrade.MarketData.MarketDataSnapshotFullRefresh(message));
						break;
					case "X":
						if (MarketDataIncrementalRefreshReceived != null) MarketDataIncrementalRefreshReceived(new Application.PreTrade.MarketData.MarketDataIncrementalRefresh(message));
						break;
					case "Y":
						if (MarketDataRequestRejectReceived != null) MarketDataRequestRejectReceived(new Application.PreTrade.MarketData.MarketDataRequestReject(message));
						break;
					case "c":
						if (SecurityDefinitionRequestReceived != null) SecurityDefinitionRequestReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityDefinitionRequest(message));
						break;
					case "d":
						if (SecurityDefinitionReceived != null) SecurityDefinitionReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityDefinition(message));
						break;
					case "e":
						if (SecurityStatusRequestReceived != null) SecurityStatusRequestReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityStatusRequest(message));
						break;
					case "f":
						if (SecurityStatusReceived != null) SecurityStatusReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.SecurityStatus(message));
						break;
					case "g":
						if (TradingSessionStatusRequestReceived != null) TradingSessionStatusRequestReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.TradingSessionStatusRequest(message));
						break;
					case "h":
						if (TradingSessionStatusReceived != null) TradingSessionStatusReceived(new Application.PreTrade.SecurityAndTradingSessionDefinitionStatus.TradingSessionStatus(message));
						break;
					case "k":
						if (BidRequestReceived != null) BidRequestReceived(new Application.PreTrade.ListProgramBasketTrading.BidRequest(message));
						break;
					case "l":
						if (BidResponseReceived != null) BidResponseReceived(new Application.PreTrade.ListProgramBasketTrading.BidResponse(message));
						break;
					case "8":
						if (ExecutionReportReceived != null) ExecutionReportReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.ExecutionReport(message));
						break;
					case "9":
						if (OrderCancelRejectReceived != null) OrderCancelRejectReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelReject(message));
						break;
					case "D":
						if (OrderSingleReceived != null) OrderSingleReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderSingle(message));
						break;
					case "F":
						if (OrderCancelRequestReceived != null) OrderCancelRequestReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelRequest(message));
						break;
					case "G":
						if (OrderCancelReplaceRequestReceived != null) OrderCancelReplaceRequestReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderCancelReplaceRequest(message));
						break;
					case "H":
						if (OrderStatusRequestReceived != null) OrderStatusRequestReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.OrderStatusRequest(message));
						break;
					case "Q":
						if (DonTKnowTradeReceived != null) DonTKnowTradeReceived(new Application.OrdersAndExecutionsTrade.SingleGeneralOrderHandling.DonTKnowTrade(message));
						break;
					case "E":
						if (OrderListReceived != null) OrderListReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.OrderList(message));
						break;
					case "K":
						if (ListCancelRequestReceived != null) ListCancelRequestReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListCancelRequest(message));
						break;
					case "L":
						if (ListExecuteReceived != null) ListExecuteReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListExecute(message));
						break;
					case "M":
						if (ListStatusRequestReceived != null) ListStatusRequestReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStatusRequest(message));
						break;
					case "N":
						if (ListStatusReceived != null) ListStatusReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStatus(message));
						break;
					case "m":
						if (ListStrikePriceReceived != null) ListStrikePriceReceived(new Application.OrdersAndExecutionsTrade.ListProgramBasketTrading.ListStrikePrice(message));
						break;
					case "J":
						if (AllocationReceived != null) AllocationReceived(new Application.PostTrade.AllocationAndReadyToBook.Allocation(message));
						break;
					case "P":
						if (AllocationACKReceived != null) AllocationACKReceived(new Application.PostTrade.AllocationAndReadyToBook.AllocationACK(message));
						break;
					case "T":
						if (SettlementInstructionsReceived != null) SettlementInstructionsReceived(new Application.PostTrade.SettlementInstructions.SettlementInstructions(message));
						break;
					case "j":
						if (BusinessMessageRejectReceived != null) BusinessMessageRejectReceived(new Application.Other.CommonApplicationMessages.BusinessMessageReject(message));
						break;
					case "0":
						if (HeartbeatReceived != null) HeartbeatReceived(new Session.Heartbeat(message));
						break;
					case "1":
						if (TestRequestReceived != null) TestRequestReceived(new Session.TestRequest(message));
						break;
					case "2":
						if (ResendRequestReceived != null) ResendRequestReceived(new Session.ResendRequest(message));
						break;
					case "3":
						if (RejectReceived != null) RejectReceived(new Session.Reject(message));
						break;
					case "4":
						if (SequenceResetReceived != null) SequenceResetReceived(new Session.SequenceReset(message));
						break;
					case "5":
						if (LogoutReceived != null) LogoutReceived(new Session.Logout(message));
						break;
					case "A":
						if (LogonReceived != null) LogonReceived(new Session.Logon(message));
						break;
					default:
						if (UnrecognizedMessageReceived != null) UnrecognizedMessageReceived(message);
						break;
				}
			}

		}

	}
